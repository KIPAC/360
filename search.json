[
  {
    "objectID": "lectures/preliminaries.html",
    "href": "lectures/preliminaries.html",
    "title": "Preliminaries",
    "section": "",
    "text": "Have a good understanding of what to expect from this course\nLearn about the grading policy, assignments and final project scope\n\n\n\n\nThis course is directed at first/second year graduate students interested in astrophysics research. We cover a few of the important physical processes necessary to understand astronomical objects and observations. The course will use python notebooks throughout helping with experiential learning and give the student resources to explore the code/formulas and algorithms behind the plots and animations.\n\n\n\n\n\n\nA useful free textbook for a number of theoretical concepts by Nick Kaiser: Elements of Astrophysics: Link to PDF\nBinney and Tremaine (2008) is a key reference for Galactic Dynamics.\nFundamentals of Astrophysical Fluid Dynamics by Kato and Fukue (2020) is recent and has a large scope with interesting discussion of fluids and radiation physics.\nIf you have access through Stanford libraries I’ll also add some .pdf files to the files section in the course Canvas site.\n\n\n\n\nIn short: 4 lectures on gravity,  4 on fluids,  4 on radiation, \n          4 on special topics and 4 with student presentations = 20 meeting times\n\nRough Calendar [will change]                     Reading              Problem Set              \nTu  1 Jan 7   Intro/Overview/Gravity             K:285-300            Workflow+\nTh  2 Jan 9   Gravity 3 ways | Stellar dynamics                       K: 26.7.1 p295 + 1-2 page Proposal\nTu  3 Jan 14  Cosmology + Zeldovich approx.      K:303+5,337+3,385+3  Bertschinger Dust Solution      \nTh  4 Jan 16  Hydrodynamics           I)         K:246-247,251-253                                   \nTu  5 Jan 21  Hydrodynamics          II)                                                                     \nTh  6 Jan 23  Sound Waves, Shocks & Sedov Taylor K:258,22.2,23.2      K:20.10.3 + Bertsch. g=5/3  \nTu  7 Jan 28  Radiation                          K:61-69                                             \nTh  8 Jan 30  Radiation Transport                K:81-89              K:6.12.1-4 +                \nTu  9 Feb  4  Radiative Processes   I)                                                               \nTh 10 Feb  6  Radiative Processes  II)                                                               \nTu 11 Feb 11  Radiative Processes III)                                K:14.9.2-3 +                \nTh 12 Feb 13  AT   I)  Spectra of Galaxies       Notes\nTu 13 Feb 18  AT  II)  HII regions               Notes                                           \nTh 14 Feb 20  AT III)  Press Schechter theory    Notes               reproduce Mo & White 98                                            \nTu 15 Feb 25  AT  IV)  Summary Statistics        Notes \nTh 16 Feb 27  AT   V)  Plasmas/Acceleration      Notes                                          \nTu 17 Mar  4  Presentations   I\nTh 18 Mar  6  Presentations  II                                                                       \nTu 19 Mar 11  Presentations III                                                                       \nTh 20 Mar 13  Presentations  IV                                                                       \n\n\n\n\n40% Final project and presentation\n\n60% Problem set (worst dropped)\n\n\nTesting our python code setup:\n\n\nCode\nimport sys\nsys.path.append('../code')\nfrom astro_utils import hello_astrophysics\n\nhello_astrophysics()\nimport sys\nprint(sys.executable)\n\n\nHello astrophysics! \n/Users/tabel/pyEnvs/k3dEnv/bin/python3"
  },
  {
    "objectID": "lectures/preliminaries.html#learning-goals",
    "href": "lectures/preliminaries.html#learning-goals",
    "title": "Preliminaries",
    "section": "",
    "text": "Have a good understanding of what to expect from this course\nLearn about the grading policy, assignments and final project scope"
  },
  {
    "objectID": "lectures/preliminaries.html#modern-astrophysics",
    "href": "lectures/preliminaries.html#modern-astrophysics",
    "title": "Preliminaries",
    "section": "",
    "text": "This course is directed at first/second year graduate students interested in astrophysics research. We cover a few of the important physical processes necessary to understand astronomical objects and observations. The course will use python notebooks throughout helping with experiential learning and give the student resources to explore the code/formulas and algorithms behind the plots and animations."
  },
  {
    "objectID": "lectures/preliminaries.html#course-notes-and-schedule",
    "href": "lectures/preliminaries.html#course-notes-and-schedule",
    "title": "Preliminaries",
    "section": "",
    "text": "A useful free textbook for a number of theoretical concepts by Nick Kaiser: Elements of Astrophysics: Link to PDF\nBinney and Tremaine (2008) is a key reference for Galactic Dynamics.\nFundamentals of Astrophysical Fluid Dynamics by Kato and Fukue (2020) is recent and has a large scope with interesting discussion of fluids and radiation physics.\nIf you have access through Stanford libraries I’ll also add some .pdf files to the files section in the course Canvas site.\n\n\n\n\nIn short: 4 lectures on gravity,  4 on fluids,  4 on radiation, \n          4 on special topics and 4 with student presentations = 20 meeting times\n\nRough Calendar [will change]                     Reading              Problem Set              \nTu  1 Jan 7   Intro/Overview/Gravity             K:285-300            Workflow+\nTh  2 Jan 9   Gravity 3 ways | Stellar dynamics                       K: 26.7.1 p295 + 1-2 page Proposal\nTu  3 Jan 14  Cosmology + Zeldovich approx.      K:303+5,337+3,385+3  Bertschinger Dust Solution      \nTh  4 Jan 16  Hydrodynamics           I)         K:246-247,251-253                                   \nTu  5 Jan 21  Hydrodynamics          II)                                                                     \nTh  6 Jan 23  Sound Waves, Shocks & Sedov Taylor K:258,22.2,23.2      K:20.10.3 + Bertsch. g=5/3  \nTu  7 Jan 28  Radiation                          K:61-69                                             \nTh  8 Jan 30  Radiation Transport                K:81-89              K:6.12.1-4 +                \nTu  9 Feb  4  Radiative Processes   I)                                                               \nTh 10 Feb  6  Radiative Processes  II)                                                               \nTu 11 Feb 11  Radiative Processes III)                                K:14.9.2-3 +                \nTh 12 Feb 13  AT   I)  Spectra of Galaxies       Notes\nTu 13 Feb 18  AT  II)  HII regions               Notes                                           \nTh 14 Feb 20  AT III)  Press Schechter theory    Notes               reproduce Mo & White 98                                            \nTu 15 Feb 25  AT  IV)  Summary Statistics        Notes \nTh 16 Feb 27  AT   V)  Plasmas/Acceleration      Notes                                          \nTu 17 Mar  4  Presentations   I\nTh 18 Mar  6  Presentations  II                                                                       \nTu 19 Mar 11  Presentations III                                                                       \nTh 20 Mar 13  Presentations  IV                                                                       \n\n\n\n\n40% Final project and presentation\n\n60% Problem set (worst dropped)\n\n\nTesting our python code setup:\n\n\nCode\nimport sys\nsys.path.append('../code')\nfrom astro_utils import hello_astrophysics\n\nhello_astrophysics()\nimport sys\nprint(sys.executable)\n\n\nHello astrophysics! \n/Users/tabel/pyEnvs/k3dEnv/bin/python3"
  },
  {
    "objectID": "lectures/hydro.html",
    "href": "lectures/hydro.html",
    "title": "Continua",
    "section": "",
    "text": "Learning Goals\n\nExplore Astrophysical Hydrodynamics\nCover some commonly used spherical distributions\nKey systems\n\nShocktubes\nSpherical winds, accretion\nHydrostatic equilibria\n\nExplore some typical hydro setups using pyro package.\nLearn key principles of numerical methods used in fluid dynamics\n\nLagrangian vs Eulerian\nGoudonov methods\n\n\n\n\nCollision-less Systems"
  },
  {
    "objectID": "tutorials/pyro_tutorial.html",
    "href": "tutorials/pyro_tutorial.html",
    "title": "Pyro tutorial",
    "section": "",
    "text": "Mike Zingale wrote a pedagogical library describing some of the numerical methods often found in astrophysical hydrodynamics called pyro. You can fin the code on github.\nfrom pyro import Pyro\nsolver = \"compressible\"\nproblem_name = \"sod\"\nparam_file = \"inputs.sod.x\"\npyro_sim = Pyro(solver)\nextra_parameters = {'vis.dovis': False, 'mesh.nx': 128, 'mesh.ny':4, 'particles.do_particles': False, \"eos.gamma\":1.01}\npyro_sim.initialize_problem(problem_name, inputs_file=param_file, inputs_dict=extra_parameters)\nprint(pyro_sim)\n\nSolver = compressible\nProblem = sod\nSimulation time = 0.0\nSimulation step number = 0\n\nRuntime Parameters\n------------------\ncompressible.cvisc = 0.1\ncompressible.delta = 0.33\ncompressible.grav = 0.0\ncompressible.limiter = 1\ncompressible.riemann = HLLC\ncompressible.use_flattening = 1\ncompressible.z0 = 0.75\ncompressible.z1 = 0.85\ndriver.cfl = 0.8\ndriver.fix_dt = -1.0\ndriver.init_tstep_factor = 0.01\ndriver.max_dt_change = 2.0\ndriver.max_steps = 200\ndriver.tmax = 0.2\ndriver.verbose = 0\neos.gamma = 1.01\nio.basename = sod_x_\nio.do_io = 0\nio.dt_out = 0.05\nio.force_final_output = 0\nio.n_out = 10000\nmesh.grid_type = Cartesian2d\nmesh.nx = 128\nmesh.ny = 4\nmesh.xlboundary = outflow\nmesh.xmax = 1.0\nmesh.xmin = 0.0\nmesh.xrboundary = outflow\nmesh.ylboundary = reflect\nmesh.ymax = 0.05\nmesh.ymin = 0.0\nmesh.yrboundary = reflect\nparticles.do_particles = False\nparticles.n_particles = 100\nparticles.particle_generator = grid\nsod.dens_left = 1.0\nsod.dens_right = 0.125\nsod.direction = x\nsod.p_left = 1.0\nsod.p_right = 0.1\nsod.u_left = 0.0\nsod.u_right = 0.0\nsponge.do_sponge = 0\nsponge.sponge_rho_begin = 0.01\nsponge.sponge_rho_full = 0.001\nsponge.sponge_timescale = 0.01\nvis.dovis = False\nvis.store_images = 0\ng = pyro_sim.get_grid()\nimport matplotlib.pyplot as plt\n# Example: set \"bwr\" as the default colormap\npyro_sim.sim.cm = 'bwr'\npyro_sim.sim.dovis()\n\n\n\n\n\n\n\n\n&lt;Figure size 1000x1333.4 with 0 Axes&gt;\nfor i in range(10):\n    pyro_sim.single_step()\npyro_sim.sim.dovis()\n\n\n\n\n\n\n\n\n&lt;Figure size 1000x1333.4 with 0 Axes&gt;\nimport numpy as np\ndef precompute_shocktube(pyro_sim, ntotal, substeps=10):\n    \"\"\"\n    Run 'ntotal' steps of pyro_sim, storing all relevant fields\n    in a list so we can animate them later.\n    \"\"\"\n    states = np.empty(ntotal, dtype=object)\n    for i in range(ntotal):\n\n        # Grab data at this step\n        state_data = {\n            \"density\"   : pyro_sim.get_var(\"density\")[:, 4].copy(),\n            \"x_momentum\": pyro_sim.get_var(\"x-momentum\")[:, 4].copy(),\n            \"pressure\"  : pyro_sim.get_var(\"pressure\")[:, 4].copy(),\n            \"energy\"    : pyro_sim.get_var(\"energy\")[:, 4].copy(),\n            \"x\"         : pyro_sim.get_grid().x.copy(),\n            \"step\"      : pyro_sim.sim.n*substeps  # current step number\n        }\n        states[i] = state_data\n\n        for k in range(substeps):\n            pyro_sim.single_step()  # advance by one step\n        \n    return states\n\n\n#EOS_GAMMA = 5./3\nEOS_GAMMA = 1.001\n\nsolver = \"compressible\"\nproblem_name = \"sod\"\nparam_file = \"inputs.sod.x\"\npyro_sim = Pyro(solver)\nextra_parameters = {\"sod.p_left\" : 1000.0, \"eos.gamma\": EOS_GAMMA, 'driver.max_steps':1000, 'driver.tmax':1., 'vis.dovis': False, 'mesh.nx': 256, 'mesh.ny':2, 'particles.do_particles': False}\npyro_sim.initialize_problem(problem_name, inputs_file=param_file, inputs_dict=extra_parameters)\n\nntotal = 51\nstates = precompute_shocktube(pyro_sim, ntotal, substeps=4)\nimport ipywidgets as widgets\nfrom IPython.display import display\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\ndef shocktube_animation_app(states):\n    \"\"\"\n    Create an interactive slider + play widget to browse precomputed 'states'.\n\n    Parameters\n    ----------\n    states : list of dict\n        Each element is a dictionary with keys:\n         - \"density\", \"x_momentum\", \"pressure\", \"energy\" (arrays)\n         - \"x\": the spatial coordinate array\n         - \"step\": integer time step index\n\n    Returns\n    -------\n    ui : widgets.VBox\n        A VBox widget containing the slider, play controls, and the plot output.\n    \"\"\"\n    # The total number of precomputed states\n    ntotal = len(states)\n\n    # 1) Create a slider to pick the index in [0, ntotal-1]\n    slider = widgets.IntSlider(value=0, min=0, max=ntotal - 1, step=1,\n        description='Step', continuous_update=False)\n\n    # 2) Create a Play widget for auto animation\n    play = widgets.Play(value=0, min=0, max=ntotal - 1,\n        step=1,interval=200,       # ms between frames\n        description=\"Press play\", disabled=False)\n\n    # Link the Play widget and the slider\n    widgets.jslink((play, 'value'), (slider, 'value'))\n    widgets.jslink((slider, 'value'), (play, 'value'))\n\n    # 3) Create an output area for the Plotly figure\n    output_area = widgets.Output()\n\n    def update_plot(change=None):\n        \"\"\"Draw the figure for the current slider value.\"\"\"\n        index = slider.value\n        state = states[index]\n\n        with output_area:\n            # Extract data\n            x          = state[\"x\"]\n            step_num   = state[\"step\"]\n\n            # Build the figure\n            fig = make_subplots( rows=2, cols=2,\n                subplot_titles=[\"Density\", \"X-Momentum\", \"Pressure\", \"Energy\"],\n                vertical_spacing=0.09 )\n\n            # 2x2 subplots\n            fig.add_trace(go.Scatter(x=x, y=state[\"density\"],    mode='lines+markers'), row=1, col=1)\n            fig.add_trace(go.Scatter(x=x, y=state[\"x_momentum\"], mode='lines+markers'), row=1, col=2)\n            fig.add_trace(go.Scatter(x=x, y=state[\"pressure\"],   mode='lines+markers'), row=2, col=1)\n            fig.add_trace(go.Scatter(x=x, y=state[\"energy\"],     mode='lines+markers'), row=2, col=2)\n            fig.update_layout( title=f\"Shocktube Data — Step {step_num}\",\n                showlegend=False, height=500, width=800,\n                margin=dict(l=60, r=60, t=60, b=60) )\n\n            # Show with \"notebook\" renderer so repeated calls don't stack new outputs\n            output_area.clear_output(wait=True)\n            fig.show(\"notebook\")\n            \n    # 4) Observe slider changes =&gt; call update_plot\n    slider.observe(update_plot, names='value')\n    # 5) Initial figure\n    update_plot()\n    # 6) Combine play+slider+figure into a single UI\n    controls = widgets.HBox([play, slider])\n    ui = widgets.VBox([controls, output_area])\n\n    return ui\n# 3) Build the animation app\napp = shocktube_animation_app(states)\n\n# 4) Display in Jupyter\ndisplay(app)\nd = pyro_sim.get_var(\"density\").copy()\nd.pretty_print(show_ghost=False)\n\n         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1   0.99998   0.99986   0.99871   0.99364   0.98504   0.97417     0.962   0.94915   0.93598    0.9227   0.90942   0.89621    0.8831   0.87011   0.85727   0.84457   0.83203   0.81965   0.80743   0.79537   0.78348   0.77176   0.76019   0.74879   0.73755   0.72648   0.71556    0.7048    0.6942   0.68375   0.67346   0.66332   0.65333   0.64349   0.63379   0.62424   0.61483   0.60557   0.59644   0.58745    0.5786   0.56988   0.56129   0.55283   0.54451    0.5363   0.52823   0.52027   0.51244   0.50473   0.49713   0.48965   0.48229   0.47504    0.4679   0.46087   0.45396   0.44714   0.44044   0.43384   0.42734   0.42095   0.41466   0.40847   0.40239   0.39641   0.39053   0.38475   0.37908   0.37349   0.36799   0.36261   0.35705   0.35158   0.34622   0.34098   0.33583   0.33077    0.3258   0.32091    0.3161   0.31136    0.3067   0.30211   0.29761   0.29317   0.28881   0.28453   0.28032   0.27618   0.27211   0.26812    0.2642   0.26035   0.25656   0.25284   0.24918   0.24559   0.24207   0.23868   0.23561   0.23338   0.23282   0.23282   0.23293   0.23346   0.23442   0.23559    0.2367   0.23759   0.23824   0.23871   0.23905   0.23933   0.23956   0.23977   0.23995   0.24011   0.24026   0.24039   0.24052   0.24064   0.24075   0.24086   0.24096   0.24105   0.24114   0.24123   0.24131    0.2414   0.24148   0.24155   0.24162   0.24169   0.24176   0.24182   0.24188   0.24194   0.24199   0.24204    0.2421   0.24216   0.24223   0.24231   0.24236   0.24237   0.24237   0.24237   0.24238   0.24247   0.24261   0.24274   0.24282    0.2429   0.24317   0.24448   0.25226   0.29928   0.57678    1.3464    2.4043    3.1663     3.182    2.0028   0.33391   0.12518     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125 \n         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1   0.99998   0.99986   0.99871   0.99364   0.98504   0.97417     0.962   0.94915   0.93598    0.9227   0.90942   0.89621    0.8831   0.87011   0.85727   0.84457   0.83203   0.81965   0.80743   0.79537   0.78348   0.77176   0.76019   0.74879   0.73755   0.72648   0.71556    0.7048    0.6942   0.68375   0.67346   0.66332   0.65333   0.64349   0.63379   0.62424   0.61483   0.60557   0.59644   0.58745    0.5786   0.56988   0.56129   0.55283   0.54451    0.5363   0.52823   0.52027   0.51244   0.50473   0.49713   0.48965   0.48229   0.47504    0.4679   0.46087   0.45396   0.44714   0.44044   0.43384   0.42734   0.42095   0.41466   0.40847   0.40239   0.39641   0.39053   0.38475   0.37908   0.37349   0.36799   0.36261   0.35705   0.35158   0.34622   0.34098   0.33583   0.33077    0.3258   0.32091    0.3161   0.31136    0.3067   0.30211   0.29761   0.29317   0.28881   0.28453   0.28032   0.27618   0.27211   0.26812    0.2642   0.26035   0.25656   0.25284   0.24918   0.24559   0.24207   0.23868   0.23561   0.23338   0.23282   0.23282   0.23293   0.23346   0.23442   0.23559    0.2367   0.23759   0.23824   0.23871   0.23905   0.23933   0.23956   0.23977   0.23995   0.24011   0.24026   0.24039   0.24052   0.24064   0.24075   0.24086   0.24096   0.24105   0.24114   0.24123   0.24131    0.2414   0.24148   0.24155   0.24162   0.24169   0.24176   0.24182   0.24188   0.24194   0.24199   0.24204    0.2421   0.24216   0.24223   0.24231   0.24236   0.24237   0.24237   0.24237   0.24238   0.24247   0.24261   0.24274   0.24282    0.2429   0.24317   0.24448   0.25226   0.29928   0.57678    1.3464    2.4043    3.1663     3.182    2.0028   0.33391   0.12518     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125     0.125 \n\n         ^ y\n         |\n         +---&gt; x"
  },
  {
    "objectID": "tutorials/pyro_tutorial.html#d-examples-of-fluid-instabilities",
    "href": "tutorials/pyro_tutorial.html#d-examples-of-fluid-instabilities",
    "title": "Pyro tutorial",
    "section": "2D examples of Fluid Instabilities",
    "text": "2D examples of Fluid Instabilities\nHere we’ll compare how different compressible solvers perform when run with the same problem setup.\n\nRayleigh-Taylor instability\n\np = Pyro(\"compressible\")\np.initialize_problem(\"rt\")\nprint(p)\n\nSolver = compressible\nProblem = rt\nSimulation time = 0.0\nSimulation step number = 0\n\nRuntime Parameters\n------------------\ncompressible.cvisc = 0.1\ncompressible.delta = 0.33\ncompressible.grav = -1.0\ncompressible.limiter = 2\ncompressible.riemann = HLLC\ncompressible.use_flattening = 1\ncompressible.z0 = 0.75\ncompressible.z1 = 0.85\ndriver.cfl = 0.8\ndriver.fix_dt = -1.0\ndriver.init_tstep_factor = 0.01\ndriver.max_dt_change = 2.0\ndriver.max_steps = 10000\ndriver.tmax = 3.0\ndriver.verbose = 0\neos.gamma = 1.4\nio.basename = rt_\nio.do_io = 0\nio.dt_out = 0.1\nio.force_final_output = 0\nio.n_out = 100\nmesh.grid_type = Cartesian2d\nmesh.nx = 64\nmesh.ny = 192\nmesh.xlboundary = periodic\nmesh.xmax = 1.0\nmesh.xmin = 0.0\nmesh.xrboundary = periodic\nmesh.ylboundary = hse\nmesh.ymax = 3.0\nmesh.ymin = 0.0\nmesh.yrboundary = hse\nparticles.do_particles = 0\nparticles.n_particles = 100\nparticles.particle_generator = grid\nrt.amp = 0.25\nrt.dens1 = 1.0\nrt.dens2 = 2.0\nrt.p0 = 10.0\nrt.sigma = 0.1\nsponge.do_sponge = 0\nsponge.sponge_rho_begin = 0.01\nsponge.sponge_rho_full = 0.001\nsponge.sponge_timescale = 0.01\nvis.dovis = 0\nvis.store_images = 0\n\n\n\n\np.run_sim()\np.sim.dovis()\n\n\n\n\n\n\n\n\n&lt;Figure size 1000x1333.4 with 0 Axes&gt;\n\n\n\np = Pyro(\"compressible\")\np.initialize_problem(\"kh\")\nprint(p)\n\nSolver = compressible\nProblem = kh\nSimulation time = 0.0\nSimulation step number = 0\n\nRuntime Parameters\n------------------\ncompressible.cvisc = 0.1\ncompressible.delta = 0.33\ncompressible.grav = 0.0\ncompressible.limiter = 2\ncompressible.riemann = HLLC\ncompressible.use_flattening = 1\ncompressible.z0 = 0.75\ncompressible.z1 = 0.85\ndriver.cfl = 0.8\ndriver.fix_dt = -1.0\ndriver.init_tstep_factor = 0.01\ndriver.max_dt_change = 2.0\ndriver.max_steps = 5000\ndriver.tmax = 2.0\ndriver.verbose = 0\neos.gamma = 1.4\nio.basename = kh_\nio.do_io = 0\nio.dt_out = 0.1\nio.force_final_output = 0\nio.n_out = 10000\nkh.bulk_velocity = 0.0\nkh.rho_1 = 1\nkh.rho_2 = 2\nkh.u_1 = -0.5\nkh.u_2 = 0.5\nmesh.grid_type = Cartesian2d\nmesh.nx = 64\nmesh.ny = 64\nmesh.xlboundary = periodic\nmesh.xmax = 1.0\nmesh.xmin = 0.0\nmesh.xrboundary = periodic\nmesh.ylboundary = periodic\nmesh.ymax = 1.0\nmesh.ymin = 0.0\nmesh.yrboundary = periodic\nparticles.do_particles = 0\nparticles.n_particles = 100\nparticles.particle_generator = grid\nsponge.do_sponge = 0\nsponge.sponge_rho_begin = 0.01\nsponge.sponge_rho_full = 0.001\nsponge.sponge_timescale = 0.01\nvis.dovis = 0\nvis.store_images = 0\n\n\n\n\nruns = []\nsolvers = [\"compressible\", \"compressible_rk\", \"compressible_fv4\"]\nparams = {\"mesh.nx\": 96, \"mesh.ny\": 96,\n          \"kh.bulk_velocity\": 3.0}\n\n\nfor s in solvers:\n    p = Pyro(s)\n    p.initialize_problem(problem_name=\"kh\", inputs_dict=params)\n    p.run_sim()\n    runs.append(p)\n\n\nfig = plt.figure(figsize=(7, 5))\ngrid = ImageGrid(fig, 111, nrows_ncols=(1, len(runs)), axes_pad=0.1,\n                 share_all=True, cbar_mode=\"single\", cbar_location=\"right\")\n\nfor ax, s, p in zip(grid, solvers, runs):\n    rho = p.get_var(\"density\")\n    g = p.get_grid()\n    im = ax.imshow(rho.v().T,\n                   extent=[g.xmin, g.xmax, g.ymin, g.ymax],\n                   origin=\"lower\", vmin=0.9, vmax=2.1)\n    ax.set_title(s, fontsize=\"small\")\ngrid.cbar_axes[0].colorbar(im)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[30], line 2\n      1 fig = plt.figure(figsize=(7, 5))\n----&gt; 2 grid = ImageGrid(fig, 111, nrows_ncols=(1, len(runs)), axes_pad=0.1,\n      3                  share_all=True, cbar_mode=\"single\", cbar_location=\"right\")\n      5 for ax, s, p in zip(grid, solvers, runs):\n      6     rho = p.get_var(\"density\")\n\nNameError: name 'ImageGrid' is not defined\n\n\n\n&lt;Figure size 700x500 with 0 Axes&gt;"
  },
  {
    "objectID": "tutorials/gala_tutorial.html",
    "href": "tutorials/gala_tutorial.html",
    "title": "gala tutorial",
    "section": "",
    "text": "Learning Outcomes\n\n\n\n\n\n\nGain familiarity with gala package\nExplore some static potentials of the MW\nDo some orbit integrations and get some first impressions\n\n\n\n\n\n\nCode\n# Orbits\nimport astropy.units as u\n#%matplotlib widget\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport gala.integrate as gi\nimport gala.dynamics as gd\nimport gala.potential as gp\nfrom gala.units import galactic\nimport plotly.graph_objects as go\n\nt_f = 4_000 # Myrs  # final time to integrate to\nn_steps = 4_000     # how many timesteps\ndt = t_f/n_steps\n\npot = gp.NFWPotential.from_circular_velocity(v_c=200*u.km/u.s,\n                                             r_s=10.*u.kpc,\n                                             units=galactic)\n\nmpot = gp.MilkyWayPotential()\n\nics = gd.PhaseSpacePosition(pos=[10,0,0.] * u.kpc,\n                            vel=[0,214,0] * u.km/u.s)\n#orbit = gp.Hamiltonian(pot).integrate_orbit(ics, dt=dt, n_steps=n_steps)\n\norbit = gp.Hamiltonian(pot).integrate_orbit(ics, dt=dt, n_steps=n_steps,\n                            Integrator=gi.DOPRI853Integrator)\n\nmorbit = gp.Hamiltonian(mpot).integrate_orbit(ics, dt=dt, n_steps=n_steps,\n                            Integrator=gi.DOPRI853Integrator)\n\n\n\n\nCode\ngrid = np.linspace(-15,15,64)\nfig,ax = plt.subplots(1, 1, figsize=(5,5))\nfig = pot.plot_contours(grid=(grid,grid,0), cmap='Greys', ax=ax)\nfig = orbit[:].plot(['x', 'y'], color='#9ecae1', alpha=0.35, axes=[ax], auto_aspect=False) \nfig = morbit[:].plot(['x', 'y'], color='#fecae1', alpha=0.35, axes=[ax], auto_aspect=False) \nplt.title(\"orbit\");\n\n\n\n\n\n\n\n\n\n\n\nCode\nnorbits = 128\nnp.random.seed(3)\nnew_pos = np.random.normal(ics.pos.xyz.to(u.pc).value, 100.,\n                           size=(norbits,3)).T * u.pc\nnew_vel = np.random.normal(ics.vel.d_xyz.to(u.km/u.s).value, 1.,\n                           size=(norbits,3)).T * u.km/u.s\nnew_ics = gd.PhaseSpacePosition(pos=new_pos, vel=new_vel)\norbits = gp.Hamiltonian(mpot).integrate_orbit(new_ics, dt=0.4, n_steps=10_000,\n                            Integrator=gi.DOPRI853Integrator)\n\n\n\n\nCode\ngrid = np.linspace(-15,15,64)\nfig,ax = plt.subplots(1, 1, figsize=(5,5))\nfig = pot.plot_contours(grid=(grid,grid,0), cmap='Greys', ax=ax)\nfig = orbits[0].plot(['x', 'y'], color='#9ecae1', s=3., alpha=0.5,\n                      axes=[ax], auto_aspect=False) \nplt.title(\"Initial distribution\");\n\n\n\n\n\n\n\n\n\n\n\nCode\ngrid = np.linspace(-15,15,64)\nfig,ax = plt.subplots(1, 1, figsize=(5,5))\nfig = pot.plot_contours(grid=(grid,grid,0), cmap='Greys', ax=ax)\nfig = orbits[-1].plot(['x', 'y'], color='#9ecae1', s=3., alpha=0.5,\n                      axes=[ax], auto_aspect=False) \nplt.title(\"final distribution\");\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport plotly.graph_objects as go\nfrom astropy import units as u\n\n# Subsample orbit data and convert units\nvorbits = orbits[::5]\nx, y, z = [getattr(vorbits, coord).to(u.kpc).value for coord in ['x', 'y', 'z']]\ntime = vorbits.t.to(u.Myr).value\n\n# Fixed camera view\ncamera = dict(eye=dict(x=1.2, y=1.2, z=1.2))\n\n# Create animation frames\nframes = [\n    go.Frame(\n        data=[\n            go.Scatter3d(\n                x=x[i], y=y[i], z=z[i],  # Current position\n                mode='markers',\n                marker=dict(color='blue', size=4,opacity=0.25)\n            )\n        ],\n        name=f\"Frame {i}\"\n    )\n    for i in range(len(time))\n]\n\n# Define the figure\nfig = go.Figure(\n    data=[\n        go.Scatter3d(x=x[0], y=y[0], z=z[0], mode='markers', marker=dict(color='blue', size=7))\n    ],\n    layout=dict(\n        title=\"Interactive Orbit Visualization\",\n        scene=dict(\n            xaxis=dict(title=\"X [kpc]\", range=[x.min(), x.max()]),\n            yaxis=dict(title=\"Y [kpc]\", range=[y.min(), y.max()]),\n            zaxis=dict(title=\"Z [kpc]\", range=[x.min(), x.max()]),\n            camera=camera\n        ),\n        updatemenus=[{\n            \"buttons\": [\n                {\"args\": [None, {\"frame\": {\"duration\": 50}, \"fromcurrent\": True}], \"label\": \"Play\", \"method\": \"animate\"},\n                {\"args\": [[None], {\"frame\": {\"duration\": 0}, \"mode\": \"immediate\"}], \"label\": \"Pause\", \"method\": \"animate\"}\n            ],\n            \"type\": \"buttons\",\n        }],\n        width=700,  # Make the plot area larger\n        height=900\n    ),\n    frames=frames\n)\n\n# Add slider\nfig.update_layout(\n    sliders=[{\n        \"steps\": [\n            {\n                \"args\": [[f.name], {\"frame\": {\"duration\": 0}, \"mode\": \"immediate\"}],\n                \"label\": f\"t={time[i]:.1f} Myr\",\n                \"method\": \"animate\"\n            }\n            for i, f in enumerate(frames)\n        ],\n        \"len\": 0.5,  # Half the slider width\n        \"currentvalue\": {\"prefix\": \"Time: \", \"font\": {\"size\": 14}},\n        \"pad\": {\"t\": 50}  # Adjust padding for compactness,\n    }]\n)\n\nfig.show()"
  },
  {
    "objectID": "tutorials/WavelengthAbsorptionLineModeller.html",
    "href": "tutorials/WavelengthAbsorptionLineModeller.html",
    "title": "A web ready dashboard.",
    "section": "",
    "text": "import numpy as np\nimport panel as pn\nimport plotly.graph_objects as go\nfrom scipy.special import wofz\nfrom bokeh.models.formatters import BasicTickFormatter\n# Ensure Panel extensions are loaded\npn.extension(\"plotly\", \"mathjax\")\n\n# Physical constants\nc = 2.998e10  # Speed of light in cm/s\nk_B = 1.38e-16  # Boltzmann constant in erg/K\nh = 6.626e-27  # Planck's constant in erg·s\n\ndef voigt_profile(nu, nu_0, A21, T, m, v_shift):\n    \"\"\"Compute the Voigt profile given the input parameters.\"\"\"\n    delta_nu_D = (nu_0 / c) * np.sqrt(2 * k_B * T / m)  # Doppler broadening\n    gamma_L = A21 / (4 * np.pi)  # Lorentzian broadening\n    x = (nu - nu_0 - v_shift * nu_0 / c) / delta_nu_D\n    a = gamma_L / delta_nu_D\n    phi_V = np.real(wofz(x + 1j * a)) / (delta_nu_D * np.sqrt(np.pi))\n    return phi_V\n\n# Formatting for numerical display\nfs = BasicTickFormatter(use_scientific=True, precision=4)\n\n# Panel widgets\nlambda_0_slider = pn.widgets.FloatInput(name=\"λ₀ (Å)\", value=1215.67, step=1, format=fs)\nlambda_delta_slider = pn.widgets.FloatInput(name=\"plot 𝛅λ = (λ-λ₀)/λ₀ \", value=1e-3, step=1, format=fs)\nunit_selector = pn.widgets.RadioButtonGroup(name=\"X-Axis\", options=[\"THz\", \"Angstrom\"], value=\"Angstrom\")\nA21_slider = pn.widgets.FloatInput(name=\"A₂₁ (s⁻¹)\", value=4.69e8, step=1, format=fs)\nT_slider = pn.widgets.FloatInput(name=\"T (K)\", value=10000, step=100, format=fs)\nm_slider = pn.widgets.FloatInput(name=\"Mass (g)\", value=1.67e-24, step=1e-16, format=fs)\nv_shift_slider = pn.widgets.FloatInput(name=\"Velocity (km/s)\", value=0, step=1)\nN_slider = pn.widgets.FloatInput(name=\"Column Density N (cm⁻²)\", value=1e18, step=1e12, format=fs)\n\n# Create empty figures for interactive updates\nfig_voigt = go.Figure()\nfig_intensity = go.Figure()\n\n# Create a Panel Markdown pane for text updates\ntext_pane_dynamic = pn.pane.Markdown(\"### Thermal line width:\\n- **Loading...**\", width=400)\n\n# Panel Plotly panes\nplot_voigt_pane = pn.pane.Plotly(fig_voigt, config={'responsive': True})\nplot_intensity_pane = pn.pane.Plotly(fig_intensity, config={'responsive': True})\n\n# Function to update text dynamically\ndef update_text(dnu, nu_0):\n    return fr\"\"\"\n    ### Thermal Line Width:\n    - Doppler Width: **{dnu:.3e} Hz**\n    - Converted to Angstrom: **{(c*dnu/(nu_0*(nu_0+dnu))) * 1e8:.4g} Å**\n    - $$\\delta \\lambda/\\lambda \\sim $$ {(dnu/((nu_0+dnu))) * 1e8:.4g}\n    \"\"\"\n\n\ndef update_plot(event):\n    \"\"\"Update Plotly plots based on widget values.\"\"\"\n    \n    # Get current widget values\n    lambda_0 = lambda_0_slider.value\n    lambda_delta = lambda_delta_slider.value\n    unit = unit_selector.value\n    A21 = A21_slider.value\n    T = T_slider.value\n    m = m_slider.value\n    v_shift = v_shift_slider.value * 1e5  # Convert from km/s to cm/s\n    N = N_slider.value\n\n    # Convert wavelength (Å) to frequency (Hz)\n    nu_0 = c / (lambda_0 * 1e-8)\n\n    # Define frequency range\n    nu = np.linspace(nu_0 *(1 - lambda_delta), nu_0  *(1 + lambda_delta), 500)\n        \n    # Compute Voigt profile\n    phi_V = voigt_profile(nu, nu_0, A21, T, m, v_shift)   \n    \n    # Compute absorption coefficient\n    g2og1 = 1  # Assume g2/g1 = 2 for simplicity\n    B12 = (c**2 / (2 * h * nu_0**3)) * (A21 * g2og1)\n    alpha_nu = (h * nu_0 / (4 * np.pi)) * B12 * phi_V\n    tau = N * alpha_nu  # Optical depth\n    I = np.exp(-tau)  # Intensity\n\n    # Convert x-axis based on selection\n    if unit == \"Angstrom\":\n        x_values = c / nu * 1e8  # Convert Hz to Å\n        xlabel = \"Wavelength (Å)\"\n    else:\n        x_values = nu / 1e12  # Convert Hz to THz\n        xlabel = \"Frequency (THz)\"\n\n    # Update Voigt profile figure\n    fig_voigt.data = []\n    fig_voigt.add_trace(go.Scatter(x=x_values, y=phi_V, mode='lines', name=\"Voigt Profile\", line=dict(color='blue', shape='spline', smoothing=0.7)))\n    fig_voigt.update_layout(title=\"Absorption Line Profile\", xaxis_title=xlabel, yaxis_title=r'line profile', template=\"plotly_white\")\n\n    # Update Intensity figure\n    fig_intensity.data = []\n    fig_intensity.add_trace(go.Scatter(x=x_values, y=I, mode='lines', name=\"Intensity\", line=dict(color='red', shape='spline', smoothing=0.7)))\n    fig_intensity.update_layout(title=\"Intensity Profile\", xaxis_title=xlabel, yaxis_title=\"Intensity\", template=\"plotly_white\")\n\n    # Update Panel plot panes\n    plot_voigt_pane.object = fig_voigt\n    plot_intensity_pane.object = fig_intensity\n\n    # Add vertical line at λ₀\n    fig_voigt.add_shape(\n        type=\"line\",\n        x0=lambda_0, x1=lambda_0,\n        y0=0, y1=1,\n        xref=\"x\", yref=\"paper\",\n        line=dict(color=\"black\", width=2, dash=\"dot\")\n    )\n    \n    dnu = (nu_0 / c) * np.sqrt(2 * k_B * T / m)  # Doppler broadening\n    print(dnu*c/nu_0**2 * 1e8)\n    # ✅ Update the text dynamically\n    text_pane_dynamic.object = update_text(dnu,nu_0)\n\n# Attach widget callbacks\nlambda_0_slider.param.watch(update_plot, 'value')\nlambda_delta_slider.param.watch(update_plot, 'value')\nunit_selector.param.watch(update_plot, 'value')\nA21_slider.param.watch(update_plot, 'value')\nT_slider.param.watch(update_plot, 'value')\nm_slider.param.watch(update_plot, 'value')\nv_shift_slider.param.watch(update_plot, 'value')\nN_slider.param.watch(update_plot, 'value')\n\n# Initialize the plot with default values\nupdate_plot(None)\n\n# Create Panel layout\ndashboard = pn.Column(\n    pn.Row(lambda_0_slider, lambda_delta_slider, unit_selector),\n    pn.Row(A21_slider, T_slider),\n    pn.Row(m_slider, v_shift_slider),\n    pn.Row(N_slider,text_pane_dynamic),\n    pn.Row(plot_voigt_pane, plot_intensity_pane)\n)\n\n# Serve the dashboard\ndashboard.servable()\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n0.05214326865458927"
  },
  {
    "objectID": "tutorials/Intro_3D_visualization.html",
    "href": "tutorials/Intro_3D_visualization.html",
    "title": "Intro to 3D Visualization in python",
    "section": "",
    "text": "pyvista is your best bet to create informative visualizations of 3D data from within python. Yes, matplotlib and veusz have beautiful 3D plots as well but these are mostly restricted to relatively simple types of visualizations.\nYour best bet to install pyvista maybe\npip install 'jupyterlab&gt;=3' ipywidgets 'pyvista[all,trame]'\nas described at their userguide.\n```{python}\nimport numpy as np\nimport pyvista as pv\nimport ipywidgets as widgets\nimport gala.potential as gp\nimport astropy.units as u\npv.set_jupyter_backend('trame')  # or 'server'\n\nnx, ny, nz = 140, 140, 140\nextent = 60. \nx = np.linspace(-extent, extent, nx)\ny = np.linspace(-extent, extent, ny)\nz = np.linspace(-extent, extent, nz)\nX, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n\n\npotential = gp.MilkyWayPotential()\nrho = potential.density([X, Y, Z] * u.kpc).to_value(u.Msun / u.pc**3) #.reshape(nx, ny, nz)\nr = rho.flatten()\n\ngrid = pv.StructuredGrid(X, Y, Z)\ngrid[\"rho\"] = rho.ravel()\n\nplotter = pv.Plotter(notebook=True,lighting='three lights')\nplotter.enable_shadows()\n\ndef plot_iso(threshold=np.log10(np.percentile(r, 75.))):\n    plotter.clear()\n    iso = grid.contour(isosurfaces=[10**threshold/2,10**threshold,10**threshold*2], scalars='rho')\n    \n    # Compute per-vertex normals\n    iso = iso.compute_normals(cell_normals=False, split_vertices=True, auto_orient_normals=True)\n    \n    # Add the isosurface mesh\n    plotter.add_mesh(\n        iso, opacity=0.3,\n        smooth_shading=False, \n        show_edges=False, cmap=\"plasma\")\n\n    \n    # Eye-dome lighting can help\n#    plotter.enable_eye_dome_lighting()\n\n    # Update the scene in the same cell\n    plotter.show(interactive_update=True)\n\nwidgets.interact(plot_iso, threshold=((np.log10(np.percentile(r, 0.1)), np.log10(np.percentile(r, 99.9)), \n                                    (np.log10(np.percentile(r, 99.9))-np.log10(np.percentile(r, 0.1)))/100)));\n```"
  },
  {
    "objectID": "tutorials/Intro_3D_visualization.html#pyvista",
    "href": "tutorials/Intro_3D_visualization.html#pyvista",
    "title": "Intro to 3D Visualization in python",
    "section": "",
    "text": "pyvista is your best bet to create informative visualizations of 3D data from within python. Yes, matplotlib and veusz have beautiful 3D plots as well but these are mostly restricted to relatively simple types of visualizations.\nYour best bet to install pyvista maybe\npip install 'jupyterlab&gt;=3' ipywidgets 'pyvista[all,trame]'\nas described at their userguide.\n```{python}\nimport numpy as np\nimport pyvista as pv\nimport ipywidgets as widgets\nimport gala.potential as gp\nimport astropy.units as u\npv.set_jupyter_backend('trame')  # or 'server'\n\nnx, ny, nz = 140, 140, 140\nextent = 60. \nx = np.linspace(-extent, extent, nx)\ny = np.linspace(-extent, extent, ny)\nz = np.linspace(-extent, extent, nz)\nX, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n\n\npotential = gp.MilkyWayPotential()\nrho = potential.density([X, Y, Z] * u.kpc).to_value(u.Msun / u.pc**3) #.reshape(nx, ny, nz)\nr = rho.flatten()\n\ngrid = pv.StructuredGrid(X, Y, Z)\ngrid[\"rho\"] = rho.ravel()\n\nplotter = pv.Plotter(notebook=True,lighting='three lights')\nplotter.enable_shadows()\n\ndef plot_iso(threshold=np.log10(np.percentile(r, 75.))):\n    plotter.clear()\n    iso = grid.contour(isosurfaces=[10**threshold/2,10**threshold,10**threshold*2], scalars='rho')\n    \n    # Compute per-vertex normals\n    iso = iso.compute_normals(cell_normals=False, split_vertices=True, auto_orient_normals=True)\n    \n    # Add the isosurface mesh\n    plotter.add_mesh(\n        iso, opacity=0.3,\n        smooth_shading=False, \n        show_edges=False, cmap=\"plasma\")\n\n    \n    # Eye-dome lighting can help\n#    plotter.enable_eye_dome_lighting()\n\n    # Update the scene in the same cell\n    plotter.show(interactive_update=True)\n\nwidgets.interact(plot_iso, threshold=((np.log10(np.percentile(r, 0.1)), np.log10(np.percentile(r, 99.9)), \n                                    (np.log10(np.percentile(r, 99.9))-np.log10(np.percentile(r, 0.1)))/100)));\n```"
  },
  {
    "objectID": "website/index.html",
    "href": "website/index.html",
    "title": "Physics 360: Modern Astrophysics",
    "section": "",
    "text": "Instructor: Dr. Tom Abel Email: tabel@stanford.edu\nMeets: Tu Th 1:30-2:50pm in 60-109\nThis website hosts all materials for Physics 360: Modern Astrophysics, including lectures, assignments, final projects, and resources."
  },
  {
    "objectID": "website/index.html#bring-laptop-to-class",
    "href": "website/index.html#bring-laptop-to-class",
    "title": "Physics 360: Modern Astrophysics",
    "section": "Bring laptop to class",
    "text": "Bring laptop to class\nDuring most lectures we will do some coding and/or run some example code I provide. Please bring your laptop. We recommend to create a class specific virtual environment for your local python installation."
  },
  {
    "objectID": "final_project/project_ideas.html",
    "href": "final_project/project_ideas.html",
    "title": "Possible Final project topics",
    "section": "",
    "text": "You are very much encouraged to develop your own final project idea and project plan and deliverable. It has to fit inside this arguably very broad topic of “Modern Astrophysics” and should be not exactly what you are already doing for research. However, it is ok if it is adjacent to your research and the final project gives you a chance to explore something you wouldn’t have done without thinking about the tools, physics and methodology we are discussing in this course."
  },
  {
    "objectID": "final_project/project_ideas.html#globular-star-clusters-observations-by-hst-and-jwst",
    "href": "final_project/project_ideas.html#globular-star-clusters-observations-by-hst-and-jwst",
    "title": "Possible Final project topics",
    "section": "Globular Star Clusters observations by HST and JWST",
    "text": "Globular Star Clusters observations by HST and JWST\n\n\n\n\n\n\nNote\n\n\n\nThis is a signficant project and breaks up into sub tasks. It likely is a good project for a group of students.\n\n\n\n\n\n\nM13 as seen by HST\n\n\n\nHST observations of Globular Clusters in the Milky Way are stunning. We want to build a forward model which uses a library of stellar spectra which we convolve with the correct broad band filters of the specific observations we want to match. We then want to build a forward model which aims to combine our theoretical stars into an image which once the point spread function of HST is applied matches our input data."
  },
  {
    "objectID": "final_project/project_ideas.html#model-galaxy-imagesspectra-from-3d-simulations",
    "href": "final_project/project_ideas.html#model-galaxy-imagesspectra-from-3d-simulations",
    "title": "Possible Final project topics",
    "section": "Model Galaxy images/spectra from 3D Simulations",
    "text": "Model Galaxy images/spectra from 3D Simulations\nWe have access to many different galaxy formation simulations and want to explore to make virtual observations that we can compare directly with real observations. We want to explore what is required to make very fast predictions."
  },
  {
    "objectID": "final_project/project_ideas.html#model-galaxy-imagesspectra",
    "href": "final_project/project_ideas.html#model-galaxy-imagesspectra",
    "title": "Possible Final project topics",
    "section": "Model Galaxy images/spectra",
    "text": "Model Galaxy images/spectra\n\n\n\n\n\n\nNote\n\n\n\nThis is a signficant project and breaks up into sub tasks. It likely is a good project for a group of students.\n\n\n\n\n\n\nGalaxy in Galaxy Zoo 2\n\n\n\nThe image data of Galaxy Zoo 2 (Willett et al. 2019) is available online. This is supplemented by classifications carried out by a large number of volunteers. Leveraging DSPS from Hearin et al. (2023) we want to match all pixel colors."
  },
  {
    "objectID": "final_project/project_ideas.html#model-the-x-ray-emission-of-an-x-ray-cluster",
    "href": "final_project/project_ideas.html#model-the-x-ray-emission-of-an-x-ray-cluster",
    "title": "Possible Final project topics",
    "section": "Model the X-ray emission of an X-ray cluster",
    "text": "Model the X-ray emission of an X-ray cluster\n\n\n\n\nChandra observation of Coma\n\n\n\nThe X-ray emission comes from hot plasma in the galaxy cluster. In this project we want to think through how well we constrain a 3D density and temperature distribution to closely match a specific observation. How does adding spectral/energy information help in ths constraints?"
  },
  {
    "objectID": "final_project/project_ideas.html#radiation-from-a-3d-hii-region",
    "href": "final_project/project_ideas.html#radiation-from-a-3d-hii-region",
    "title": "Possible Final project topics",
    "section": "Radiation from a 3D HII region",
    "text": "Radiation from a 3D HII region"
  },
  {
    "objectID": "final_project/project_ideas.html#radiation-hydro-dynamics-of-a-3d-hii-region",
    "href": "final_project/project_ideas.html#radiation-hydro-dynamics-of-a-3d-hii-region",
    "title": "Possible Final project topics",
    "section": "Radiation Hydro-Dynamics of a 3D HII region",
    "text": "Radiation Hydro-Dynamics of a 3D HII region"
  },
  {
    "objectID": "final_project/project_ideas.html#model-a-dwarf-galaxygc-disruption-in-gala",
    "href": "final_project/project_ideas.html#model-a-dwarf-galaxygc-disruption-in-gala",
    "title": "Possible Final project topics",
    "section": "Model a dwarf galaxy/GC disruption in gala",
    "text": "Model a dwarf galaxy/GC disruption in gala"
  },
  {
    "objectID": "final_project/project_ideas.html#study-the-spitzer-equipartition-instability-in-globular-clusters",
    "href": "final_project/project_ideas.html#study-the-spitzer-equipartition-instability-in-globular-clusters",
    "title": "Possible Final project topics",
    "section": "Study the Spitzer (equipartition) Instability in Globular Clusters",
    "text": "Study the Spitzer (equipartition) Instability in Globular Clusters\nUse our N-body code, write your own, or use a professional one such like rebound to set up initial conditions that illustrate various aspects of Spitzer’s instability. The instability relates to having heavy stars mass segregate towards the center of a star cluster. Once they are more common they tend to dissipate energy to the lowe mass stars in the out parts via two body scattering. This leads the heavy masses to move to smaller radii moving away from equi-partition rather than towards equilibrium. See chapter 7.5.5 of Binney and Tremaine (2008)."
  },
  {
    "objectID": "final_project/project_ideas.html#particle-mesh-codes-in-cosmology",
    "href": "final_project/project_ideas.html#particle-mesh-codes-in-cosmology",
    "title": "Possible Final project topics",
    "section": "Particle-Mesh Codes in Cosmology",
    "text": "Particle-Mesh Codes in Cosmology\nAndrey Kravtsov wrote a wonderful set of instructions on how to approach writing your own particle mesh code specifically for numerical cosmology. There is now a beautifully implemented python version of cosmological PM by Breton (2024), called pysco, which also includes well developed initial conditions generation. I have many example Jupyter notebooks I can share with you also ones related to the Simplex in Cell technique Hahn and Angulo (2016). There are multiple possible projects building on this work. Our own Delon Shen wrote a beautiful set of notes that are even more pedagogical and interactive.\n\nMake pysco use the phase-space sheet\nE.g. you might incorporate the ideas from Abel, Hahn, and Kaehler (2012), Sousbie and Colombi (2016), and Hahn and Angulo (2016) into pysco.\n\n\nExplore the statistics of 3D cosmological density\nYou might first just use fields as computed through the Lagrangian Perturbation theory implemented in pysco, i.e. the initial conditions. Once you have a pipeline to measure the spatial statistics you are interested in - Kymatio implements 1, 2 and 3D wavelet scattering transforms. Follow Cheng et al. (2023) and characterize the scattering coefficients for evolved cosmological density fields. - Measure the PDFs for the density fields for many different smoothing lengths and compare to the predictions given by pyLDT from Cataneo et al. (2021). - Explore kNN-CDFs from Banerjee and Abel (2021)."
  },
  {
    "objectID": "final_project/project_ideas.html#statistical-properties-of-12-and-3d-turbulence",
    "href": "final_project/project_ideas.html#statistical-properties-of-12-and-3d-turbulence",
    "title": "Possible Final project topics",
    "section": "Statistical properties of 1,2 and 3D turbulence",
    "text": "Statistical properties of 1,2 and 3D turbulence\nThe novelty in this project is that we will try to do very high dynamic range estimates of the statistical properties of turbulence by running a set of simulations which we connect in a one way approach. We will start with a 1D model which will help us practice everything we need. If we manage that we can extend it to 2 and 3D. Beattie et al. (2022) study the density PDF in supersonic MHD turbulence. We start by reading this paper to get a sense of the current questions in the field. We will assume as hypothesis that energy cascades only from large scales to samll scales. Hence when we simulate First step then is to use 1D hydro and look at decaying supersonic turbulence."
  },
  {
    "objectID": "final_project/project_ideas.html#numerical-cosmology",
    "href": "final_project/project_ideas.html#numerical-cosmology",
    "title": "Possible Final project topics",
    "section": "Numerical Cosmology",
    "text": "Numerical Cosmology"
  },
  {
    "objectID": "final_project/project_ideas.html#study-lyman-alpha-radiation-transport",
    "href": "final_project/project_ideas.html#study-lyman-alpha-radiation-transport",
    "title": "Possible Final project topics",
    "section": "Study Lyman-\\(\\alpha\\) Radiation Transport",
    "text": "Study Lyman-\\(\\alpha\\) Radiation Transport\nImplement the grid-less monte carlo transfer approach of Smith et al. (2025), reproduce some of their plots and discuss the approach. Stretch goal: Make a differentiable version. Feeding it one of its own solutions can you write a pipeline which recovers all input parameters and (further stretch) error bars on them?"
  },
  {
    "objectID": "final_project/project_ideas.html#very-fast-chemical-reaction-network-solvers-using-neural-nets",
    "href": "final_project/project_ideas.html#very-fast-chemical-reaction-network-solvers-using-neural-nets",
    "title": "Possible Final project topics",
    "section": "Very fast chemical reaction network solvers using neural nets",
    "text": "Very fast chemical reaction network solvers using neural nets"
  },
  {
    "objectID": "final_project/project_ideas.html#fast-non-equilibrium-cooling-functions-high-dimensional-interpolation",
    "href": "final_project/project_ideas.html#fast-non-equilibrium-cooling-functions-high-dimensional-interpolation",
    "title": "Possible Final project topics",
    "section": "Fast non-equilibrium cooling functions: high dimensional interpolation",
    "text": "Fast non-equilibrium cooling functions: high dimensional interpolation"
  },
  {
    "objectID": "final_project/project_ideas.html#differentiable-emission-line-modeling-for-galaxies",
    "href": "final_project/project_ideas.html#differentiable-emission-line-modeling-for-galaxies",
    "title": "Possible Final project topics",
    "section": "Differentiable emission line modeling for galaxies",
    "text": "Differentiable emission line modeling for galaxies"
  },
  {
    "objectID": "final_project/project_ideas.html#differentiable-dust-emission-and-absorption",
    "href": "final_project/project_ideas.html#differentiable-dust-emission-and-absorption",
    "title": "Possible Final project topics",
    "section": "Differentiable Dust emission and absorption",
    "text": "Differentiable Dust emission and absorption"
  },
  {
    "objectID": "assignments/assignment_1.html",
    "href": "assignments/assignment_1.html",
    "title": "Assignment 1",
    "section": "",
    "text": "One key aspect of all our work is that we communicate with a wide range of audiences our research methodology, our approach and our findings. These reports come in a wide range of formats as well. From talk slides, to research blogs, to popular science writing, to github repositories, to code pull requests, to research articles and even a PhD thesis. Very often this means that we have similar content but variations of our work. The same figures I made for my research paper are usually not adequate for a talk slide. We need larger fonts, more legible axes labels, titles, backgrounds, etc. The publications style, citations style, and style guidance all change depending on which journal we are writing for.\nSimilarly for our daily work flow, time management and project progress tracking we employ productivity hacks. We strive to get to know ourselves better and experiment with what works and what doesn’t. There are many ways to personalize how we approach tracking and keeping progress towards our goals.\nLast but not least we work a lot with code and data. Whether we are experimental, observational, theoretical, computational, historical, philosophical physicists, or any combination of those labels, chances are we are wrangling quite a bit of data, CAD files, survey data, telescope archives, simulation suites, to thesis mile-stones.\nIn this first assignment we are asking to describe a workflow that is helpful to these goals. I.e. how to best organize everything needed to write a successful thesis and the many other things related to it. The talk for the thesis defense, the qual exam, the assembly of the thesis. Make the assignment follow more the “do as I say, rather than do what I do” mantra. I.e. talk more about how you think it might best be done and how you might try to change your own workflow rather than describing parts that do not work to well. Let us know about any tools that are helping you and any tips you may have for using them. Nothing is too small a tip. Which keyboard shortcuts are your most useful ones?, what directory structure keeps things organized, what cloud-service / external hard-drives powers your backup strategy?, What web bookmarks are essential for a Physics PhD at Stanford? Which for research at KIPAC/SLAC?.\nHand in you personal take on this next week. This version can happily offer strong opinions. However, also already think about organizing yourself so you can turn all this eventually into a large shared document that can be helpful to all of us as a resource. For the larger resource we may tone down our strongest opinions. I would suggest a structure that separates the writing on publishing/authoring from time management, project tracking as well as from data wrangling and coding while at the same explicitly highlights the threads that connect these areas in as much as it makes sense in your approach.\nHand in your write up through Canvas."
  },
  {
    "objectID": "assignments/assignment_1.html#describe-your-workflow",
    "href": "assignments/assignment_1.html#describe-your-workflow",
    "title": "Assignment 1",
    "section": "",
    "text": "One key aspect of all our work is that we communicate with a wide range of audiences our research methodology, our approach and our findings. These reports come in a wide range of formats as well. From talk slides, to research blogs, to popular science writing, to github repositories, to code pull requests, to research articles and even a PhD thesis. Very often this means that we have similar content but variations of our work. The same figures I made for my research paper are usually not adequate for a talk slide. We need larger fonts, more legible axes labels, titles, backgrounds, etc. The publications style, citations style, and style guidance all change depending on which journal we are writing for.\nSimilarly for our daily work flow, time management and project progress tracking we employ productivity hacks. We strive to get to know ourselves better and experiment with what works and what doesn’t. There are many ways to personalize how we approach tracking and keeping progress towards our goals.\nLast but not least we work a lot with code and data. Whether we are experimental, observational, theoretical, computational, historical, philosophical physicists, or any combination of those labels, chances are we are wrangling quite a bit of data, CAD files, survey data, telescope archives, simulation suites, to thesis mile-stones.\nIn this first assignment we are asking to describe a workflow that is helpful to these goals. I.e. how to best organize everything needed to write a successful thesis and the many other things related to it. The talk for the thesis defense, the qual exam, the assembly of the thesis. Make the assignment follow more the “do as I say, rather than do what I do” mantra. I.e. talk more about how you think it might best be done and how you might try to change your own workflow rather than describing parts that do not work to well. Let us know about any tools that are helping you and any tips you may have for using them. Nothing is too small a tip. Which keyboard shortcuts are your most useful ones?, what directory structure keeps things organized, what cloud-service / external hard-drives powers your backup strategy?, What web bookmarks are essential for a Physics PhD at Stanford? Which for research at KIPAC/SLAC?.\nHand in you personal take on this next week. This version can happily offer strong opinions. However, also already think about organizing yourself so you can turn all this eventually into a large shared document that can be helpful to all of us as a resource. For the larger resource we may tone down our strongest opinions. I would suggest a structure that separates the writing on publishing/authoring from time management, project tracking as well as from data wrangling and coding while at the same explicitly highlights the threads that connect these areas in as much as it makes sense in your approach.\nHand in your write up through Canvas."
  },
  {
    "objectID": "assignments/assignment_1.html#install-gala-and-plotly-libraries-in-your-own-python-setup",
    "href": "assignments/assignment_1.html#install-gala-and-plotly-libraries-in-your-own-python-setup",
    "title": "Assignment 1",
    "section": "Install gala and plotly libraries in your own python setup",
    "text": "Install gala and plotly libraries in your own python setup\nWe will carry out a few galactic dynamics calculations using gala and visualize some of it with plotly. Make sure to install these before next class time on Thursday. Our setup python tutorial maybe helpful to you to get started."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html",
    "href": "tutorials/integrate-1D-poissonEquation.html",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "In physics we often write \\(\\nabla^2\\) instead of \\(\\Delta\\) but we mean the same thing, suming the second derivatives along each value.\nHere we explore a solution strategy for the one dimensional Poisson equation. This is purely an example and most of the solution strategies will work for almost all second order partial differential equations. Let us first make the equation dimension-less. We can use the mean density \\(\\bar{\\rho}=\\int\\rho dV/\\int dV\\) to define the overdensity \\[D\\equiv \\frac{\\rho}{\\bar{\\rho}}\\] and rescale the potential\n\\[\n\\tilde{\\Phi}\\equiv (C \\bar{\\rho} L^2)^{-1}\\Phi\n\\]\nwhich we can insert into the original equation \\(\\Delta \\tilde{\\Phi} C \\bar{\\rho} L^2 = C \\rho\\) and get a new equation for \\(\\tilde{\\Phi}\\):\n\\[\nL^{2}\\Delta \\tilde{\\Phi} =  D.\n\\]\n\\(L\\) is just a constant length. It could be just a typical length scale of the problem. This is now convenient as the over density is a nice dimensionless intuitively easy to grasp description of the density. Also all the length intervals we have in the problem as just measured in units of \\(L\\) and once we have a solution we can use these relations to back out the SI/cgs values of the potential.\nSo let us also measure all distances in units of \\(L\\) so we define \\[\\tilde{x}\\equiv x/L\\] and have \\(d\\tilde{x}/dx = 1/L\\)\nThe Force is just \\(-\\nabla \\tilde{\\Phi}\\), so in one dimension\n\\[\n-\\frac{\\partial F}{\\partial \\tilde{x}} = D\n\\]\nwe now simply have\n\\[\nF(X) = -\\int_0^X D(\\tilde{x}) d\\tilde{x} + F(x=0),\n\\]\nwith the integration constant being recognized as \\(F(x=0)\\) which must be obtained from a boundary condition. Its meaning is clear it is the Force at \\(x=0\\). Also the integral over the density on the right hand side has a simple meaning. It is the mass (charge) in the interval \\([0..X]\\). We also can see this from Gauss’ law that\n\\[\nF(1)-F(0)= -\\int_0^1 D(\\tilde{x}) d\\tilde{x}\n\\]\nso that in a periodic domain where we have \\(F(0)=F(1)\\) it follows that \\(C_1 = F(0)\\). The problem is though that a priori we do not know \\(F(0)\\). However, in the case where no external forces are applied the system must conserve momentum. I.e. the total momentum change must remain zero\n\\[\n\\int_0^1 \\frac{dp}{dt} d\\tilde{x} = \\int_0^1 F(\\tilde{x}) d\\tilde{x} = 0\n\\]\nSo we have\n\\[\n-\\int_0^X \\int_0^X D(\\tilde{x})d\\tilde{x} + X F(x=0) = 0\n\\]\nso\n\\[\nF(0) = -\\int_0^1 \\int_0^1 D(\\tilde{x})d\\tilde{x}  \n\\]\nIntegrating this once more and we get the Potential\n\\[\n- \\tilde{\\Phi}(X) = \\int_0^X F(\\tilde{x}) d\\tilde{x}  + C_2\n\\]\n\n\nF(x=0) =  -0.07082481931956612\n\n\n\n\n\n\n\n\n\n\n\n- Calculate the potential and force in and around a homogeneous sphere reusing the numerical integration and differentiation as in the example above. \n- Have the sphere be at position x=0.4 and have a radius 0.025\n- What did you notice about our assumption of periodic boundaries? How does the mean density enter?\n- Plot it for the grid resolution 60 and 240\n- Discuss the solution\n\n\nF(x=0) =  0.6019793898581776\n\n\n\n\n\n\n\n\n\n\n\n\nThe trick we just used above is only possible in one dimensions. In two or more the Poisson equation is essentially always a boundary value problem. I.e. we need to specify the values of \\(\\Phi\\) on the boundary and the interate to find a convergent solution. We introduce this style of solving it here next but stay in one dimensions to keep things simple at first. So we start out by discretizing the Poisson equation using the central difference for the second derivative.\n\\[\n\\frac{1}{h^2} \\left( \\Phi_{i+1} + \\Phi_{i-1} - 2\\Phi_i \\right) = C\\ D(x_i)\n\\]\nwhere we took the liberty and drop the ~ symbols for \\(\\tilde{\\Phi}\\) and \\(d\\tilde{x}\\) while still working in these dimensionless quantities.\nThis gives us an obvious solution strategy. We just solve for \\(\\Phi_i\\) and remember to specify boundary values on the left and right so that the resulting formula is always defined. I.e.\n\\[\n\\Phi_i = \\frac{1}{2}\\left( \\Phi_{i+1} + \\Phi_{i-1} - C\\ D(x_i)\\ h^2 \\right)\n\\]\nFor our first implementation we will assume periodic boundaries.\nThe overdensity \\(D(x)\\) will be defined at cell centers and similarly \\(\\Phi\\) is recorded at the same positions.\n\n\n\n\n\n\n\n\n\nWow. That takes an enormous amount of iterations to converge. In particular if the solution has long wavelength components. This method is known an Jacobi’s iterative method.\nAh yes. But we could use the update values as we march through. Perhaps that converges faster?\n\n\n\n\n\n\n\n\n\nThat is indeed somewhat of an improvement. It is called the Gauss Seidel iteration.\n\n\n\nIf we wouldn’ change the values completely just on the neighbors but keep some information from previous steps we can weight the update. This is known as successive over-relaxation. \\[\n\\Phi_i^{n+1} = (1-\\omega)\\ \\Phi_i^n + \\omega/2\\ \\left( \\Phi^n_{i+1} + \\Phi^n_{i-1} - c h^2 D \\right),\n\\] first for \\(i=0,2,4,\\cdots\\) and then for \\(i=1,3,5,\\cdots\\). It is the same number of operations as before but does converge somewhat quicker.\n\n\n\n\n\n\n\n\n\nOk. This is better! It, however, added another parameter which is left to the user to choose. It is only convergent in $ 0 &lt; w &lt; 2 $.\n\n\n\nThere is a variant of Gauss Seidel and succesive over-relaxation that is known as red-black ordering. This realizes that even positions are only dependent on odd neighbors and odd ones only on even. So first updates the one half and then the other. We do our SOR update \\[\n\\Phi_i^{n+1} = (1-\\omega)\\ \\Phi_i^N + \\omega/2\\ \\left( \\Phi^n_{i+1} + \\Phi^n_{i-1} - c h^2 D \\right),\n\\] first for \\(i=0,2,4,\\cdots\\) and then for \\(i=1,3,5,\\cdots\\). It is the same number of operations as before but does converge somewhat quicker.\n\n\n\n\n\n\n\n\n\nThis is indeed a further improvement.\n\n\n\nOur discretization we used in the relaxation method can also be written in matrix form:\n\\[ A\\ \\Phi = h^2 C\\ D =\n\\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 & 0 & 1 \\\\\\\\\n1 & -2 & 1 & 0 & \\cdots & 0 & 0 \\\\\\\\\n0 & 1 & -2 & 1 & 0 & \\cdots & 0 \\\\\\\\\n\\vdots  & \\vdots  & \\ddots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\\\\\n0 & 0 & ... & 0 & 1 & -2 & 1 \\\\\\\\\n1 & 0 & 0 & ... & 0 & 1 & -2\n\\end{pmatrix}\n\\\n\\begin{pmatrix}\n\\Phi_1 \\\\\\\\\n\\Phi_2 \\\\\\\\\n\\Phi_3 \\\\\\\\\n\\vdots \\\\\\\\\n\\Phi_{n-1} \\\\\\\\\n\\Phi_n\n\\end{pmatrix}\n= h^2 C\\\n\\begin{pmatrix}\nD_1 \\\\\\\\\nD_2 \\\\\\\\\nD_3 \\\\\\\\\n\\vdots \\\\\\\\\nD_{n-1} \\\\\\\\\nD_n\n\\end{pmatrix}\n\\]\nSo in the relaxation technique we iterated until we got \\(\\Phi\\) to agree with this formula.\nSo let us define this Matrix:\n\n\n[[-2.  1.  0. ...  0.  0.  1.]\n [ 1. -2.  1. ...  0.  0.  0.]\n [ 0.  1. -2. ...  0.  0.  0.]\n ...\n [ 0.  0.  0. ... -2.  1.  0.]\n [ 0.  0.  0. ...  1. -2.  1.]\n [ 1.  0.  0. ...  0.  1. -2.]]\nDeterminant of A is: 1.1147087742196166e-13\n\n\nand now invert it\n\n\narray([[ 1.   , -0.125, -0.125, ...,  0.   ,  0.   ,  0.   ],\n       [ 0.   ,  1.   , -0.25 , ...,  0.   ,  0.   ,  0.   ],\n       [-0.125, -0.125,  0.875, ...,  0.   ,  0.   ,  0.   ],\n       ...,\n       [-0.125,  0.   , -0.125, ...,  1.125,  0.   ,  0.   ],\n       [ 0.   , -0.125, -0.125, ...,  0.125,  1.   ,  0.   ],\n       [ 0.   , -0.125, -0.125, ...,  0.   ,  0.   ,  1.   ]],\n      shape=(100, 100))\n\n\nThis did not work … It failed to correctly invert the matrix. I.e. we do not get identity matrix back when we multiply the original matrix and its supposed inverse. In hindsight we may have guessed that since the potential is not fixed up to a constant. So consequently the matrix has a determinant of zero and no unique solution is obtained.\nHowever, we can add one row in which we set a constant \\(\\Phi\\) value. I.e.\n\\[ A\\ \\Phi = h^2 C\\ D =\n\\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 & 0 & 1& 0  \\\\\\\\\n1 & -2 & 1 & 0 & \\cdots & 0 & 0& 0 \\\\\\\\\n0 & 1 & -2 & 1 & 0 & \\cdots & 0& 0 \\\\\\\\\n\\vdots  & \\vdots  & \\ddots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\\\\\n0 & 0 & ... & 0 & 1 & -2 & 1& 0 \\\\\\\\\n1 & 0 & 0 & ... & 0 & 1 & -2& 0 \\\\\\\\\n1 & 1 & 1 & ... & 1 & 1 & 1 & 0\n\\end{pmatrix}\n\\\n\\begin{pmatrix}\n\\Phi_1 \\\\\\\\\n\\Phi_2 \\\\\\\\\n\\Phi_3 \\\\\\\\\n\\vdots \\\\\\\\\n\\Phi_{n-1} \\\\\\\\\n\\Phi_n \\\\\\\\\n\\Phi_{n+1}\n\\end{pmatrix}\n= h^2 C\\\n\\begin{pmatrix}\nD_1 \\\\\\\\\nD_2 \\\\\\\\\nD_3 \\\\\\\\\n\\vdots \\\\\\\\\nD_{n-1} \\\\\\\\\nD_n \\\\\\\\\n0\n\\end{pmatrix}\n\\]\nOnce we have the solution to \\(\\Phi\\) we throw away \\(\\Phi_{n+1}\\) and subtract the mean of the potential \\(\\int_0^1 \\Phi dx\\) just by convention.\n\n\n[[ 5.55111512e-17  4.94444444e-01  9.77777778e-01 ...  9.77777778e-01\n   4.94444444e-01  1.11111111e-02]\n [-5.55111512e-17 -4.94444444e-01 -1.66183640e-15 ...  9.55555556e-01\n   4.83333333e-01  1.11111111e-02]\n [-1.66533454e-16 -4.83333333e-01 -9.77777778e-01 ...  9.33333333e-01\n   4.72222222e-01  1.11111111e-02]\n ...\n [ 0.00000000e+00  4.72222222e-01  9.33333333e-01 ... -9.77777778e-01\n  -4.83333333e-01  1.11111111e-02]\n [ 1.66533454e-16  4.83333333e-01  9.55555556e-01 ...  1.47945607e-15\n  -4.94444444e-01  1.11111111e-02]\n [ 1.00000000e+00  1.48333333e+00  1.95555556e+00 ...  1.00000000e+00\n   5.05555556e-01  1.11111111e-02]]\nDeterminant of the input matrix is : 8100.000000000035\n\n\n\n\n\n\n\n\n\n\n\nDeterminant of A is: 8100.000000000035\n\n\n\n\n\n\n\n\n\n\n\nSo clearly all the matrix values are filled. This is now very similar to the \\(N^2\\) operations we saw in the gravitational N-body problem. Every cell contibutes to the potential of every other cell and our matrix inversion gives the formula of how to do that.\n\n\n\nLet us for a second though think of what would happen if we had the density and the potential given by their Fourier transforms. \\[\n\\Phi(x) =  \\int \\phi(k)\\ e^{2\\pi\\ ikx} dk, \\ \\ D(x) =  \\int \\delta(k)\\ e^{2\\pi\\ ikx} dk\n\\] If we enter this in our starting equation \\(\\Delta \\Phi=c\\ D\\) we find that \\[\n-4\\pi\\ k^2\\phi(k) = c\\ \\delta(k), \\ \\ \\rightarrow \\ \\ \\phi(k) = -\\frac{c}{4\\pi}\\ \\delta(k)/k^2.\n\\] Oh fantastic. This means that if we Fourier transform the density, then multiply it with \\(-c/k^2\\) in Fourier space we already get the Fourier transformed potential. If we then just do the inverse Fourier transform back to real space we should have the correct potential we were looking for!\nThis may sound at first like a fairly complicated roundabaout way of getting at our problem. However, discrete Fourier transforms are only of complexity \\(log\\ N \\ \\ N\\) and some of the best optimized routines available on computers. So this can be an extraordinarily useful way of solving the Poisson equation in any dimension.\nThis is so elegant we just have to try it. Fortunately python makes this easy for us since it comes with Fourier transforms and helper functions included.\nThe conventions in numpy for the discrete Fourier transform are \\[\nA_k = \\sum_{m=0}^{N-1}\\ a_m\\ e^{-2\\pi\\ i\\ m\\ k/N}, \\ \\ k=0,1,...,n-2,n-1\n\\] and the inverse transform is given by \\[\na_m = \\frac{1}{N}\\sum_{m=0}^{n-1}\\ A_m\\ e^{2\\pi\\ i\\ m\\ k/N}\n\\] See the FFT documentation for more details."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#using-relaxation",
    "href": "tutorials/integrate-1D-poissonEquation.html#using-relaxation",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "The trick we just used above is only possible in one dimensions. In two or more the Poisson equation is essentially always a boundary value problem. I.e. we need to specify the values of \\(\\Phi\\) on the boundary and the interate to find a convergent solution. We introduce this style of solving it here next but stay in one dimensions to keep things simple at first. So we start out by discretizing the Poisson equation using the central difference for the second derivative.\n\\[\n\\frac{1}{h^2} \\left( \\Phi_{i+1} + \\Phi_{i-1} - 2\\Phi_i \\right) = C\\ D(x_i)\n\\]\nwhere we took the liberty and drop the ~ symbols for \\(\\tilde{\\Phi}\\) and \\(d\\tilde{x}\\) while still working in these dimensionless quantities.\nThis gives us an obvious solution strategy. We just solve for \\(\\Phi_i\\) and remember to specify boundary values on the left and right so that the resulting formula is always defined. I.e.\n\\[\n\\Phi_i = \\frac{1}{2}\\left( \\Phi_{i+1} + \\Phi_{i-1} - C\\ D(x_i)\\ h^2 \\right)\n\\]\nFor our first implementation we will assume periodic boundaries.\nThe overdensity \\(D(x)\\) will be defined at cell centers and similarly \\(\\Phi\\) is recorded at the same positions.\n\n\n\n\n\n\n\n\n\nWow. That takes an enormous amount of iterations to converge. In particular if the solution has long wavelength components. This method is known an Jacobi’s iterative method.\nAh yes. But we could use the update values as we march through. Perhaps that converges faster?\n\n\n\n\n\n\n\n\n\nThat is indeed somewhat of an improvement. It is called the Gauss Seidel iteration."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#using-successive-over-relaxation",
    "href": "tutorials/integrate-1D-poissonEquation.html#using-successive-over-relaxation",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "If we wouldn’ change the values completely just on the neighbors but keep some information from previous steps we can weight the update. This is known as successive over-relaxation. \\[\n\\Phi_i^{n+1} = (1-\\omega)\\ \\Phi_i^n + \\omega/2\\ \\left( \\Phi^n_{i+1} + \\Phi^n_{i-1} - c h^2 D \\right),\n\\] first for \\(i=0,2,4,\\cdots\\) and then for \\(i=1,3,5,\\cdots\\). It is the same number of operations as before but does converge somewhat quicker.\n\n\n\n\n\n\n\n\n\nOk. This is better! It, however, added another parameter which is left to the user to choose. It is only convergent in $ 0 &lt; w &lt; 2 $."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#succesive-over-relaxation-with-red-black-ordering",
    "href": "tutorials/integrate-1D-poissonEquation.html#succesive-over-relaxation-with-red-black-ordering",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "There is a variant of Gauss Seidel and succesive over-relaxation that is known as red-black ordering. This realizes that even positions are only dependent on odd neighbors and odd ones only on even. So first updates the one half and then the other. We do our SOR update \\[\n\\Phi_i^{n+1} = (1-\\omega)\\ \\Phi_i^N + \\omega/2\\ \\left( \\Phi^n_{i+1} + \\Phi^n_{i-1} - c h^2 D \\right),\n\\] first for \\(i=0,2,4,\\cdots\\) and then for \\(i=1,3,5,\\cdots\\). It is the same number of operations as before but does converge somewhat quicker.\n\n\n\n\n\n\n\n\n\nThis is indeed a further improvement."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#recognizing-this-is-a-linear-algebra-problem",
    "href": "tutorials/integrate-1D-poissonEquation.html#recognizing-this-is-a-linear-algebra-problem",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "Our discretization we used in the relaxation method can also be written in matrix form:\n\\[ A\\ \\Phi = h^2 C\\ D =\n\\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 & 0 & 1 \\\\\\\\\n1 & -2 & 1 & 0 & \\cdots & 0 & 0 \\\\\\\\\n0 & 1 & -2 & 1 & 0 & \\cdots & 0 \\\\\\\\\n\\vdots  & \\vdots  & \\ddots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\\\\\n0 & 0 & ... & 0 & 1 & -2 & 1 \\\\\\\\\n1 & 0 & 0 & ... & 0 & 1 & -2\n\\end{pmatrix}\n\\\n\\begin{pmatrix}\n\\Phi_1 \\\\\\\\\n\\Phi_2 \\\\\\\\\n\\Phi_3 \\\\\\\\\n\\vdots \\\\\\\\\n\\Phi_{n-1} \\\\\\\\\n\\Phi_n\n\\end{pmatrix}\n= h^2 C\\\n\\begin{pmatrix}\nD_1 \\\\\\\\\nD_2 \\\\\\\\\nD_3 \\\\\\\\\n\\vdots \\\\\\\\\nD_{n-1} \\\\\\\\\nD_n\n\\end{pmatrix}\n\\]\nSo in the relaxation technique we iterated until we got \\(\\Phi\\) to agree with this formula.\nSo let us define this Matrix:\n\n\n[[-2.  1.  0. ...  0.  0.  1.]\n [ 1. -2.  1. ...  0.  0.  0.]\n [ 0.  1. -2. ...  0.  0.  0.]\n ...\n [ 0.  0.  0. ... -2.  1.  0.]\n [ 0.  0.  0. ...  1. -2.  1.]\n [ 1.  0.  0. ...  0.  1. -2.]]\nDeterminant of A is: 1.1147087742196166e-13\n\n\nand now invert it\n\n\narray([[ 1.   , -0.125, -0.125, ...,  0.   ,  0.   ,  0.   ],\n       [ 0.   ,  1.   , -0.25 , ...,  0.   ,  0.   ,  0.   ],\n       [-0.125, -0.125,  0.875, ...,  0.   ,  0.   ,  0.   ],\n       ...,\n       [-0.125,  0.   , -0.125, ...,  1.125,  0.   ,  0.   ],\n       [ 0.   , -0.125, -0.125, ...,  0.125,  1.   ,  0.   ],\n       [ 0.   , -0.125, -0.125, ...,  0.   ,  0.   ,  1.   ]],\n      shape=(100, 100))\n\n\nThis did not work … It failed to correctly invert the matrix. I.e. we do not get identity matrix back when we multiply the original matrix and its supposed inverse. In hindsight we may have guessed that since the potential is not fixed up to a constant. So consequently the matrix has a determinant of zero and no unique solution is obtained.\nHowever, we can add one row in which we set a constant \\(\\Phi\\) value. I.e.\n\\[ A\\ \\Phi = h^2 C\\ D =\n\\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 & 0 & 1& 0  \\\\\\\\\n1 & -2 & 1 & 0 & \\cdots & 0 & 0& 0 \\\\\\\\\n0 & 1 & -2 & 1 & 0 & \\cdots & 0& 0 \\\\\\\\\n\\vdots  & \\vdots  & \\ddots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\\\\\n0 & 0 & ... & 0 & 1 & -2 & 1& 0 \\\\\\\\\n1 & 0 & 0 & ... & 0 & 1 & -2& 0 \\\\\\\\\n1 & 1 & 1 & ... & 1 & 1 & 1 & 0\n\\end{pmatrix}\n\\\n\\begin{pmatrix}\n\\Phi_1 \\\\\\\\\n\\Phi_2 \\\\\\\\\n\\Phi_3 \\\\\\\\\n\\vdots \\\\\\\\\n\\Phi_{n-1} \\\\\\\\\n\\Phi_n \\\\\\\\\n\\Phi_{n+1}\n\\end{pmatrix}\n= h^2 C\\\n\\begin{pmatrix}\nD_1 \\\\\\\\\nD_2 \\\\\\\\\nD_3 \\\\\\\\\n\\vdots \\\\\\\\\nD_{n-1} \\\\\\\\\nD_n \\\\\\\\\n0\n\\end{pmatrix}\n\\]\nOnce we have the solution to \\(\\Phi\\) we throw away \\(\\Phi_{n+1}\\) and subtract the mean of the potential \\(\\int_0^1 \\Phi dx\\) just by convention.\n\n\n[[ 5.55111512e-17  4.94444444e-01  9.77777778e-01 ...  9.77777778e-01\n   4.94444444e-01  1.11111111e-02]\n [-5.55111512e-17 -4.94444444e-01 -1.66183640e-15 ...  9.55555556e-01\n   4.83333333e-01  1.11111111e-02]\n [-1.66533454e-16 -4.83333333e-01 -9.77777778e-01 ...  9.33333333e-01\n   4.72222222e-01  1.11111111e-02]\n ...\n [ 0.00000000e+00  4.72222222e-01  9.33333333e-01 ... -9.77777778e-01\n  -4.83333333e-01  1.11111111e-02]\n [ 1.66533454e-16  4.83333333e-01  9.55555556e-01 ...  1.47945607e-15\n  -4.94444444e-01  1.11111111e-02]\n [ 1.00000000e+00  1.48333333e+00  1.95555556e+00 ...  1.00000000e+00\n   5.05555556e-01  1.11111111e-02]]\nDeterminant of the input matrix is : 8100.000000000035\n\n\n\n\n\n\n\n\n\n\n\nDeterminant of A is: 8100.000000000035\n\n\n\n\n\n\n\n\n\n\n\nSo clearly all the matrix values are filled. This is now very similar to the \\(N^2\\) operations we saw in the gravitational N-body problem. Every cell contibutes to the potential of every other cell and our matrix inversion gives the formula of how to do that."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#using-fast-fourier-transforms",
    "href": "tutorials/integrate-1D-poissonEquation.html#using-fast-fourier-transforms",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "Let us for a second though think of what would happen if we had the density and the potential given by their Fourier transforms. \\[\n\\Phi(x) =  \\int \\phi(k)\\ e^{2\\pi\\ ikx} dk, \\ \\ D(x) =  \\int \\delta(k)\\ e^{2\\pi\\ ikx} dk\n\\] If we enter this in our starting equation \\(\\Delta \\Phi=c\\ D\\) we find that \\[\n-4\\pi\\ k^2\\phi(k) = c\\ \\delta(k), \\ \\ \\rightarrow \\ \\ \\phi(k) = -\\frac{c}{4\\pi}\\ \\delta(k)/k^2.\n\\] Oh fantastic. This means that if we Fourier transform the density, then multiply it with \\(-c/k^2\\) in Fourier space we already get the Fourier transformed potential. If we then just do the inverse Fourier transform back to real space we should have the correct potential we were looking for!\nThis may sound at first like a fairly complicated roundabaout way of getting at our problem. However, discrete Fourier transforms are only of complexity \\(log\\ N \\ \\ N\\) and some of the best optimized routines available on computers. So this can be an extraordinarily useful way of solving the Poisson equation in any dimension.\nThis is so elegant we just have to try it. Fortunately python makes this easy for us since it comes with Fourier transforms and helper functions included.\nThe conventions in numpy for the discrete Fourier transform are \\[\nA_k = \\sum_{m=0}^{N-1}\\ a_m\\ e^{-2\\pi\\ i\\ m\\ k/N}, \\ \\ k=0,1,...,n-2,n-1\n\\] and the inverse transform is given by \\[\na_m = \\frac{1}{N}\\sum_{m=0}^{n-1}\\ A_m\\ e^{2\\pi\\ i\\ m\\ k/N}\n\\] See the FFT documentation for more details."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#the-laplace-operator-in-spherical-coordinates",
    "href": "tutorials/integrate-1D-poissonEquation.html#the-laplace-operator-in-spherical-coordinates",
    "title": "Solving the Poisson Equation tutorial",
    "section": "The Laplace operator in spherical coordinates",
    "text": "The Laplace operator in spherical coordinates\nThe Laplace operator in spherical coordinates is: \\[\n\\begin{align}\n\\nabla^2 f &=& {1 \\over r^2}{\\partial \\over \\partial r}\\!\\left(r^2 {\\partial f \\over \\partial r}\\right)\n  \\!+\\!{1 \\over r^2\\!\\sin\\theta}{\\partial \\over \\partial \\theta}\\!\\left(\\sin\\theta {\\partial f \\over \\partial \\theta}\\right)\n  \\!+\\!{1 \\over r^2\\!\\sin^2\\theta}{\\partial^2 f \\over \\partial \\varphi^2}\n= \\\\\n& = &\\left(\\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r} \\frac{\\partial}{\\partial r}\\right)f \\!+\n{1 \\over r^2\\!\\sin\\theta}{\\partial \\over \\partial \\theta}\\!\\left(\\sin\\theta \\frac{\\partial}{\\partial \\theta}\\right)f +\\frac{1}{r^2\\!\\sin^2\\theta}\\frac{\\partial^2}{\\partial \\varphi^2}f.\n\\end{align}\n\\]\nHere we care only for the radial part: \\[\n\\nabla^2_r f =  {1 \\over r^2}{\\partial \\over \\partial r}\\!\\left(r^2 {\\partial f \\over \\partial r}\\right) = \\left(\\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r} \\frac{\\partial}{\\partial r}\\right)f\n\\] and also make note of the gradient in radial direction: \\[\n\\nabla_r\\ f = {\\partial f \\over \\partial r}\n\\]"
  },
  {
    "objectID": "tutorials/plasma_pic_1D.html",
    "href": "tutorials/plasma_pic_1D.html",
    "title": "Example of 1D particle in cell code for plasma dynamics",
    "section": "",
    "text": "We set up some test problems involving ions and “electrons”.\nimport numpy as np\n\nclass PICSimulation:\n    \"\"\"\n    A simple class-based 1D PIC simulation.\n    Advances current particle positions, velocities, time, etc.,\n    The run() method returns a list of snapshots for later visualization\n    \"\"\"\n\n    def __init__(self, xp, vp, xe, ve, Ngrid, dt,\n                 massIon, massE, chargeIon, chargeE):\n        \"\"\"\n        Initialize the simulation with initial arrays and parameters.\n\n        xp, vp: arrays of proton positions & velocities\n        xe, ve: arrays of electron positions & velocities\n        Ngrid:  number of grid cells\n        dt:     time step\n        massIon, massE, chargeIon, chargeE: physical parameters\n        \"\"\"\n        # Particle arrays (1D)\n        self.xp = xp   # shape (N_ion,) \n        self.vp = vp\n        self.xe = xe\n        self.ve = ve\n\n        # Grid info\n        self.Ngrid = Ngrid\n        self.dx = 1.0 / Ngrid\n\n        # Physical parameters\n        self.dt = dt\n        self.massIon = massIon\n        self.massE   = massE\n        self.chargeIon = chargeIon\n        self.chargeE   = chargeE\n\n        # Simulation time/step\n        self.time = 0.0\n        self.step_count = 0\n\n    def array_periodic_boundary(self, x):\n        \"\"\"Wrap positions x into [0,1) to enforce periodic boundary.\"\"\"\n        x %= 1\n\n    def CIC_deposit(self, x, weight=1.0):\n        \"\"\"Simple Python version of CIC deposit.\"\"\"\n        rho = np.zeros(self.Ngrid)\n        m = weight / x.size\n\n        left = x - 0.5 * self.dx\n        xi = np.floor(left / self.dx).astype(np.int32) % self.Ngrid\n        frac = 1.0 - (left / self.dx - xi) % 1\n\n        # neighbor cell\n        xir = (xi + 1) % self.Ngrid\n        \n        # main deposit\n        w_main = frac * m\n        rho_main = np.bincount(xi, weights=w_main, minlength=self.Ngrid)\n\n        # neighbor deposit\n        w_next = (1.0 - frac) * m\n        rho_next = np.bincount(xir, weights=w_next, minlength=self.Ngrid)\n\n        rho = rho_main + rho_next\n        return rho * self.Ngrid\n    \n    def rebin_grad_phi(self, x, grad_phi):\n        \"\"\"\n        Interpolate grad_phi from grid to particle positions x (CIC gather).\n        \"\"\"\n        left = x - 0.5 * self.dx\n        xi = np.floor(left / self.dx).astype(np.int32) % self.Ngrid\n        frac = 1.0 - (left / self.dx - xi) % 1  # Ensure frac is wrapped within [0, 1)\n\n        xir = (xi + 1) % self.Ngrid  # Neighbor cell (wrapped)\n\n        g_main = grad_phi[xi]\n        g_next = grad_phi[xir]\n        return frac * g_main + (1.0 - frac) * g_next\n\n    def solve_poisson(self, rho):\n        \"\"\"Poisson solver in 1D with periodic BC using FFT.\"\"\"\n        delta_l = np.fft.fft(rho - 1.0)\n        k_ell   = 2 * np.pi * np.fft.fftfreq(self.Ngrid)\n        phi_l = np.zeros_like(k_ell, dtype=np.complex128)\n\n        # electrostatics =&gt; factor C = -1\n        C = -1.0\n        # avoid divide-by-zero\n        phi_l[1:] = (C / (self.Ngrid**2)) * delta_l[1:] / (np.sin(k_ell[1:] / 2)**2)\n        phi_l[0]  = 0.0\n\n        phi_x = np.fft.ifft(phi_l).real\n        return phi_x\n\n    def central_difference(self, y):\n        \"\"\"Compute derivative via central difference.\"\"\"\n        return 0.5 * (np.roll(y, -1) - np.roll(y, 1))\n\n    def accelerations_1D(x: np.ndarray, m: float, C: float) -&gt; np.ndarray:\n        \"\"\"\n        Compute 1D gravitational accelerations for labeled particles,\n        ensuring zero net force by subtracting the mass-weighted average acceleration.\n        C is the constant in the Poisson equation nabla^2 Phi = C rho\n        So for gravity C would be 4 pi G \n        \n        *Experimental* not tested yet.\n        \n        Parameters\n        ----------\n        x : np.ndarray of shape (N,)\n            Positions of particles in label order (not necessarily sorted).\n        m : float\n            Mass carried by each Lagrangian cell between x[i] and x[i+1].\n        C : float\n            Gravitational constant factor (e.g., 4*pi*G).\n            \n        Returns\n        -------\n        a : np.ndarray of shape (N,)\n            The gravitational acceleration at each particle,\n            shifted so the total force is zero.\n        \"\"\"\n        # 1. Compute differences between consecutive particle positions\n        dx = x[1:] - x[:-1]  # shape (N-1,)\n        \n        # 2. Piecewise densities (could be negative if dx&lt;0),\n        #    but for magnitude-based mass we use abs(dx) below\n        rho = m / dx  # shape (N-1,)\n        \n        # 3. Segment mass = rho * |dx|, effectively ±m\n        segment_mass = rho * np.abs(dx)\n        \n        # 4. Cumulative sum to get total mass to the left for each particle\n        mass_left = np.cumsum(segment_mass)\n        # Prepend zero for the first particle\n        mass_left = np.concatenate(([0.0], mass_left), axis=0)  # shape (N,)\n        \n        # 5. Gravitational acceleration from mass_left\n        a = -C * mass_left\n        \n        # 6. Subtract mean mass-weighted acceleration to ensure net force = 0\n        N = x.shape[0]\n        total_mass = N * m  # sum of all cell masses if each cell is mass m\n        a_mean = np.sum(m * a) / total_mass\n        a -= a_mean\n        \n        return a\n\n    def single_step(self):\n        \"\"\"Advance one time step with a leapfrog .\"\"\"\n        dt = self.dt\n\n        # 1) Drift half-step\n        self.xp += 0.5 * dt * self.vp\n        self.xe += 0.5 * dt * self.ve\n        self.array_periodic_boundary(self.xp)\n        self.array_periodic_boundary(self.xe)\n\n        # 2) Deposit\n        rhop = self.CIC_deposit(self.xp, weight=self.chargeIon)\n        rhoe = self.CIC_deposit(self.xe, weight=self.chargeE)\n        rho  = rhop + rhoe\n        rho -= rho.mean()\n\n        # 3) Solve Poisson\n        phi = self.solve_poisson(rho)\n\n        # 4) Compute grad\n        grad_phi = self.central_difference(phi) * self.Ngrid  # multiply by dx^-1 \n\n        # 5) Gather =&gt; acceleration\n        ap =  (self.chargeIon / self.massIon) * self.rebin_grad_phi(self.xp, grad_phi)\n        ae =  (self.chargeE   / self.massE  ) * self.rebin_grad_phi(self.xe, grad_phi)\n\n        # 6) Kick step\n        self.vp += dt * ap\n        self.ve += dt * ae\n\n        # 7) Final drift half-step\n        self.xp += 0.5 * dt * self.vp\n        self.xe += 0.5 * dt * self.ve\n\n        # 8) Update time\n        self.step_count += 1\n        self.time += dt\n\n    def run(self, Nsteps, store_interval=10,snapshots=[]):\n        \"\"\"\n        Run the simulation for Nsteps. Return a list of snapshots,\n        each a dict with arrays for xp, vp, xe, ve, plus time and step.\n        \"\"\"\n\n        for step in range(Nsteps):\n            self.single_step()\n\n            # If we want to store a snapshot:\n            if (step % store_interval) == 0:\n                self.array_periodic_boundary(self.xp)\n                self.array_periodic_boundary(self.xe)\n                snapshots.append({\n                    \"step\": self.step_count,\n                    \"time\": self.time,\n                    \"xp\": self.xp.copy(),\n                    \"vp\": self.vp.copy(),\n                    \"xe\": self.xe.copy(),\n                    \"ve\": self.ve.copy()\n                })\n\n        return snapshots\n\ndef plot_phase_space(sim, s, vmax=1):\n    import plotly.graph_objects as go\n    from plotly.subplots import make_subplots\n    import numpy as np\n\n    # ------------------------------\n    # 1. Precompute Histogram Parameters\n    # ------------------------------\n    \n    # Define the number of bins for histograms\n    nbins_x = sim.Ngrid  # Number of bins for x-axis histogram\n    nbins_y = sim.Ngrid  # Number of bins for y-axis histogram\n\n    # Define the fixed ranges for x and y axes\n    x_min, x_max = 0, 1        # Position range\n    y_min, y_max = -vmax, vmax # Velocity range\n\n    # Initialize variables to store maximum counts across all frames\n    max_count_x_e = 10  # Maximum count for x-axis histogram (Electrons)\n    max_count_x_p = 10  # Maximum count for x-axis histogram (Protons)\n    max_count_y_e = 10  # Maximum count for y-axis histogram (Electrons)\n    max_count_y_p = 10  # Maximum count for y-axis histogram (Protons)\n\n    # Iterate through all frames to determine maximum histogram counts\n    for frame in s:\n        # Electrons x-data\n        x_data_e = frame[\"xe\"]\n        counts_x_e, _ = np.histogram(x_data_e, bins=nbins_x, range=(x_min, x_max))\n        max_count_x_e = max(max_count_x_e, counts_x_e.max())\n\n        # Protons x-data\n        x_data_p = frame[\"xp\"]\n        counts_x_p, _ = np.histogram(x_data_p, bins=nbins_x, range=(x_min, x_max))\n        max_count_x_p = max(max_count_x_p, counts_x_p.max())\n\n        # Electrons y-data\n        y_data_e = frame[\"ve\"]\n        counts_y_e, _ = np.histogram(y_data_e, bins=nbins_y, range=(y_min, y_max))\n        max_count_y_e = max(max_count_y_e, counts_y_e.max())\n\n        # Protons y-data\n        vp_scaled = np.sqrt(sim.massIon / sim.massE) * frame[\"vp\"]\n        y_data_p = vp_scaled\n        counts_y_p, _ = np.histogram(y_data_p, bins=nbins_y, range=(y_min, y_max))\n        max_count_y_p = max(max_count_y_p, counts_y_p.max())\n\n    # ------------------------------\n    # 2. Create Subplots with Marginals\n    # ------------------------------\n    \n    # Create a 2x2 subplot grid\n    fig = make_subplots(\n        rows=2, cols=2,\n        shared_xaxes=True,\n        shared_yaxes=True,\n        vertical_spacing=0.05,\n        horizontal_spacing=0.05,\n        specs=[\n            [None, {\"type\": \"histogram\"}],        # Top-Left: Empty, Top-Right: X Histogram\n            [{\"type\": \"histogram\"}, {\"type\": \"scatter\"}]  # Bottom-Left: Y Histogram, Bottom-Right: Scatter Plot\n        ],\n        column_widths=[0.2, 0.8],  # Allocate 20% width to histograms, 80% to scatter plot\n        row_heights=[0.2, 0.8]     # Allocate 20% height to top histograms, 80% to scatter plot\n    )\n\n    # ------------------------------\n    # 3. Initialize Traces for the First Frame\n    # ------------------------------\n    \n    # Select the initial frame\n    i = 0\n    frame = s[i]\n    xe = frame[\"xe\"]\n    ve = frame[\"ve\"]\n    xp = frame[\"xp\"]\n    vp = frame[\"vp\"]\n    vp_scaled = np.sqrt(sim.massIon / sim.massE) * vp\n\n    # Add scatter trace for electrons\n    scatter_e = go.Scatter(\n        x=xe,\n        y=ve,\n        mode='markers',\n        name=f\"Electrons t={frame['time']:.1f} i={frame['step']}\",\n        marker=dict(color=\"blue\", size=5, opacity=0.6),\n        showlegend=True\n    )\n    fig.add_trace(scatter_e, row=2, col=2)  # Bottom-Right subplot\n\n    # Add scatter trace for protons\n    scatter_p = go.Scatter(\n        x=xp,\n        y=vp_scaled,\n        mode='markers',\n        name=\"Protons\",\n        marker=dict(color=\"red\", size=5, opacity=0.8),\n        showlegend=True\n    )\n    fig.add_trace(scatter_p, row=2, col=2)  # Bottom-Right subplot\n\n    # Add histogram trace for electrons (x-axis) (Top-Right subplot)\n    hist_x_e = go.Histogram(\n        x=xe,\n        nbinsx=nbins_x,\n        marker_color='blue',\n        opacity=0.5,\n        name='Electrons',\n        showlegend=True,\n        xbins=dict(start=x_min, end=x_max, size=(x_max - x_min) / nbins_x)\n    )\n    fig.add_trace(hist_x_e, row=1, col=2)  # Top-Right subplot\n\n    # Add histogram trace for protons (x-axis) (Top-Right subplot)\n    hist_x_p = go.Histogram(\n        x=xp,\n        nbinsx=nbins_x,\n        marker_color='red',\n        opacity=0.5,\n        name='Protons',\n        showlegend=True,\n        xbins=dict(start=x_min, end=x_max, size=(x_max - x_min) / nbins_x)\n    )\n    fig.add_trace(hist_x_p, row=1, col=2)  # Top-Right subplot\n\n    # Add histogram trace for electrons (y-axis) (Bottom-Left subplot)\n    hist_y_e = go.Histogram(\n        y=ve,\n        nbinsy=nbins_y,\n        marker_color='blue',\n        opacity=0.5,\n        name='Electrons',\n        showlegend=False,\n        ybins=dict(start=-vmax, end=vmax, size=2 * vmax / nbins_y)\n    )\n    fig.add_trace(hist_y_e, row=2, col=1)  # Bottom-Left subplot\n\n    # Add histogram trace for protons (y-axis) (Bottom-Left subplot)\n    hist_y_p = go.Histogram(\n        y=vp_scaled,\n        nbinsy=nbins_y,\n        marker_color='red',\n        opacity=0.5,\n        name='Protons',\n        showlegend=False,\n#        ybins=dict(start=-vmax, end=vmax, size=2 * vmax / nbins_y)\n        xbins=dict(start=-vmax, end=vmax, size=2 * vmax / nbins_y)\n    )\n    fig.add_trace(hist_y_p, row=2, col=1)  # Bottom-Left subplot\n\n    # ------------------------------\n    # 4. Configure Slider Steps\n    # ------------------------------\n    \n    steps = []\n    for i in range(len(s)):\n        frame = s[i]\n        xe = frame[\"xe\"]\n        ve = frame[\"ve\"]\n        xp = frame[\"xp\"]\n        vp = frame[\"vp\"]\n        vp_scaled = np.sqrt(sim.massIon / sim.massE) * vp\n\n        # Combine data for histograms\n        x_data_e = xe\n        x_data_p = xp\n        y_data_e = ve\n        y_data_p = vp_scaled\n\n        step = dict(\n            method=\"update\",\n            args=[\n                {\n                    # Update scatter traces\n                    \"x\": [xe, xp, x_data_e, x_data_p, None, None],        # Trace 0: scatter_e x, Trace 1: scatter_p x, Trace 2: hist_x_e x, Trace 3: hist_x_p x, Trace 4: hist_y_e x (unused), Trace 5: hist_y_p x (unused)\n                    \"y\": [ve, vp_scaled, None, None, y_data_e, y_data_p] # Trace 0: scatter_e y, Trace 1: scatter_p y, Trace 2: hist_x_e y (unused), Trace 3: hist_x_p y (unused), Trace 4: hist_y_e y, Trace 5: hist_y_p y\n                },\n                {\n                    \"title\": f\"Phase Space: t={frame['time']:.1f} i={frame['step']}\"\n                }\n            ],\n            label=f\"t={frame['time']:.1f} i={frame['step']}\"\n        )\n        steps.append(step)\n\n    # Define the slider\n    sliders = [dict(\n        active=0,\n        currentvalue={\"prefix\": \"Time = \"},\n        pad={\"t\": 50},\n        steps=steps\n    )]\n\n    # ------------------------------\n    # 5. Finalize Layout\n    # ------------------------------\n    \n    fig.update_layout(\n        sliders=sliders,\n        title=\"Phase Space\",\n        showlegend=True,\n        legend=dict(title=\"Legend\", orientation=\"v\", x=1, y=1),\n        template=\"plotly_white\",\n        height=700,\n        width=800,\n        barmode='overlay'  # Overlay histograms for better visibility\n    )\n\n    # Configure axes for histograms and scatter plot\n\n    # Scatter Plot Axes (Bottom-Right subplot: row=2, col=2)\n    fig.update_xaxes(title_text=\"x\", range=[x_min, x_max], row=2, col=2)\n    fig.update_yaxes(title_text=\"v\", range=[y_min, y_max], row=2, col=2)\n\n    # X-axis Histogram (Top-Right subplot: row=1, col=2)\n    fig.update_xaxes(title_text=\"x Distribution\", range=[x_min, x_max], row=1, col=2)\n    fig.update_yaxes(title_text=\"Counts\", range=[0, max(max_count_x_e, max_count_x_p)], row=1, col=2)\n\n    # Y-axis Histogram (Bottom-Left subplot: row=2, col=1)\n    fig.update_xaxes(title_text=\"Counts\", range=[0, max(max_count_y_e, max_count_y_p)], row=2, col=1, showticklabels=False)\n    fig.update_yaxes(title_text=\"v Distribution\", range=[y_min, y_max], row=2, col=1)\n\n    # Hide unused subplot (Top-Left)\n    fig.update_layout(\n        annotations=[\n            dict(\n                text=\"\",\n                x=0.15, y=0.85,\n                showarrow=False,\n                xref=\"paper\",\n                yref=\"paper\"\n            )\n        ]\n    )\n\n    # ------------------------------\n    # 6. Display the Figure\n    # ------------------------------\n    \n    fig.show()\n# Setup initial data : 2 particles orbiting\nNp = 2\nxp0 = np.array([0.5])\nvp0 = 0\nxe0 = np.array([0.6])\nve0 = 0\n\n\n# Create the simulation\nosim = PICSimulation(\n    xp=xp0, vp=vp0,\n    xe=xe0, ve=ve0,\n    Ngrid    = 128,\n    dt       = 0.003,\n    massIon  = 1.0,\n    massE    = 1e-1,\n    chargeIon=  1.0,\n    chargeE  = -1.0\n)\n\nso=0.\nso = [] # store snapshots\n# Run for 100 steps, storing snapshots every 2 steps\nso = osim.run(Nsteps=400, store_interval=4)\n#so = osim.run(Nsteps=30_000, store_interval=1_000,snapshots=so)\n\nprint(f\"Final time:  {osim.time:.2f}, Final step: {osim.step_count}\")\nprint(\"Number of snapshots:\", len(so))\n\nplot_phase_space(osim,so,vmax=2)\n# Setup initial data: random proton and electron positions\nNp = 1000\nxp0 = np.random.rand(Np)\nvp0 = np.random.randn(Np)*0.1\nxe0 = np.random.rand(Np)\nve0 = np.random.randn(Np)*0.1\n\nvp0 -= vp0.mean()\nve0 -= ve0.mean()\n\n# Create the simulation\nsim = PICSimulation(\n    xp=xp0, vp=vp0,\n    xe=xe0, ve=ve0,\n    Ngrid    = 128,\n    dt       = 0.003,\n    massIon  = 1.0,\n    massE    = 1e-1,\n    chargeIon=  1.0,\n    chargeE  = -1.0\n)\n\ns = [] # store snapshots\n# Run for 100 steps, storing snapshots every 2 steps\ns = sim.run(Nsteps=100, store_interval=2)\ns = sim.run(Nsteps=30_000, store_interval=1_000,snapshots=s.copy())\n\nprint(f\"Final time:  {sim.time:.2f}, Final step: {sim.step_count}\")\nprint(\"Number of snapshots:\", len(s))\n\nplot_phase_space(sim,s,vmax=0.5)\n# initial conditions: random electron positions\nNh = 800\nxp0 = np.random.uniform(size=Nh)  # initial positions  ions\nxp0 = np.linspace(1/Nh/2, 1-1/Nh/2, Nh) # uniform lattice of protons\nvp0 = np.zeros(shape=Nh)          # initial velocities\nxe0 = np.random.uniform(size=Nh)  # same for electrons\nve0 = np.zeros(shape=Nh)\n\n\n\n# Create the simulation\nsim = PICSimulation(\n    xp=xp0, vp=vp0,\n    xe=xe0, ve=ve0,\n    Ngrid    = 128,\n    dt       = 0.003,\n    massIon  = 1.0,\n    massE    = 1e-1,\n    chargeIon=  1.0,\n    chargeE  = -1.0\n)\n\ns = [] # store snapshots\n# Run for 100 steps, storing snapshots every 2 steps\ns = sim.run(Nsteps=100, store_interval=4)\ns = sim.run(Nsteps=30_000, store_interval=1_000,snapshots=s)\n\nprint(f\"Final time:  {sim.time:.2f}, Final step: {sim.step_count}\")\nprint(\"Number of snapshots:\", len(s))\n\nplot_phase_space(sim,s,vmax=0.5)\nimport matplotlib.pyplot as plt\nNout = len(s)\nrelE = np.array([[s[i][\"time\"], s[i][\"vp\"].var()/s[i][\"ve\"].var() * sim.massIon/sim.massE] for i in range(1,Nout)])\nplt.plot(relE[:,0], relE[:,1],'.');\n# initial conditions: Large velocity perturbation in the electrons\nNh = 800\nxp0 = np.random.uniform(size=Nh)  # initial positions  ions\nxp0 = np.linspace(1/Nh/2, 1-1/Nh/2, Nh) # uniform lattice of protons\nvp0 = np.zeros(shape=Nh)          # initial velocities\nxe0 = np.linspace(1/Nh/2, 1-1/Nh/2, Nh) # same for electrons\nve0 = 0.1 * np.sin(8 * 2*np.pi*xe0)\n\n\n\n# Create the simulation\nsim = PICSimulation(\n    xp=xp0, vp=vp0,\n    xe=xe0, ve=ve0,\n    Ngrid    = 128,\n    dt       = 0.003,\n    massIon  = 1.0,\n    massE    = 1e-1,\n    chargeIon=  1.0,\n    chargeE  = -1.0\n)\n\ns = [] # store snapshots\n# Run for 100 steps, storing snapshots every 2 steps\ns = sim.run(Nsteps=400, store_interval=4)\ns = sim.run(Nsteps=30_000, store_interval=1_000,snapshots=s)\n\nprint(f\"Final time:  {sim.time:.2f}, Final step: {sim.step_count}\")\nprint(\"Number of snapshots:\", len(s))\n\nplot_phase_space(sim,s,vmax=0.5)\n# initial conditions: Two stream instability\nNh = 2048\nxp0 = np.random.uniform(size=Nh)  # initial positions  ions\nxp0 = np.linspace(1/Nh/2, 1-1/Nh/2, Nh) # uniform lattice of protons\nvs = 0.02 \nvp0 = vs * np.ones(shape=Nh)          # initial velocities\nxe0 = np.linspace(1/Nh/2, 1-1/Nh/2, Nh) # same for electrons\nmi = 1 ; me = 1\nve0 =  0.01 * np.sin(8 * 2*np.pi*xe0) - vs * mi/me \n\n# Create the simulation\nsim = PICSimulation(\n    xp=xp0, vp=vp0,\n    xe=xe0, ve=ve0,\n    Ngrid    = 256,\n    dt       = 0.003,\n    massIon  = mi,\n    massE    = me,\n    chargeIon=  1.0,\n    chargeE  = -1.0\n)\n\ns = [] # store snapshots\n# Run for 100 steps, storing snapshots every 2 steps\ns = sim.run(Nsteps=16_400, store_interval=24)\n#s = sim.run(Nsteps=30_000, store_interval=1_000,snapshots=s)\n\nprint(f\"Final time:  {sim.time:.2f}, Final step: {sim.step_count}\")\nprint(\"Number of snapshots:\", len(s))\n\nplot_phase_space(sim,s,vmax=2.5 * mi/me *vs)\n\nFinal time:  49.20, Final step: 16400\nNumber of snapshots: 684\n# initial conditions: uniform electron positions\nNh = 10\nxp0 = np.random.uniform(size=Nh)  # initial positions  ions\nxp0 = np.linspace(1/Nh/2, 1-1/Nh/2, Nh) # uniform lattice of protons\nvp0 = np.zeros(shape=Nh)          # initial velocities\nxe0 = np.linspace(0, 1-1/Nh, Nh)  # same for electronsa offset half a lattice spacing\nve0 = np.zeros(shape=Nh)\n\n\n# Create the simulation\nsim = PICSimulation(\n    xp=xp0, vp=vp0,\n    xe=xe0, ve=ve0,\n    Ngrid    = 128,\n    dt       = 0.03,\n    massIon  = 1.0,\n    massE    = 1e-1,\n    chargeIon=  1.0,\n    chargeE  = -1.0\n)\n\ns = [] # store snapshots\n# Run for 100 steps, storing snapshots every 2 steps\ns = sim.run(Nsteps=100, store_interval=1)\n#s = sim.run(Nsteps=30_000, store_interval=1_000,snapshots=s)\n\nprint(f\"Final time:  {sim.time:.2f}, Final step: {sim.step_count}\")\nprint(\"Number of snapshots:\", len(s))\n\nplot_phase_space(sim,s,vmax=0.5)\n# initial conditions: uniform electron positions\nNh = 5\nxp0 = np.random.uniform(size=Nh)  # initial positions  ions\nxp0 = np.linspace(1/Nh/2, 1-1/Nh/2, Nh) # uniform lattice of protons\nvp0 = np.zeros(shape=Nh)          # initial velocities\nxe0 = np.linspace(0, 1-1/Nh, Nh)  # same for electronsa offset half a lattice spacing\nve0 = np.zeros(shape=Nh)\n\n# Create the simulation\nsim = PICSimulation(\n    xp=xp0, vp=vp0,\n    xe=xe0, ve=ve0,\n    Ngrid    = 10,\n    dt       = 0.03,\n    massIon  = 1.0,\n    massE    = 1e-1,\n    chargeIon=  1.0,\n    chargeE  = -1.0\n)\nr = sim.CIC_deposit(xe0)\nimport matplotlib.pyplot as plt\nplt.plot(r,'x-')"
  },
  {
    "objectID": "tutorials/plasma_pic_1D.html#beware-this-code-may-need-more-testing.",
    "href": "tutorials/plasma_pic_1D.html#beware-this-code-may-need-more-testing.",
    "title": "Example of 1D particle in cell code for plasma dynamics",
    "section": "Beware this code may need more testing.",
    "text": "Beware this code may need more testing."
  },
  {
    "objectID": "tutorials/lagrangian-hydrodynamics.html",
    "href": "tutorials/lagrangian-hydrodynamics.html",
    "title": "Lagrangian Hydrodynamics",
    "section": "",
    "text": "INTRODUCTION\nAn inviscid fluid flow is described through the following conservation equations collectively known as the Euler equations.\nConservation of mass (continuity equation): \\[\n\\dot{\\rho} + \\nabla(\\rho\\,\\mathbf{v}) = 0, \\ \\ \\text{or} \\ \\ \\ \\ \\left( \\frac{\\partial }{\\partial t} + \\mathbf{v} \\nabla\\right) \\rho = - \\rho \\nabla\\mathbf{v}\n\\]\nConservation of momentum: (Navier Stokes equation) \\[\n\\rho \\left( \\frac{\\partial }{\\partial t} + \\mathbf{v} \\cdot \\nabla  \\right) \\mathbf{v}= -\\nabla p + \\rho \\nu \\nabla^2 \\mathbf{v},\n\\] where \\(\\nu\\) is the kinematic viscosity.\nConservation of energy: \\[\n\\frac{\\partial e}{\\partial t} + \\nabla\\cdot(e\\,\\mathbf{v}) + p\\nabla\\cdot\\mathbf{v} = 0\n\\]\nIn certain situations the pressure can sometimes be expressed as a function of \\(\\rho\\) only. Such as in the isothermal equation of state \\(p=c_0^2\\,\\rho\\), where \\(c_0\\) is the speed of sound. In this case the behavior is given only from the continuity equation and the momentum equation. Because \\(\\nabla p=c_0^2 \\nabla\\rho\\) and that is all we need for the momentum equation.\nIn this case for a Lagrangian description this boils down to solving this single equation: \\[\n\\frac{D\\mathbf{v}}{Dt} = -\\frac{1}{\\rho}\\nabla p\n\\]\nSo we have a second-order differential equation for the positions of our mass grid.\nSo imagine we discretized the total mass \\(M\\) with \\(N\\) shells of mass, \\(\\triangle m\\) , with edges of \\(r_i\\) with \\(0&lt;i&lt;N\\) in the domain \\([0,1]\\). Call the initial pressure distribution at time zero \\(p_0\\) and realize that the density, \\(\\rho_i\\) in our grid zones is always just simply given by \\(\\rho_i = \\triangle m/|r_{i+1}-r_{i}|\\). So if we can describe our fluid purely with an equation of state described by \\(p = c_0^2\\rho\\) we only need to store the initial value of \\(c_0\\) which may be a different in different parcels of the gas.\nWe will first use a simple leap frog integrator to solve this. This operates in two parts. First we update the positions by half a time step \\(r_i = r_i + (dt/2)\\,v_i\\) then using these positions to calculate the accelerations\nFor the special case where pressure is only a function of density these are the only equations we would need. More generally we also have to consider an energy (or entropy) equation in order to account for the possibility that the internal energy could be different for different densities. However, in the Lagrangian case we know right away that the energy change is just the work done on the cell. I.e. \\[\n\\frac{Du}{dt} = - p \\frac{dV}{dt},\n\\] where \\(dV\\) is the rate of change of the fluid element volume we are considering.\nLinearizing the continuity and momentum equation above for small perturbations \\(\\rho_1\\) and \\(v_1\\) (i.e. assume \\(\\rho = \\rho_0 + \\rho_1\\) and \\(v = 0+v_1\\)) and differentiating the momentum equation one more time in time we can obtain the wave solutions with the linear dispersion relation \\(\\omega=ck\\) \\[\nv = v_{a} \\exp[i(kx+\\omega t)] = v_{a}\\exp[ik(x + c t)] , \\ \\ \\ \\rho = \\rho_0 \\left(1-\\frac{v_1}{c}\\right).\n\\] The mass coordinate is \\[\nm(x) = \\int_0^1 \\rho dx = \\rho_0\\left[x+\\frac{v_a}{2\\pi\\,c_0}(\\cos(2\\pi\\,x)-1)\\right]\n\\] so to set up a simple test we can choose equidistant points in mass and derive the positions by finding the roots of this last equation.\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time as systime\n#from scitools.std import as sci\nfrom scipy.optimize import brentq \n\n# Set default figure size to 10 inches wide by 6 inches tall\nplt.rcParams['figure.figsize'] = [8, 5]\n\ndef accGradP(dr,m,c):\n    rho = (m/np.fabs(dr))\n    press = c**2 * rho\n    return -1./rho * (press-np.roll(press,1))/(0.5*np.fabs(dr+np.roll(dr,1)))\n\nN = 300\nr = (0.+np.arange(N))/N\nva = .01\nrho0 = 1.\nc = 1.\nv = va*np.sin(4.*np.pi*r)\nc0 = np.ones(N)\nc0[:] = c\nm = 1./N\n\nmass = lambda x,off: rho0*(x+va/c*(np.cos(4.*np.pi*x)-1)/4/np.pi)-off\nfor i in range(len(r)):\n    r[i] = brentq(mass,0,1,args=(r[i]))\ndr = np.roll(r,-1)-r\n\n    \nCourantfactor = 0.2\ndt = Courantfactor * 1./N\n\ntfinal = 16.9\ntime = [0.]\nvmax = [max(v)]\ncount=0\nwhile (time[-1]&lt;tfinal and count &lt; 500000):\n    r += dt/2 * v\n    r[r&gt;1] -= 1.\n    r[r&lt;0] += 1.\n    dr = np.roll(r,-1)-r\n    ind = np.where(np.fabs(dr)&gt;0.5)\n    dr[ind] = np.fabs(1.+dr[ind])\n    acc = accGradP(dr,m,c0) \n    v += dt * acc\n#    print accGradP(r,m,c0)\n    r += dt/2 * v\n    dt = Courantfactor*min(dr)/max((max(c0),max(v)))\n    time.append((time[-1]+dt))\n    count += 1\n    vmax.append(max(v))\n    \nprint(count, ' time steps to time: ', time[-1])\nplt.plot(r,v,'.',label=\"velocity\")\nplt.xlabel(\"position\")\nplt.legend();\n\n25715  time steps to time:  16.900384016172453\nplt.plot(r,m/dr,'.',label=\"density\");\nplt.xlabel('position')\nplt.legend();\nDid we screw up our approach to solving the equations? What happened to our wave?"
  },
  {
    "objectID": "tutorials/lagrangian-hydrodynamics.html#wave-steepening",
    "href": "tutorials/lagrangian-hydrodynamics.html#wave-steepening",
    "title": "Lagrangian Hydrodynamics",
    "section": "Wave steepening",
    "text": "Wave steepening\nEssentially all non-linear wave steepen! The ones that do not are arranged such that their dispersion just cancels the steepening. These are called solitary wave or solitons. This is actually quite easy to understand. The sound speed of a gas is given by \\(c^2 = \\partial p/\\partial \\rho\\)\n\nArtificial Viscosity\n\nA Method for the Numerical Calculation of Hydrodynamic Shocks 1950 by J. VonNeumann and R. D. Richtmyer layed out how to study shock waves by inroducing a so called artificial viscosity into the method. Let us explore this and see whether we can make it work.\n\ndef accVisc(dr,m,v,dx_smear=.01):\n    dv = (np.roll(v,-1)-v)/dr\n    dif = -dx_smear**2 *dv*np.fabs(dv)  *(np.fabs(dr)/m)\n    return -1./m*dr*(dif-np.roll(dif,1))/(0.5*np.fabs(dr+np.roll(dr,1)))\n\ndef accGradP(dr,m,c):\n    dif = c**2* (m/np.fabs(dr))\n    return -1./m*dr*(dif-np.roll(dif,1))/(0.5*np.fabs(dr+np.roll(dr,1)))\n\nN = 160\nr = (0.+np.arange(N))/N\nxL = r+.5/N\nva = .1\nrho0 = 1.\nc = 1.\nv = va*np.sin(4.*np.pi*r)\nc0 = np.ones(N)\nc0[:] = c\nm = 1./N\n\nmass = lambda x,off: rho0*(x+va/c*(np.cos(4.*np.pi*x)-1)/4/np.pi)-off\nfor i in range(len(r)):\n    r[i] = brentq(mass,0,1,args=(r[i]))\ndr = np.roll(r,-1)-r\n\nCourantfactor = 0.2\ndt = Courantfactor * 1./N/max(v)\n\ntfinal = 3.5\ntime = [0.]\nvmax = [max(v)]\ncount=0\nwhile (time[-1]&lt;tfinal and count &lt; 500000):\n    r += dt/2 * v\n    r[r&gt;1] -= 1.\n    r[r&lt;0] += 1.\n    dr = np.roll(r,-1)-r\n    ind = np.where(np.fabs(dr)&gt;0.5)\n    dr[ind] = np.fabs(1.+dr[ind])\n    acc = accGradP(dr,m,c0) + accVisc(dr,m,v,dx_smear=.02)\n    v += dt * acc\n#    print accGradP(r,m,c0)\n    r += dt/2 * v\n    dt = Courantfactor*min(dr)/max((max(c0),max(v)))\n\n    time.append((time[-1]+dt))\n    count += 1\n    vmax.append(max(v))\n    \nprint(count, ' time steps to time: ', time[-1])\nplt.plot(r,v,'.',label=\"velocity\")\nplt.xlabel(\"position\")\nplt.legend();\n\n3041  time steps to time:  3.5000962670733284\n\n\n\n\n\n\n\n\n\n\nplot(r,accGradP(dr,m,c0), r, .01*accVisc(dr,m,v,dx_smear=.5));\n\nClean up the code a bit.\n\ndef diff(y):\n    return y[1:]-y[0:-1]\ndef av(y):\n    return (y[1:]+y[0:-1])/2\ndef eos_u(rho, p):\n    u = p\n    return u\n    \nclass EquationOfState:\n    def __init__(self, gammain):\n        self.gamma = gammain\n    def u(self,rho,p):\n        return 1./(self.gamma-1.) * p/rho\n    def cs(self,rho,p):\n        return sqrt(self.gamma*p/rho)\n    def p(self,rho,u):\n        return (self.gamma-1)*rho*u\n\ndef VNR_q(dr,dm,v,kdx=.1):\n    '''return VanNeumann Richtmyer viscosity'''\n    dv = (v-np.roll(v,-1))/dr\n    q = -kdx**2 *dv*fabs(dv)  *dr/dm\n    return q\n\ndef accGradP(dr,m,p):\n    rho = m/dr\n    return -1./rho*(p-np.roll(p,1))/(0.5*fabs(dr+np.roll(dr,1)))\n\ngasgamma = 1.001\neos = EquationOfState(gasgamma)\n\ndef LagrangeHydro(tfinal, r, v, dm, p):\n    N = len(r)\n    Courantfactor = 0.2\n    dr = np.roll(r,-1)-r # cell volumes. \n    ind = where(fabs(dr)&gt;0.5)\n    dr[ind] = fabs(1.+dr[ind])\n    drold = dr\n    rho = dm/dr\n    u = eos.u(rho, p)\n    cs = eos.cs(rho,p)\n    dt = Courantfactor * 1./N/max((max(cs), max(v)))\n    kvnr = 4.\n    dxvnr = 1./N\n\n    count=0\n    time = 0.\n    while (time&lt;tfinal and count &lt; 500000):\n        r += dt/2 * v\n        dr = np.roll(r,-1)-r\n        ind = where(fabs(dr)&gt;0.5)\n        dr[ind] = fabs(1.+dr[ind])\n        q = VNR_q(dr,dm,v,kdx=kvnr*dxvnr)\n        p = eos.p(dm/dr,u)\n        \n        acc = accGradP(dr,m,p+q) \n        v += dt * acc\n    #    print accGradP(r,m,c0)\n        r += dt/2 * v\n        r[r&gt;1] -= 1.\n        r[r&lt;0] += 1.\n\n        dr = np.roll(r,-1)-r # cell volumes. \n        ind = where(fabs(dr)&gt;0.5)\n        dr[ind] = fabs(1.+dr[ind])\n        \n        dV = dr-drold\n        u -= (p+q)*dV/dm\n        rho = dm/dr\n        p = eos.p(rho,u)\n        \n        drold = dr\n        time += dt\n        dt = Courantfactor*min(abs(dr))/(max(eos.cs(rho,p+q)+abs((v-np.roll(v,-1)) ))) # new time step\n\n        count += 1\n    return r, v, rho, p, u\n\n\nN = 160\nr = (0.+np.arange(N))/N\nxL = r+.5/N\nva = .1\nrho0 = 1.\nc = 1.\nv = va*sin(4.*np.pi*r)\nc0 = np.ones(N)\nc0[:] = c\nm = 1./N\n\nmass = lambda x,off: rho0*(x+va/c*(cos(4.*np.pi*x)-1)/4/np.pi)-off\nfor i in range(len(r)):\n    r[i] = brentq(mass,0,1,args=(r[i]))\ndr = np.roll(r,-1)-r\nind = where(fabs(dr)&gt;0.5)\ndr[ind] = fabs(1.+dr[ind])\n\np = m/dr\n\nr, v, den, p, u = LagrangeHydro(.1, r, v, m, p)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[46], line 7\n      5 rho0 = 1.\n      6 c = 1.\n----&gt; 7 v = va*sin(4.*np.pi*r)\n      8 c0 = np.ones(N)\n      9 c0[:] = c\n\nNameError: name 'sin' is not defined\n\n\n\n\nimport JSAnimation\nfrom JSAnimation import IPython_display\nfrom matplotlib import animation\n\ndef HydroMovie(solver, h=1.0, tfinal=2*2.0*np.pi, w0=1.0, phase=1.0):\n    x, v, t = solver(tfinal, h, w0, phase)\n    \n    skiprate = int(len(t) / 100)\n    skiprate = max(skiprate, 1)\n    t = t[::skiprate]\n    x = x[::skiprate]\n    v = v[::skiprate]\n    # create a simple animation\n    fig = plt.figure()\n\n    ax = plt.axes(xlim=(-2, 2), ylim=(-2, 2))\n    line, = ax.plot([], [], lw=2)\n    ax.set_xlabel('x')\n    ax.set_ylabel('v')\n        \n    def init():\n        line.set_data([], [])\n        return line,\n    \n    def animate(i):\n        line.set_data(x[:i], v[:i])\n        return line,\n    \n    return animation.FuncAnimation(fig, animate, init_func=init,\n                            frames=len(t), interval=60, blit=True)\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[47], line 1\n----&gt; 1 import JSAnimation\n      2 from JSAnimation import IPython_display\n      3 from matplotlib import animation\n\nModuleNotFoundError: No module named 'JSAnimation'\n\n\n\n\n\nmass = lambda x,off: rho0*(x+va/c*(np.cos(4.*np.pi*x)-1)/4/np.pi)-off\nfor i in range(len(r)):\n    r[i] = brentq(mass,0,1,args=(r[i]))\ndr = np.roll(r,-1)-r\n\n\nShock tube\n\nLet us study a problem where we have an experiment in which we have a tube with fixed ends. I.e. boundary conditions for the velocity will be \\(v(x=0)=v(x-1)=0\\) in which we prepared the left half of the tube with gas of a certain pressure, and density, \\(p_l\\) and \\(\\rho_l\\) separated from the the fluid on the right with \\(p_r\\) and \\(\\rho_l\\) at \\(t=0\\). You could imagine e.g. that we had a thin membrane to separate the two parts which we can remove very fast.  To setup the interface we will use a smoothly varying function rather than an infinitesimal thin interface using the function \\(R(x)\\) defined as \\[\nR(x)\\equiv \\left[\\tanh(x-x_0)/\\triangle x+1\\right]/2,\n\\] which goes smoothly from 0 to 1 at \\(x_0\\) over an interval of approximate width \\(\\triangle x\\).\n\nimport matplotlib.pyplot as plt\nimport numpy as np\ndef ramp(x,x0,dx):\n    '''ramp function. Goes from 0 to 1 smoothly at x0 over a transition region with width dx'''\n    return (np.tanh((x-x0)/dx)+1.)/2\ndef rampInt(x,x0,dx):\n    ''' integral from 0 to x of the ramp function ramp(x,x0,dx)'''\n    return 0.5*(x + dx*np.log(np.cosh((x-x0)/dx)/np.cosh(x0/dx)))\n\n\nx=np.linspace(0,1,100)\nx0 =.5\ndx = 0.1\nplt.plot(x,ramp(x,x0,dx))\nplt.plot(x,rampInt(x,x0,dx))\nprint(\"value of ramp function dx from x0:\",ramp(x0-dx,x0,dx), \\\n    \"\\n integral of rampInt\", rampInt(1.,x0,dx) )\n\nvalue of ramp function dx from x0: 0.11920292202211763 \n integral of rampInt 0.5\n\n\n\n\n\n\n\n\n\nSo now we can describe e.g. the density as \\[\n\\rho(x)=\\rho_l+R(x)\\,(\\rho_r-\\rho_l)\n\\] and have as the integral \\[\n\\int_0^x \\rho(x') dx' = \\rho_l\\,x+(\\rho_r-\\rho_l) RI(x)\n\\] where \\(RI(x)=\\int_0^x R(x')dx'\\).\n\nrhol=2\nrhor=1\nrho = rhol + ramp(x,x0,dx)*(rhor-rhol)\nmass = rhol*x + (rhor-rhol)*rampInt(x,x0,dx)\nplt.plot(x,rho,label=\"Density\")\nplt.plot(x,mass,label=\"Mass(&lt;x)\")\nplt.xlabel(\"x\")\nplt.legend();\n\n\n\n\n\n\n\n\nSo now we have \\[\n\\rho(x)=\\rho_l+R(x)\\,(\\rho_r-\\rho_l)\n\\] \\[\np(x)=p_l+R(x)\\,(p_r-p_l)\n\\] $$ v(x)=v_l+R(x),(v_r-v_l)\n\nfrom scipy.optimize import brentq \n\ndef diff(y):\n    return y[1:]-y[0:-1]\ndef av(y):\n    return (y[1:]+y[0:-1])/2\ndef eos_u(rho, p):\n    u = p\n    return u\n    \nclass EquationOfState:\n    def __init__(self, gammain):\n        self.gamma = gammain\n    def u(self,rho,p):\n        return 1./(self.gamma-1) * p/rho\n    def cs(self,rho,p):\n        return np.sqrt(self.gamma*p/rho)\n    def p(self,rho,u):\n        return (self.gamma-1)*rho*u\n    \n    \n## User Parameters\nN = 1000\nrhol = 1\nrhor = 1\npl = 1000.\npr = 1\nvl = 0\nvr = 0\nx0 = 0.5\ndx = 1./N\nkvnr = 4.\ndxvnr = 1./N\n\ngasgamma = 5./3\neos = EquationOfState(gasgamma)\n## ===== done initial conditions specification\n\nmass = lambda x,off: rhol*x + (rhor-rhol)*rampInt(x,x0,dx) - off\n# now we discretize using equal mass bins\nmt = np.linspace(0,1,N)*mass(1,0)\nr = np.zeros(N)\nfor i in range(len(mt)):\n    r[i] = brentq(mass,0,1,args=(mt[i]))  # cell faces containing mass mt[i]\nra = av(r) # cell centers\n\ndr = diff(r)  # cell widths\ndm = diff(mt) # mass of cell\nrho = dm/dr\nv = vl + ramp(r,x0,dx)*(vr-vl)  # velocities cell faces\np = pl + ramp(ra,x0,dx)*(pr-pl) # pressure at cell centers\nu = eos.u(rho, p)\n\ndef VNR_q(dr,dm,v,kdx=.1):\n    '''return VanNeumann Richtmyer viscosity'''\n    dv = diff(v)/dr\n    q = -kdx**2 *dv*np.fabs(dv)  *dr/dm\n    return q\n\ndef accGradP(dr,dm,p):\n    rho = dm/dr\n    return np.concatenate(([0],-1./av(rho)*diff(p)/av(dr),[0]))\n\n\nCourantfactor = .2\ndt = Courantfactor * 1./np.max(eos.cs(rho,p))/N \n\ntfinal = 0.01  # try for time = 1, 2, 3 and 5 \ntime = [0.]\nvmax = [max(v)]\ncount=0\nedges = [0,-1]\nv[edges] = 0\ndrold = diff(r)\nstates = []\n\nwhile (time[-1]&lt;tfinal and count &lt; 100000):\n    r += dt/2 * v\n    dr = diff(r) # cell volumes. \n    q = VNR_q(dr,dm,v,kdx=kvnr*dxvnr)\n    p = eos.p(dm/dr,u)\n#    print min(q), max(q), median(q)\n    acc = accGradP(dr,dm,p+q) # now accelerations and continue with leap frog step\n    v += dt * acc\n    r += dt/2 * v\n    time.append((time[-1]+dt)) # remember times\n\n    dr = diff(r) # cell volumes. \n    dV = dr-drold\n    u -= (p+q)*dV/dm\n    p = eos.p(rho,u)\n    rho = dm/dr\n    \n    drold = dr\n    dt = Courantfactor*min(abs(dr))/(max(eos.cs(rho,p+q)+abs(diff(v)) )) # new time step\n    dt = min([dt, tfinal-time[-1]])  # do not integrate longer than asked to\n\n    count += 1\n    vmax.append(max(v))\n    \n    if ((count % 1) == 0):\n        # Grab data at this step\n        state_data = {\n            \"density\"   : rho.copy(),\n            \"x_momentum\": v.copy(),\n            \"pressure\"  : p.copy(),\n            \"energy\"    : u.copy(),\n            \"x\"         : r.copy(),\n            \"step\"      : count  # current step number\n        }\n        states.append(state_data)\n    \n    \n#    print (((u)+av(v)**2/2)*dm).sum()\n\n\nrhop = (gasgamma-1)/(gasgamma+1)\nf, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, sharex='col')\nax1.plot(ra, rho,label='density')\n\nax2.plot(ra, av(v)/eos.cs(rho,p),'rx-', label='velocity')\nax2.yaxis.tick_right()\nax3.semilogy(ra, p, label='pressure')\nax3.set_xlabel('position')\nax4.semilogy(ra, u, label='internal energy')\nax4.yaxis.tick_right()\nax4.set_xlabel('position')\nfor i in (ax1,ax2,ax3,ax4):\n    leg = i.legend(loc='best', fancybox=False)\n    leg.get_frame().set_alpha(0.5)\n\nf.subplots_adjust(wspace=0,hspace=0)\n\n\n\n\n\n\n\n\n\nimport ipywidgets as widgets\nfrom IPython.display import display\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\ndef shocktube_animation_app(states):\n    \"\"\"\n    Create an interactive slider + play widget to browse precomputed 'states'.\n\n    Parameters\n    ----------\n    states : list of dict\n        Each element is a dictionary with keys:\n         - \"density\", \"x_momentum\", \"pressure\", \"energy\" (arrays)\n         - \"x\": the spatial coordinate array\n         - \"step\": integer time step index\n\n    Returns\n    -------\n    ui : widgets.VBox\n        A VBox widget containing the slider, play controls, and the plot output.\n    \"\"\"\n    # The total number of precomputed states\n    ntotal = len(states)\n\n    # 1) Create a slider to pick the index in [0, ntotal-1]\n    slider = widgets.IntSlider(value=0, min=0, max=ntotal - 1, step=1,\n        description='Step', continuous_update=False)\n\n    # 2) Create a Play widget for auto animation\n    play = widgets.Play(value=0, min=0, max=ntotal - 1,\n        step=1,interval=200,       # ms between frames\n        description=\"Press play\", disabled=False)\n\n    # Link the Play widget and the slider\n    widgets.jslink((play, 'value'), (slider, 'value'))\n    widgets.jslink((slider, 'value'), (play, 'value'))\n\n    # 3) Create an output area for the Plotly figure\n    output_area = widgets.Output()\n\n    def update_plot(change=None):\n        \"\"\"Draw the figure for the current slider value.\"\"\"\n        index = slider.value\n        state = states[index]\n\n        with output_area:\n            # Extract data\n            x          = state[\"x\"]\n            step_num   = state[\"step\"]\n\n            # Build the figure\n            fig = make_subplots( rows=2, cols=2,\n                subplot_titles=[\"Density\", \"X-Momentum\", \"Pressure\", \"Energy\"],\n                vertical_spacing=0.09 )\n\n            # 2x2 subplots\n            fig.add_trace(go.Scatter(x=x, y=state[\"density\"],    mode='lines+markers'), row=1, col=1)\n            fig.add_trace(go.Scatter(x=x, y=state[\"x_momentum\"], mode='lines+markers'), row=1, col=2)\n            fig.add_trace(go.Scatter(x=x, y=state[\"pressure\"],   mode='lines+markers'), row=2, col=1)\n            fig.add_trace(go.Scatter(x=x, y=state[\"energy\"],     mode='lines+markers'), row=2, col=2)\n            fig.update_layout( title=f\"Shocktube Data — Step {step_num}\",\n                showlegend=False, height=500, width=800,\n                margin=dict(l=60, r=60, t=60, b=60) )\n\n            # Show with \"notebook\" renderer so repeated calls don't stack new outputs\n            output_area.clear_output(wait=True)\n            fig.show(\"notebook\")\n            \n    # 4) Observe slider changes =&gt; call update_plot\n    slider.observe(update_plot, names='value')\n    # 5) Initial figure\n    update_plot()\n    # 6) Combine play+slider+figure into a single UI\n    controls = widgets.HBox([play, slider])\n    ui = widgets.VBox([controls, output_area])\n\n    return ui\n\n\nshocktube_animation_app(states)"
  },
  {
    "objectID": "tutorials/zingale_write_a_hydrocode.html",
    "href": "tutorials/zingale_write_a_hydrocode.html",
    "title": "How To Write A Hydro Code",
    "section": "",
    "text": "Michael Zingale\nThere are many methods for solving the equations of hydrodynamics. We will make some choices right from the start:\nMuch more in-depth details and derivations are given in my hydro notes available online: https://github.com/Open-Astrophysics-Bookshelf/numerical_exercises\nFor a greater variety of methods, in 2-d, see the pyro code: https://github.com/python-hydro/pyro2 (ref: Harpole et al. JOSS)"
  },
  {
    "objectID": "tutorials/zingale_write_a_hydrocode.html#overview",
    "href": "tutorials/zingale_write_a_hydrocode.html#overview",
    "title": "How To Write A Hydro Code",
    "section": "Overview",
    "text": "Overview\nWe’ll focus on the Euler equations. In 1-d, these are:\n\\[\\begin{align*}\n  \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial (\\rho u)}{\\partial x} & = 0 \\\\\n  \\frac{\\partial (\\rho u)}{\\partial t} + \\frac{\\partial (\\rho u^2 + p)}{\\partial x} &= 0 \\\\\n  \\frac{\\partial (\\rho E)}{\\partial t} + \\frac{\\partial (u(\\rho E + p))}{\\partial x} &= 0 \\\\\n  \\end{align*}\\]\nThis is a set of (hyperbolic) partial differential equations. To close the system, we need an equation of state, relating the specific internal energy, \\(e\\), to the pressure: \\[\n\\begin{align*}\ne &= E - \\frac{1}{2}u^2 \\\\\np &= \\rho e ( \\gamma - 1 ) \\\\\n\\end{align*}\n\\]\nTo solve these, we need to discretize the equations in both space and time. We’ll use grid-based methods (in addition to the finite-volume method we’ll consider, this can include finite-difference and finite-element methods).\nOur system of equations can be expressed in conservative form: \\[ \\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0\\] where \\(U = (\\rho, \\rho u, \\rho E)^\\intercal\\) and \\[\nF(U) = \\left ( \\begin{array}{c} \\rho u \\\\ \\rho u^2 + p \\\\ u (\\rho E + p) \\end{array} \\right )\\]\nIn a finite-volume method, we store the state of the fluid in discrete volumes in space, and we can refer to this discretized state with an index. To see this, we integrate the conservative law system in space over a volume \\([x_{i-1/2},x_{i+1/2}]\\): \\[\\frac{\\partial \\langle U\\rangle_i}{\\partial t} = - \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}\\]\nThis is the form of the equations we will solve. Here, \\(\\langle U\\rangle_i\\) represents the average state of the fluid in a volume: \\[\\langle U\\rangle_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} U(x) dx\\] Visually, we usually think of this grid as:\n\n\n\nFV grid\n\n\nThe state on the grid represents an instance in time. We evolve the state by computing the fluxes through the volumes. These fluxes tell us how much the state changes in each volume over some small timestep, \\(\\Delta t\\).\nOur code will have the following structure:\n\nCreate our numerical grid\nSet the initial conditions\nMain timestep evolution loop\n\nCompute the timestep\nLoop to advance one step (count depends on the number of stages in the integrator)\n\nReconstruct the state to interfaces\nSolve Riemann problem to find the fluxes through the interface\nDo a conservative update of the state to the stage\n\nOutput"
  },
  {
    "objectID": "tutorials/zingale_write_a_hydrocode.html#grid",
    "href": "tutorials/zingale_write_a_hydrocode.html#grid",
    "title": "How To Write A Hydro Code",
    "section": "Grid",
    "text": "Grid\nWe’ll manage our 1-d grid via a class FVGrid. We will divide the domain into a number of zones (or volumes) that will store the state. To implement boundary conditions, we traditionally use ghost cells–extra cells added to each end of the domain. We’ll consider a grid that looks like this:\n\n\n\ngrid w ghostcells\n\n\nWe’ll use the names lo and hi to refer to the first and last zone in our domain. The domain boundaries are the bold lines shown above, and beyond that, on each end, we have ghost cells.\nThe main information we need to setup the grid are the number of zones in the interior and the number of ghost cells.\n\nimport numpy as np\n\nTo make life easier, we’ll have a simple class with indices that we use to index the fluid state arrays. We can pass this around and be sure that we are always accessing the correct fluid state.\n\nclass FluidVars:\n    \"\"\"A simple container that holds the integer indicies we will use to\n    refer to the different fluid components\"\"\"\n    def __init__(self, gamma=1.4, C=0.8):\n        self.nvar = 3\n    \n        # conserved variables\n        self.urho = 0\n        self.umx = 1\n        self.uener = 2\n    \n        # primitive variables\n        self.qrho = 0\n        self.qu = 1\n        self.qp = 2\n    \n        # EOS gamma\n        self.gamma = gamma\n        \n        # CFL number\n        self.C = C\n\nThis is the main class for managing the finite-volume grid. In addition to holding coordinate information and knowing the bounds of the domain, it also can fill the ghost cells and give you a scratch array that lives on the same grid.\n\nclass FVGrid:\n    \"\"\"The main finite-volume grid class for holding our fluid state.\"\"\"\n    \n    def __init__(self, nx, ng, xmin=0.0, xmax=1.0):\n\n        self.xmin = xmin\n        self.xmax = xmax\n        self.ng = ng\n        self.nx = nx\n\n        self.lo = ng\n        self.hi = ng+nx-1\n\n        # physical coords -- cell-centered\n        self.dx = (xmax - xmin)/(nx)\n        self.x = xmin + (np.arange(nx+2*ng)-ng+0.5)*self.dx\n\n    def scratch_array(self, nc=1):\n        \"\"\" return a scratch array dimensioned for our grid \"\"\"\n        return np.squeeze(np.zeros((self.nx+2*self.ng, nc), dtype=np.float64))\n\n    def fill_BCs(self, atmp):\n        \"\"\" fill all ghost cells with zero-gradient boundary conditions \"\"\"\n        if atmp.ndim == 2:\n            for n in range(atmp.shape[-1]):\n                atmp[0:self.lo, n] = atmp[self.lo, n]\n                atmp[self.hi+1:, n] = atmp[self.hi, n]            \n        else:\n            atmp[0:self.lo] = atmp[self.lo]\n            atmp[self.hi+1:] = atmp[self.hi]"
  },
  {
    "objectID": "tutorials/zingale_write_a_hydrocode.html#reconstruction",
    "href": "tutorials/zingale_write_a_hydrocode.html#reconstruction",
    "title": "How To Write A Hydro Code",
    "section": "Reconstruction",
    "text": "Reconstruction\nWe need to use the cell-averages to figure out what the fluid state is on the interfaces. We’ll reconstruct the cell-averages as piecewise lines that give us the same average in the zone. We then follow these lines to the interfaces to define the left and right state at each interface.\nUsually we work in terms of the primitive variables, \\(q = (\\rho, u, p)\\). So we first write a routine to do the algebraic transformation from conservative to primitive variables: \\[\n\\begin{align}\n\\rho &= \\rho \\\\\nu &= \\frac{(\\rho u)}{\\rho} \\\\\np &= \\left ( (\\rho E) - \\frac{1}{2} \\frac{(\\rho u)^2}{\\rho}\\right )(\\gamma - 1)\n\\end{align}\n\\]\n\ndef cons_to_prim(grid, U):\n    \"\"\"take a conservative state U and return the corresponding primitive\n    variable state as a new array.\"\"\"\n    v = FluidVars()\n    q = grid.scratch_array(nc=v.nvar)\n\n    q[:, v.qrho] = U[:, v.urho]\n    q[:, v.qu] = U[:, v.umx]/U[:, v.urho]\n    rhoe = U[:, v.uener] - 0.5*q[:, v.qrho]*q[:, v.qu]**2\n    q[:, v.qp] = rhoe*(v.gamma - 1.0)\n    return q\n\nNext we need a routine to create the interface states. Here’s well construct a slope for each zone, \\(\\Delta q\\) based on the average state in the neighboring zones. This gives us a line representing the value of the fluid state as a function of position in each zone: \\[q_i(x) = \\langle q\\rangle_i + \\frac{\\Delta q_i}{\\Delta x} (x - x_i)\\]\nNote that there is a unique \\(q_i(x)\\) for each zone—this is usually called piecewise linear reconstruction. By design, the average of \\(q_i(x)\\) over the zone is the cell-average, so it is conservative.\nWe use this equation for a line to find the fluid state right at the interface. For zone \\(i\\), the line \\(q_i(x)\\) gives you the right state on the left interface, \\(q_{i-1/2,R}\\), and the left state on the right interface, \\(q_{i+1/2,L}\\). Visually this looks like:\n\n\n\nfinding interface states\n\n\nThere’s one additional wrinkle—2nd order codes tend to produce oscillations near discontinuities, so we usually need to limit the slopes, \\(\\Delta q_i\\), so we don’t introduce new minima or maxima in the evolution. We’ll use the minmod limiter: \\[\n\\begin{equation}                                                                                                         \n\\left . \\frac{\\partial a}{\\partial x} \\right |_i = \\mathtt{minmod} \\left (                                               \n  \\frac{a_i - a_{i-1}}{\\Delta x}, \\frac{a_{i+1} - a_i}{\\Delta x} \\right )                                                \n\\end{equation}\n\\] with \\[\n\\begin{equation}                                                                                                         \n\\mathtt{minmod}(a,b) = \\left \\{                                                                                          \n    \\begin{array}{ll}                                                                                                    \n    a & \\mathit{if~} |a| &lt; |b| \\mathrm{~and~} a\\cdot b &gt; 0 \\\\                                                            \n    b & \\mathit{if~} |b| &lt; |a| \\mathrm{~and~} a\\cdot b &gt; 0 \\\\                                                            \n    0 & \\mathit{otherwise}                                                                                               \n    \\end{array}                                                                                                          \n  \\right .                                                                                                               \n\\end{equation}  \n\\]\n\ndef states(grid, U):\n    v = FluidVars()\n    q = cons_to_prim(grid, U)\n\n    # construct the slopes\n    dq = grid.scratch_array(nc=v.nvar)\n\n    for n in range(v.nvar):        \n        dl = grid.scratch_array()\n        dr = grid.scratch_array()\n\n        dl[grid.lo-1:grid.hi+2] = q[grid.lo:grid.hi+3,n] - q[grid.lo-1:grid.hi+2,n]\n        dr[grid.lo-1:grid.hi+2] = q[grid.lo-1:grid.hi+2,n] - q[grid.lo-2:grid.hi+1,n]\n\n        # these where's do a minmod()\n        d1 = np.where(np.fabs(dl) &lt; np.fabs(dr), dl, dr)\n        dq[:, n] = np.where(dl*dr &gt; 0.0, d1, 0.0)\n\n    # now make the states\n    q_l = grid.scratch_array(nc=v.nvar)\n    q_l[grid.lo:grid.hi+2, :] = q[grid.lo-1:grid.hi+1, :] + 0.5*dq[grid.lo-1:grid.hi+1, :]\n\n    q_r = grid.scratch_array(nc=v.nvar)\n    q_r[grid.lo:grid.hi+2, :] = q[grid.lo:grid.hi+2, :] - 0.5*dq[grid.lo:grid.hi+2, :]\n    \n    return q_l, q_r"
  },
  {
    "objectID": "tutorials/zingale_write_a_hydrocode.html#riemann-problem-and-conservative-update",
    "href": "tutorials/zingale_write_a_hydrocode.html#riemann-problem-and-conservative-update",
    "title": "How To Write A Hydro Code",
    "section": "Riemann problem and conservative update",
    "text": "Riemann problem and conservative update\nAfter doing our reconstruction, we are left with a left and right state on an interface. To find the unique fluid state on the interface, we solve a Riemann problem, \\[q_{i+1/2} = \\mathcal{R}(q_{i+1/2,L},q_{i+1/2,R})\\]\nWe could spend an entire day talking about how to solve the Riemann problem. Well just summarize things here.\nAt each interface, we have a left and right state. Information about the jump across this interface will be carried away from the interface by the 3 hydrodynamic waves (\\(u\\) and \\(u\\pm c\\)).\n The solution to the Riemann problem that we need is the state on the interface–with that we can evaluate the flux through the interface.\nTo solve the Riemann problem, we need to know how much each variable changes across each of the three waves. To complicate matters, the left and right waves can be either shocks or rarefactions. The middle wave (\\(u\\)) is always a contact discontinuity (and of our primitive variables, only \\(\\rho\\) jumps across it).\nFor a gamma-law gas, we can write down analytic expressions for the change in the primitive variables across both a rarefaction and shock. We can then solve these to find the state inbetween the left and right waves (the star state) and then compute the wave speeds.\nFinally, we can find the solution on the interface by determining which region we are in.\n\nWe’ll use an exact Riemann solver to find the solution on the interface. There a lot of algebra involved in finding the expressions for the jumps across the waves and the wave speeds, which we’ll skip (by see my notes). Instead we’ll just use this solver to give us the state.\nOne we have the interface state, we can compute the fluxes using this state:\n\ndef cons_flux(state, v):\n    \"\"\" given an interface state, return the conservative flux\"\"\"\n    flux = np.zeros((v.nvar), dtype=np.float64)\n\n    flux[v.urho] = state.rho * state.u\n    flux[v.umx] = flux[v.urho] * state.u + state.p\n    flux[v.uener] = (0.5 * state.rho * state.u**2 +\n                     state.p/(v.gamma - 1.0) + state.p) * state.u\n    return flux\n\n\nimport riemann_exact as re\nhelp(re)\n\nHelp on module riemann_exact:\n\nNAME\n    riemann_exact\n\nDESCRIPTION\n    An exact Riemann solver for the Euler equations with a gamma-law\n    gas.  The left and right states are stored as State objects.  We then\n    create a RiemannProblem object with the left and right state:\n    \n    &gt; rp = RiemannProblem(left_state, right_state)\n    \n    Next we solve for the star state:\n    \n    &gt; rp.find_star_state()\n    \n    Finally, we sample the solution to find the interface state, which\n    is returned as a State object:\n    \n    &gt; q_int = rp.sample_solution()\n\nCLASSES\n    builtins.object\n        RiemannProblem\n        State\n    \n    class RiemannProblem(builtins.object)\n     |  RiemannProblem(left_state, right_state, gamma=1.4)\n     |  \n     |  a class to define a Riemann problem.  It takes a left\n     |  and right state.  Note: we assume a constant gamma\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, left_state, right_state, gamma=1.4)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  find_star_state(self, p_min=0.001, p_max=1000.0)\n     |      root find the Hugoniot curve to find ustar, pstar\n     |  \n     |  rarefaction_solution(self, sgn, state)\n     |      return the interface solution considering a rarefaction wave\n     |  \n     |  sample_solution(self)\n     |      given the star state (ustar, pstar), find the state on the interface\n     |  \n     |  shock_solution(self, sgn, state)\n     |      return the interface solution considering a shock\n     |  \n     |  u_hugoniot(self, p, side)\n     |      define the Hugoniot curve, u(p).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables\n     |  \n     |  __weakref__\n     |      list of weak references to the object\n    \n    class State(builtins.object)\n     |  State(p=1.0, u=0.0, rho=1.0)\n     |  \n     |  a simple object to hold a primitive variable state\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, p=1.0, u=0.0, rho=1.0)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __str__(self)\n     |      Return str(self).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables\n     |  \n     |  __weakref__\n     |      list of weak references to the object\n\nFUNCTIONS\n    cons_flux(state, v)\n        given an interface state, return the conservative flux\n\nFILE\n    /Users/tabel/Library/Mobile Documents/com~apple~CloudDocs/Teaching/360/tutorials/riemann_exact.py\n\n\n\n\nFor a method-of-lines approach, we want to just compute the righthand side, \\(A = -\\partial F/\\partial x\\). Then we will turn our PDE into an ODE for time: \\[\\frac{\\partial \\langle U\\rangle_i}{\\partial t} = -A_i = - \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}\\]\nWe can then use any ODE integration method, like Runge-Kutta to solve the system.\nThis routine will take the conserved state, \\(U\\), construct the left and right states at all interfaces, solve the Riemann problem to get the unique state on the boundary, and then compute the advective term and return it.\n\ndef make_flux_divergence(grid, U):\n    \n    v = FluidVars()\n    \n    # get the states\n    q_l, q_r = states(grid, U)\n\n    # now solve the Riemann problem\n    flux = grid.scratch_array(nc=v.nvar)\n    for i in range(grid.lo, grid.hi+2):\n        sl = re.State(rho=q_l[i,v.qrho], u=q_l[i,v.qu], p=q_l[i,v.qp])\n        sr = re.State(rho=q_r[i,v.qrho], u=q_r[i,v.qu], p=q_r[i,v.qp])\n        rp = re.RiemannProblem(sl, sr, gamma=v.gamma)\n        rp.find_star_state()\n        q_int = rp.sample_solution()\n        flux[i, :] = cons_flux(q_int, v)\n\n    A = grid.scratch_array(nc=v.nvar)\n    for n in range(v.nvar):\n        A[grid.lo:grid.hi+1, n] = (flux[grid.lo:grid.hi+1, n] -\n                                   flux[grid.lo+1:grid.hi+2, n])/grid.dx\n\n    return A"
  },
  {
    "objectID": "tutorials/zingale_write_a_hydrocode.html#timestep",
    "href": "tutorials/zingale_write_a_hydrocode.html#timestep",
    "title": "How To Write A Hydro Code",
    "section": "Timestep",
    "text": "Timestep\nExplicit hydro codes have a restriction on the size of the timestep. We cannot allow information to move more than one zone per step. For the hydro equations, the speeds at which information travels are \\(u\\) and \\(u \\pm c\\), so we use the largest speed here to compute the timestep.\n\ndef timestep(grid, U):\n\n    v = FluidVars()\n    \n    # compute the sound speed\n    q = cons_to_prim(grid, U)\n    c = grid.scratch_array()\n    c[grid.lo:grid.hi+1] = np.sqrt(v.gamma *\n                                   q[grid.lo:grid.hi+1,v.qp] /\n                                   q[grid.lo:grid.hi+1,v.qrho])\n\n    dt = v.C * grid.dx / (np.abs(q[grid.lo:grid.hi+1, v.qu]) +\n                          c[grid.lo:grid.hi+1]).max()\n    return dt"
  },
  {
    "objectID": "tutorials/zingale_write_a_hydrocode.html#main-driver",
    "href": "tutorials/zingale_write_a_hydrocode.html#main-driver",
    "title": "How To Write A Hydro Code",
    "section": "Main driver",
    "text": "Main driver\nThis is the main driver. For simplicity, I’ve hardcoded the initial conditions here for the standard Sod problem. Usually those would be a separate routine.\nThis does 2nd-order RK (or Euler’s method) for the integration, and requires that we compute the advection terms twice to advance the solution by \\(\\Delta t\\). The update looks like: \\[\n\\begin{align*}\nU^\\star &= U^n + \\frac{\\Delta t}{2} A(U^n) \\\\\nU^{n+1} &= U^n + \\Delta t A(U^\\star)\n\\end{align*}\n\\]\n\ndef mol_solve(nx, tmax=1.0, init_cond=None):\n    \"\"\"Perform 2nd order MOL integration of the Euler equations.\n    You need to pass in a function foo(grid) that returns the \n    initial conserved fluid state.\"\"\"\n\n    grid = FVGrid(nx, 2)\n    v = FluidVars()\n    \n    U = init_cond(grid)\n    \n    t = 0.0\n    \n    while t &lt; tmax:\n        dt = timestep(grid, U)\n        if t + dt &gt; tmax:\n            dt = tmax - t\n\n        grid.fill_BCs(U)\n        k1 = make_flux_divergence(grid, U)\n\n        U_tmp = grid.scratch_array(nc=v.nvar)\n        for n in range(v.nvar):\n            U_tmp[:, n] = U[:, n] + 0.5 * dt * k1[:, n]\n\n        grid.fill_BCs(U_tmp)\n        k2 = make_flux_divergence(grid, U_tmp)\n\n        for n in range(v.nvar):\n            U[:, n] += dt * k2[:, n]\n\n        t += dt\n\n    return grid, U"
  },
  {
    "objectID": "tutorials/zingale_write_a_hydrocode.html#example-sods-problem",
    "href": "tutorials/zingale_write_a_hydrocode.html#example-sods-problem",
    "title": "How To Write A Hydro Code",
    "section": "Example: Sod’s problem",
    "text": "Example: Sod’s problem\nThe Sod problem is a standard test problem, consisting of a left and right state separated by an initial discontinuity. As time evolves, a rightward moving shock and contact and leftward moving rarefaction form.\nOne reason this problem is so popular is that you can find the exact solution (it’s just the Riemann problem) and compare the performance of your code to the exact solution.\n\ndef sod(grid):\n    \n    v = FluidVars()\n    U = grid.scratch_array(nc=v.nvar)\n    \n    # setup initial conditions -- this is Sod's problem\n    rho_l = 1.0\n    u_l = 0.0\n    p_l = 1.0\n    rho_r = 0.125\n    u_r = 0.0\n    p_r = 0.1\n\n    idx_l = grid.x &lt; 0.5\n    idx_r = grid.x &gt;= 0.5\n\n    U[idx_l, v.urho] = rho_l\n    U[idx_l, v.umx] =  rho_l * u_l\n    U[idx_l, v.uener] = p_l/(v.gamma - 1.0) + 0.5 * rho_l * u_l**2\n\n    U[idx_r, v.urho] = rho_r\n    U[idx_r, v.umx] =  rho_r * u_r\n    U[idx_r, v.uener] = p_r/(v.gamma - 1.0) + 0.5 * rho_r * u_r**2\n    \n    return U\n\n\ng, U = mol_solve(128, tmax=0.2, init_cond=sod)\n\n\nimport matplotlib.pyplot as plt\nplt.rcParams['figure.dpi'] = 100\nplt.rcParams['figure.figsize'] = [8, 6]\n\n\nsod = np.genfromtxt(\"sod-exact.out\", skip_header=2, names=True)\n\n\nv = FluidVars()\nplt.scatter(g.x, U[:,v.urho], marker=\"x\", color=\"C0\")\nplt.plot(sod[\"x\"], sod[\"rho\"], color=\"C1\")"
  },
  {
    "objectID": "tutorials/zingale_write_a_hydrocode.html#exercises",
    "href": "tutorials/zingale_write_a_hydrocode.html#exercises",
    "title": "How To Write A Hydro Code",
    "section": "Exercises",
    "text": "Exercises\n\nRun the problem without limiting the slopes to see how it compares\nTry a higher-order Runge-Kutta time integration methods to see how the problem changes\nImplement periodic boundary conditions and create a new set of initial conditions that just puts a low amplitude Gaussian pulse—this will create an acoustic wave that propagates through the domain."
  },
  {
    "objectID": "tutorials/python_setup.html",
    "href": "tutorials/python_setup.html",
    "title": "Setting Up a Python Virtual Environment",
    "section": "",
    "text": "For this class, we will use a dedicated Python virtual environment with Python version 3.10. A virtual environment is an isolated space where you can manage dependencies specific to a project, without interfering with other Python installations on your system. Follow these steps to set up the environment:\n\n\nFirst, check if Python 3.10 is installed on your system. Open a terminal or command prompt and run:\npython3.10 --version\nIf this returns something like Python 3.10.x, you’re good to go. If Python 3.10 is not installed, you can download it from the official Python website or use your system’s package manager to install it.\n\n\n\nNavigate to a directory where you’d like to store your virtual environment. If you already have a class folder called 360 you may change into it and execute the commands below:\nThen run:\npython3.10 -m venv myenv\nThis command creates a new virtual environment named myenv in the current directory. Replace myenv with a name of your choice if desired.\n\n\n\nTo activate the virtual environment: - On Linux/macOS:\nsource myenv/bin/activate\n\nOn Windows:\n\nmyenv\\Scripts\\activate\nAfter activation, your terminal prompt will change to indicate that the virtual environment is active. All Python packages installed while the virtual environment is active will be isolated from your global Python installation.\n\n\n\nWith the virtual environment activated, you can now install the required Python packages for this class. Use pip to install packages:\npip install numpy matplotlib scipy gala jax taichi plotly\n\n\n\nWhen you’re done working in the virtual environment, deactivate it by running:\ndeactivate\nThis will return your terminal to its normal state.\n\n\n\n\n\nAlways activate the virtual environment before running scripts for this class to ensure the correct Python version and dependencies are used.\nIf you ever need to delete the virtual environment, simply remove the myenv directory.\n\nThis process ensures an organized and isolated Python development environment, making it easier to manage dependencies for your coursework."
  },
  {
    "objectID": "tutorials/python_setup.html#setting-up-a-python-3.10-virtual-environment",
    "href": "tutorials/python_setup.html#setting-up-a-python-3.10-virtual-environment",
    "title": "Setting Up a Python Virtual Environment",
    "section": "",
    "text": "For this class, we will use a dedicated Python virtual environment with Python version 3.10. A virtual environment is an isolated space where you can manage dependencies specific to a project, without interfering with other Python installations on your system. Follow these steps to set up the environment:\n\n\nFirst, check if Python 3.10 is installed on your system. Open a terminal or command prompt and run:\npython3.10 --version\nIf this returns something like Python 3.10.x, you’re good to go. If Python 3.10 is not installed, you can download it from the official Python website or use your system’s package manager to install it.\n\n\n\nNavigate to a directory where you’d like to store your virtual environment. If you already have a class folder called 360 you may change into it and execute the commands below:\nThen run:\npython3.10 -m venv myenv\nThis command creates a new virtual environment named myenv in the current directory. Replace myenv with a name of your choice if desired.\n\n\n\nTo activate the virtual environment: - On Linux/macOS:\nsource myenv/bin/activate\n\nOn Windows:\n\nmyenv\\Scripts\\activate\nAfter activation, your terminal prompt will change to indicate that the virtual environment is active. All Python packages installed while the virtual environment is active will be isolated from your global Python installation.\n\n\n\nWith the virtual environment activated, you can now install the required Python packages for this class. Use pip to install packages:\npip install numpy matplotlib scipy gala jax taichi plotly\n\n\n\nWhen you’re done working in the virtual environment, deactivate it by running:\ndeactivate\nThis will return your terminal to its normal state.\n\n\n\n\n\nAlways activate the virtual environment before running scripts for this class to ensure the correct Python version and dependencies are used.\nIf you ever need to delete the virtual environment, simply remove the myenv directory.\n\nThis process ensures an organized and isolated Python development environment, making it easier to manage dependencies for your coursework."
  },
  {
    "objectID": "lectures/gravity.html",
    "href": "lectures/gravity.html",
    "title": "Gravity",
    "section": "",
    "text": "Explore Newtonian Gravity via fores, potentials, and least action principle.\nCover some commonly used spherical distributions\nExplore stellar dynamics ins more realistic (yet static) potentials using gala package.\nLearn key principles of numerical methods used in gravitational dynamics"
  },
  {
    "objectID": "lectures/gravity.html#newtonian-gravity-3-ways",
    "href": "lectures/gravity.html#newtonian-gravity-3-ways",
    "title": "Gravity",
    "section": "Newtonian Gravity 3 Ways",
    "text": "Newtonian Gravity 3 Ways\n\n Newtonian gravity can be understood from three complementary perspectives, each providing unique insights into the nature of gravitational interactions. In the following sections, we will explore these perspectives: Forces, where we consider how gravitational acceleration arises directly from pairwise interactions or a continuous mass distribution; Potentials, where we describe the gravitational field as a scalar potential that satisfies Poisson’s equation and links mass to field strength; and Action, where the motion of self-gravitating systems is derived from a variational principle. Together, these approaches offer a comprehensive view of the dynamics governed by Newtonian gravity. If it has been a while you may appreciate (re-)watch Feynman’s Messenger lectures on these topics. At the very least they may help to motivate further study.\n\nFor gravity the 4th way please sign up for the General Relativity course physics PHYSICS 262: General Relativity\n\nForces\nIn Newton’s theory the acceleration of a particle is the sum over all other particles of \\(G\\) times the mass times the inverse square of the distance.\n\\[\n\\ddot{\\mathbf{x}}_j=\\sum_{i \\neq j} \\frac{G m_i\\left(\\mathbf{x}_i-\\mathbf{x}_j\\right)}{\\left|\\mathbf{x}_i-\\mathbf{x}_j\\right|^3}\n\\]\nwhere\n\\[\nG \\simeq 6.67 \\times 10^{-8} \\mathrm{~cm}^3 \\mathrm{~g}^{-1} \\mathrm{~s}^{-2}\n\\]\nFor a continuous density distribution this is\n\\[\n\\ddot{\\mathbf{x}}=\\mathbf{g}(\\mathbf{x})=G \\int d^3 x^{\\prime} \\rho\\left(\\mathbf{x}^{\\prime}\\right) \\frac{\\left(\\mathbf{x}^{\\prime}-\\mathbf{x}\\right)}{\\left|\\mathbf{x}^{\\prime}-\\mathbf{x}\\right|^3}\n\\]\n\n\nPotentials\nThe gravitational acceleration \\(\\mathbf{g}\\) can be written as the negative of the gradient of the gravitational potential \\(\\mathbf{g}=-\\nabla \\Phi\\) where\n\\[\n\\Phi(\\mathbf{x})=-G \\int d^3 x^{\\prime} \\frac{\\rho\\left(\\mathbf{x}^{\\prime}\\right)}{\\left|\\mathbf{x}^{\\prime}-\\mathbf{x}\\right|}\n\\]\nTaking the gradient of \\(\\Phi(\\mathbf{x})\\) one recovers In addition to the explicit formula for the potential as an spatial integral (25.4) there is also an equivalent local relationship between the Laplacian of the potential \\(\\nabla^2 \\Phi\\) and the density \\(\\rho\\)\n\\[\n\\nabla^2 \\Phi=4 \\pi G \\rho\n\\tag{1}\\]\nwhich is Poisson’s equation.\nIf we divide by \\(4 \\pi G\\) and integrate both sides of equation (Equation 1) over an arbitrary volume \\(V\\), and then apply the divergence theorem, we obtain\n\\[\nM = \\int_{V} \\mathrm{~d}^3 \\mathbf{x} \\rho= \\frac{1}{4 \\pi G} \\int_{V} \\mathrm{d}^3 \\mathbf{x} \\nabla^2 \\Phi =\n\\frac{1}{4 \\pi G} \\oint_{\\partial V} \\mathrm{d}^2 \\mathbf{S} \\cdot \\boldsymbol{\\nabla} \\Phi\n\\]\nThis is Gauss’s theorem and says that the integral of the normal component of \\(\\nabla \\Phi\\) over any closed surface, \\(\\partial V\\), divided by \\(4 \\pi G\\) equals the mass contained within that surface. This says average accelerations on the surface are only directly related to the mass contained inside it.\n\n\nAction for N Self-Gravitating Bodies\nThe action for \\(N\\) self-gravitating bodies is the starting point for deriving their equations of motion using the variational principle. In classical mechanics, the action is expressed as the time integral of the Lagrangian. For self-gravitating bodies, the Lagrangian has two components: the kinetic energy of the particles and the gravitational potential energy between them.\n\nGeneral Form of the Action\nThe action \\(S\\) for \\(N\\) self-gravitating bodies is:\n\\[\nS = \\int \\mathcal{L} \\, \\mathrm{d}t,\n\\]\nwhere the Lagrangian \\(\\mathcal{L}\\) is given by:\n\\[\n\\mathcal{L} = T - U.\n\\]\nHere:\n\n\\(T\\) is the total kinetic energy of the system.\n\\(U\\) is the total gravitational potential energy of the system.\n\n\nKinetic Energy\nThe kinetic energy is:\n\\[\nT = \\frac{1}{2} \\sum_{i=1}^N m_i \\|\\dot{\\mathbf{r}}_i\\|^2,\n\\]\nwhere:\n\n\\(m_i\\) is the mass of the \\(i\\)-th particle.\n\\(\\dot{\\mathbf{r}}_i = \\frac{\\mathrm{d}\\mathbf{r}_i}{\\mathrm{d}t}\\) is the velocity of the \\(i\\)-th particle.\n\n\n\nGravitational Potential Energy\nThe gravitational potential energy is:\n\\[\nU = - \\frac{1}{2} \\sum_{i=1}^N \\sum_{j \\neq i}^N \\frac{G m_i m_j}{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|},\n\\]\nwhere:\n\n\\(G\\) is the gravitational constant.\n\n\\(\\|\\mathbf{r}_i - \\mathbf{r}_j\\|\\) is the Euclidean distance between the \\(i\\)-th and \\(j\\)-th particles.\n\nThe factor \\(\\frac{1}{2}\\) accounts for double-counting each pair of interactions.\n\n\n\nFull Expression for the Action\nSubstituting the kinetic and potential energy terms, the action becomes:\n\\[\nS = \\int \\left( \\frac{1}{2} \\sum_{i=1}^N m_i \\|\\dot{\\mathbf{r}}_i\\|^2 + \\frac{1}{2} \\sum_{i=1}^N \\sum_{j \\neq i}^N \\frac{G m_i m_j}{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|} \\right) \\mathrm{d}t.\n\\]\nThis action governs the dynamics of \\(N\\) self-gravitating bodies under Newtonian gravity.\n\n\nDeriving Equations of Motion\nTo find the equations of motion, apply the principle of stationary action:\n\\[\n\\delta S = 0.\n\\]\nVarying \\(S\\) with respect to \\(\\mathbf{r}_i\\) leads to the Euler-Lagrange equations:\n\\[\nm_i \\ddot{\\mathbf{r}}_i = -\\sum_{j \\neq i}^N \\frac{G m_i m_j}{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|^3} (\\mathbf{r}_i - \\mathbf{r}_j).\n\\]\nThis is Newton’s second law for the \\(i\\)-th particle in the gravitational field created by the other particles."
  },
  {
    "objectID": "lectures/gravity.html#spherical-systems",
    "href": "lectures/gravity.html#spherical-systems",
    "title": "Gravity",
    "section": "25.3 Spherical Systems",
    "text": "25.3 Spherical Systems\n\n25.3.1 Newton’s Theorems\nNewton found that\n\n\\(\\mathbf{g}=0\\) inside a spherical shell of mass.\nThe gravity outside such a shell is the same as for an equivalent mass at the origin.\n\nThese can be proved geometrically (see Binney and Tremaine (2008)), and they also follow directly from Gauss’ law and spherical symmetry.\nThese theorems imply that the gravity \\(\\mathbf{g}(\\mathbf{r})\\) for an arbitrary spherical system with cumulative mass profile \\(M(r)\\) is\n\\[\n\\mathbf{g}=-\\frac{G M(r)}{r^2} \\hat{\\mathbf{r}}\n\\]\n\n\n25.3.2 Circular and Escape Speed\nThe speed of a particle on a circular orbit satisfies\n\\[\n\\frac{d v}{d t}=\\frac{v^2}{r}=\\frac{G M(r)}{r^2} \\quad \\rightarrow \\quad v_{\\mathrm{circ}}=\\sqrt{G M(r) / r}\n\\]\nThe escape speed is\n\\[\nv_{\\mathrm{esc}}=\\sqrt{2 \\Phi(r)}\n\\]\nwhere \\(\\Phi\\) is measured relative to its value at spatial infinity.\n\n\n25.3.3 Point Mass\nFor a point mass \\(M(r)=m\\):\n\nThe potential is \\(\\Phi=-G m / r\\).\nThe circular velocity is \\(v_{\\text {circ }}=\\sqrt{G m / r}\\).\nThe escape velocity is \\(v_{\\text {esc }}=\\sqrt{2} v_{\\text {circ }}\\).\nThe \\(v_{\\text {circ }} \\propto r^{-1 / 2}\\) circular speed profile is usually referred to as a Keplerian profile.\n\n\n\n25.3.3 Uniform Density Sphere\nFor a static uniform sphere of density \\(\\rho\\) - The gravity is\n\\[\ng=\\frac{G M(r)}{r^2}=\\frac{4 \\pi}{3} G \\rho r .\n\\]\n\nThe circular speed is\n\n\\[\nv_{\\mathrm{circ}}=\\sqrt{\\frac{4 \\pi G \\rho}{3}} r\n\\]\n\nThe orbital period is\n\n\\[\nt_{\\text {orbit }}=\\frac{2 \\pi r}{v_{\\text {circ }}}=\\sqrt{\\frac{3 \\pi}{G \\rho}}\n\\]\nwhich is independent of the radius of the orbit. - The potential, measured with respect to the origin, is a parabola and the equation of motion for test particles within the sphere is\n\\[\n\\ddot{\\mathbf{r}}=-\\frac{4 \\pi G \\rho}{3} \\mathbf{r}\n\\]\nThe period of any orbit in this potential is the same as that for a circular orbit.\n\nThe dynamical time scales corresponding to density \\(\\rho\\) have various definitions and you will find orbital time, the collapse time, the free fall time etc.. These are always on the order of \\(t_{\\mathrm{dyn}}=1 / \\sqrt{G \\rho}\\).\n\nThis is the gravitational spherical harmonic oscillator. No phase mixing occurs in such a potential. Nearby particles stay nearby.\n\n\nPower Law Density Profile\nA power law density profile \\(\\rho(r)=\\rho_0\\left(r / r_0\\right)^{-\\alpha}\\) has - Mass \\(M(r) \\propto r^{3-\\alpha}\\). - We need \\(\\alpha&lt;3\\) if the mass at the origin is to be finite. - The density cusp at the origin can be ‘softened’ as in the NFW models. - A flat rotation curve results for \\(\\alpha=2\\) and is referred to as a singular isothermal sphere profile.\n\n\nHernquist and NFW Models\nMass condensations that grow in cosmological simulations have been found to be quite well described by double power-law models.\nThe Navarro, Frenk, and White (1996) (NFW) model is\n\\[\n\\rho(r) \\propto \\frac{1}{r\\left(r^2+r_c^2\\right)}\n\\]\nwhich has asymptotic forms\n\\[\n\\rho \\propto\\left\\{\\begin{array}{l}\nr^{-1} \\\\\nr^{-3}\n\\end{array}\\right\\} \\quad \\text { for } \\quad\\left\\{\\begin{array}{l}\nr \\ll r_c \\\\\nr \\gg r_c\n\\end{array}\\right.\n\\]"
  },
  {
    "objectID": "lectures/gravity.html#the-virial-theorem",
    "href": "lectures/gravity.html#the-virial-theorem",
    "title": "Gravity",
    "section": "26.3 The Virial Theorem",
    "text": "26.3 The Virial Theorem\nConsider the moment of inertia of a system of point masses \\(I \\equiv \\sum m r^2\\). The time derivative is \\(\\dot{I}=2 \\sum m \\mathbf{r} \\cdot \\dot{\\mathbf{r}}\\) and taking a further time derivative gives\n\\[\n\\frac{1}{2} \\ddot{I}=\\sum m \\dot{r}^2+\\sum m \\mathbf{r} \\cdot \\ddot{\\mathbf{r}}\n\\]\nRequiring that \\(\\ddot{I}\\) vanish for a stable system and expressing the acceleration \\(\\ddot{\\mathbf{r}}\\) as a sum of the gravity from all the other particles gives\n\\[\n2 T+\\sum_{\\mathbf{r}} m \\mathbf{r} \\cdot \\sum_{\\mathbf{r}^{\\prime} \\neq \\mathbf{r}} G m^{\\prime} \\frac{\\mathbf{r}^{\\prime}-\\mathbf{r}}{\\left|\\mathbf{r}^{\\prime}-\\mathbf{r}\\right|^3}=0\n\\]\nwith \\(T\\) the kinetic energy of the particles. Now switching \\(\\mathbf{r} \\leftrightarrow \\mathbf{r}^{\\prime}\\) in the last term simply changes the sign, so we can write this as\n\\[\n\\begin{gathered}\n\\sum_{\\mathbf{r}} \\sum_{\\mathbf{r}^{\\prime} \\neq \\mathbf{r}} G m m^{\\prime} \\mathbf{r} \\cdot \\frac{\\mathbf{r}^{\\prime}-\\mathbf{r}}{\\left|\\mathbf{r}^{\\prime}-\\mathbf{r}\\right|^3} \\\\\n=\\frac{1}{2}\\left[\\sum_{\\mathbf{r}} \\sum_{\\mathbf{r}^{\\prime} \\neq \\mathbf{r}} G m m^{\\prime} \\mathbf{r} \\cdot \\frac{\\mathbf{r}^{\\prime}-\\mathbf{r}}{\\left|\\mathbf{r}^{\\prime}-\\mathbf{r}\\right|^3}-\\sum_{\\mathbf{r}} \\sum_{\\mathbf{r}^{\\prime} \\neq \\mathbf{r}} G m m^{\\prime} \\mathbf{r}^{\\prime} \\cdot \\frac{\\mathbf{r}^{\\prime}-\\mathbf{r}}{\\left|\\mathbf{r}^{\\prime}-\\mathbf{r}\\right|^3}\\right] \\\\\n=-\\frac{1}{2} \\sum_{\\mathbf{r}} \\sum_{\\mathbf{r}^{\\prime} \\neq \\mathbf{r}} \\frac{G m m^{\\prime}}{\\left|\\mathbf{r}^{\\prime}-\\mathbf{r}\\right|}=W\n\\end{gathered}\n\\]\nand we therefore have the virial theorem\n\\[\n2 T+W=0\n\\]\nThe virial theorem provides a useful way to estimate the mass of bound systems. For example, if we assume equal mass particles, then the particle mass \\(m\\) is given by\n\\[\nm=\\frac{2}{G} \\frac{\\sum \\dot{r}^2}{\\sum_{\\text {pairs }} 1 / r_{12}}\n\\]\nFor a roughly spherical system it is reasonable to assume that the 3-dimensional velocity dispersion in the numerator is 3 times the observed line of sight velocity dispersion. Similarly, the mean harmonic radius which appears in the denominator can be estimated from the observed distribution of projected separations, and this provides a useful way to determine the mass of a gravitating system.\nThe virial theorem gives the correct answer if the luminous particles trace the mass, but will fail if, for example, the dark matter has a different profile from the luminous particles."
  }
]