[
  {
    "objectID": "final_project/project_ideas.html",
    "href": "final_project/project_ideas.html",
    "title": "Possible Final project topics",
    "section": "",
    "text": "You are very much encouraged to develop your own final project idea and project plan and deliverable. It has to fit inside this arguably very broad topic of “Modern Astrophysics” and should be not exactly what you are already doing for research. However, it is ok if it is adjacent to your research and the final project gives you a chance to explore something you wouldn’t have done without thinking about the tools, physics and methodology we are discussing in this course."
  },
  {
    "objectID": "final_project/project_ideas.html#globular-star-clusters-observations-by-hst-and-jwst",
    "href": "final_project/project_ideas.html#globular-star-clusters-observations-by-hst-and-jwst",
    "title": "Possible Final project topics",
    "section": "Globular Star Clusters observations by HST and JWST",
    "text": "Globular Star Clusters observations by HST and JWST\n\n\n\n\n\n\nNote\n\n\n\nThis is a signficant project and breaks up into sub tasks. It likely is a good project for a group of students.\n\n\n\n\n\n\nM13 as seen by HST\n\n\n\nHST observations of Globular Clusters in the Milky Way are stunning. We want to build a forward model which uses a library of stellar spectra which we convolve with the correct broad band filters of the specific observations we want to match. We then want to build a forward model which aims to combine our theoretical stars into an image which once the point spread function of HST is applied matches our input data."
  },
  {
    "objectID": "final_project/project_ideas.html#model-galaxy-imagesspectra-from-3d-simulations",
    "href": "final_project/project_ideas.html#model-galaxy-imagesspectra-from-3d-simulations",
    "title": "Possible Final project topics",
    "section": "Model Galaxy images/spectra from 3D Simulations",
    "text": "Model Galaxy images/spectra from 3D Simulations\nWe have access to many different galaxy formation simulations and want to explore to make virtual observations that we can compare directly with real observations. We want to explore what is required to make very fast predictions."
  },
  {
    "objectID": "final_project/project_ideas.html#model-galaxy-imagesspectra",
    "href": "final_project/project_ideas.html#model-galaxy-imagesspectra",
    "title": "Possible Final project topics",
    "section": "Model Galaxy images/spectra",
    "text": "Model Galaxy images/spectra\n\n\n\n\n\n\nNote\n\n\n\nThis is a signficant project and breaks up into sub tasks. It likely is a good project for a group of students.\n\n\n\n\n\n\nGalaxy in Galaxy Zoo 2\n\n\n\nThe image data of Galaxy Zoo 2 (Willett et al. 2019) is available online. This is supplemented by classifications carried out by a large number of volunteers. Leveraging DSPS from Hearin et al. (2023) we want to match all pixel colors."
  },
  {
    "objectID": "final_project/project_ideas.html#model-the-x-ray-emission-of-an-x-ray-cluster",
    "href": "final_project/project_ideas.html#model-the-x-ray-emission-of-an-x-ray-cluster",
    "title": "Possible Final project topics",
    "section": "Model the X-ray emission of an X-ray cluster",
    "text": "Model the X-ray emission of an X-ray cluster\n\n\n\n\nChandra observation of Coma\n\n\n\nThe X-ray emission comes from hot plasma in the galaxy cluster. In this project we want to think through how well we constrain a 3D density and temperature distribution to closely match a specific observation. How does adding spectral/energy information help in ths constraints?"
  },
  {
    "objectID": "final_project/project_ideas.html#radiation-from-a-3d-hii-region",
    "href": "final_project/project_ideas.html#radiation-from-a-3d-hii-region",
    "title": "Possible Final project topics",
    "section": "Radiation from a 3D HII region",
    "text": "Radiation from a 3D HII region"
  },
  {
    "objectID": "final_project/project_ideas.html#radiation-hydro-dynamics-of-a-3d-hii-region",
    "href": "final_project/project_ideas.html#radiation-hydro-dynamics-of-a-3d-hii-region",
    "title": "Possible Final project topics",
    "section": "Radiation Hydro-Dynamics of a 3D HII region",
    "text": "Radiation Hydro-Dynamics of a 3D HII region"
  },
  {
    "objectID": "final_project/project_ideas.html#model-a-dwarf-galaxygc-disruption-in-gala",
    "href": "final_project/project_ideas.html#model-a-dwarf-galaxygc-disruption-in-gala",
    "title": "Possible Final project topics",
    "section": "Model a dwarf galaxy/GC disruption in gala",
    "text": "Model a dwarf galaxy/GC disruption in gala"
  },
  {
    "objectID": "final_project/project_ideas.html#study-the-spitzer-equipartition-instability-in-globular-clusters",
    "href": "final_project/project_ideas.html#study-the-spitzer-equipartition-instability-in-globular-clusters",
    "title": "Possible Final project topics",
    "section": "Study the Spitzer (equipartition) Instability in Globular Clusters",
    "text": "Study the Spitzer (equipartition) Instability in Globular Clusters\nUse our N-body code, write your own, or use a professional one such like rebound to set up initial conditions that illustrate various aspects of Spitzer’s instability. The instability relates to having heavy stars mass segregate towards the center of a star cluster. Once they are more common they tend to dissipate energy to the lowe mass stars in the out parts via two body scattering. This leads the heavy masses to move to smaller radii moving away from equi-partition rather than towards equilibrium. See chapter 7.5.5 of Binney and Tremaine (2008)."
  },
  {
    "objectID": "final_project/project_ideas.html#particle-mesh-codes-in-cosmology",
    "href": "final_project/project_ideas.html#particle-mesh-codes-in-cosmology",
    "title": "Possible Final project topics",
    "section": "Particle-Mesh Codes in Cosmology",
    "text": "Particle-Mesh Codes in Cosmology\nAndrey Kravtsov wrote a wonderful set of instructions on how to approach writing your own particle mesh code specifically for numerical cosmology. There is now a beautifully implemented python version of cosmological PM by Breton (2024), called pysco, which also includes well developed initial conditions generation. I have many example Jupyter notebooks I can share with you also ones related to the Simplex in Cell technique Hahn and Angulo (2016). There are multiple possible projects building on this work. Our own Delon Shen wrote a beautiful set of notes that are even more pedagogical and interactive.\n\nMake pysco use the phase-space sheet\nE.g. you might incorporate the ideas from Abel, Hahn, and Kaehler (2012), Sousbie and Colombi (2016), and Hahn and Angulo (2016) into pysco.\n\n\nExplore the statistics of 3D cosmological density\nYou might first just use fields as computed through the Lagrangian Perturbation theory implemented in pysco, i.e. the initial conditions. Once you have a pipeline to measure the spatial statistics you are interested in - Kymatio implements 1, 2 and 3D wavelet scattering transforms. Follow Cheng et al. (2023) and characterize the scattering coefficients for evolved cosmological density fields. - Measure the PDFs for the density fields for many different smoothing lengths and compare to the predictions given by pyLDT from Cataneo et al. (2021). - Explore kNN-CDFs from Banerjee and Abel (2021)."
  },
  {
    "objectID": "final_project/project_ideas.html#statistical-properties-of-12-and-3d-turbulence",
    "href": "final_project/project_ideas.html#statistical-properties-of-12-and-3d-turbulence",
    "title": "Possible Final project topics",
    "section": "Statistical properties of 1,2 and 3D turbulence",
    "text": "Statistical properties of 1,2 and 3D turbulence\nThe novelty in this project is that we will try to do very high dynamic range estimates of the statistical properties of turbulence by running a set of simulations which we connect in a one way approach. We will start with a 1D model which will help us practice everything we need. If we manage that we can extend it to 2 and 3D. Beattie et al. (2022) study the density PDF in supersonic MHD turbulence. We start by reading this paper to get a sense of the current questions in the field. We will assume as hypothesis that energy cascades only from large scales to samll scales. Hence when we simulate First step then is to use 1D hydro and look at decaying supersonic turbulence."
  },
  {
    "objectID": "final_project/project_ideas.html#numerical-cosmology",
    "href": "final_project/project_ideas.html#numerical-cosmology",
    "title": "Possible Final project topics",
    "section": "Numerical Cosmology",
    "text": "Numerical Cosmology"
  },
  {
    "objectID": "final_project/project_ideas.html#study-lyman-alpha-radiation-transport",
    "href": "final_project/project_ideas.html#study-lyman-alpha-radiation-transport",
    "title": "Possible Final project topics",
    "section": "Study Lyman-\\(\\alpha\\) Radiation Transport",
    "text": "Study Lyman-\\(\\alpha\\) Radiation Transport\nImplement the grid-less monte carlo transfer approach of Smith et al. (2025), reproduce some of their plots and discuss the approach. Stretch goal: Make a differentiable version. Feeding it one of its own solutions can you write a pipeline which recovers all input parameters and (further stretch) error bars on them?"
  },
  {
    "objectID": "final_project/project_ideas.html#very-fast-chemical-reaction-network-solvers-using-neural-nets",
    "href": "final_project/project_ideas.html#very-fast-chemical-reaction-network-solvers-using-neural-nets",
    "title": "Possible Final project topics",
    "section": "Very fast chemical reaction network solvers using neural nets",
    "text": "Very fast chemical reaction network solvers using neural nets"
  },
  {
    "objectID": "final_project/project_ideas.html#fast-non-equilibrium-cooling-functions-high-dimensional-interpolation",
    "href": "final_project/project_ideas.html#fast-non-equilibrium-cooling-functions-high-dimensional-interpolation",
    "title": "Possible Final project topics",
    "section": "Fast non-equilibrium cooling functions: high dimensional interpolation",
    "text": "Fast non-equilibrium cooling functions: high dimensional interpolation"
  },
  {
    "objectID": "final_project/project_ideas.html#differentiable-emission-line-modeling-for-galaxies",
    "href": "final_project/project_ideas.html#differentiable-emission-line-modeling-for-galaxies",
    "title": "Possible Final project topics",
    "section": "Differentiable emission line modeling for galaxies",
    "text": "Differentiable emission line modeling for galaxies"
  },
  {
    "objectID": "final_project/project_ideas.html#differentiable-dust-emission-and-absorption",
    "href": "final_project/project_ideas.html#differentiable-dust-emission-and-absorption",
    "title": "Possible Final project topics",
    "section": "Differentiable Dust emission and absorption",
    "text": "Differentiable Dust emission and absorption"
  },
  {
    "objectID": "website/index.html",
    "href": "website/index.html",
    "title": "Physics 360: Modern Astrophysics",
    "section": "",
    "text": "Instructor: Dr. Tom Abel Email: tabel@stanford.edu\nMeets: Tu Th 1:30-2:50pm in 60-109\nThis website hosts all materials for Physics 360: Modern Astrophysics, including lectures, assignments, final projects, and resources."
  },
  {
    "objectID": "website/index.html#bring-laptop-to-class",
    "href": "website/index.html#bring-laptop-to-class",
    "title": "Physics 360: Modern Astrophysics",
    "section": "Bring laptop to class",
    "text": "Bring laptop to class\nDuring most lectures we will do some coding and/or run some example code I provide. Please bring your laptop. We recommend to create a class specific virtual environment for your local python installation."
  },
  {
    "objectID": "tutorials/Intro_3D_visualization.html",
    "href": "tutorials/Intro_3D_visualization.html",
    "title": "Intro to 3D Visualization in python",
    "section": "",
    "text": "pyvista is your best bet to create informative visualizations of 3D data from within python. Yes, matplotlib and veusz have beautiful 3D plots as well but these are mostly restricted to relatively simple types of visualizations.\nYour best bet to install pyvista maybe\npip install 'jupyterlab&gt;=3' ipywidgets 'pyvista[all,trame]'\nas described at their userguide.\n```{python}\nimport numpy as np\nimport pyvista as pv\nimport ipywidgets as widgets\nimport gala.potential as gp\nimport astropy.units as u\npv.set_jupyter_backend('trame')  # or 'server'\n\nnx, ny, nz = 140, 140, 140\nextent = 60. \nx = np.linspace(-extent, extent, nx)\ny = np.linspace(-extent, extent, ny)\nz = np.linspace(-extent, extent, nz)\nX, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n\n\npotential = gp.MilkyWayPotential()\nrho = potential.density([X, Y, Z] * u.kpc).to_value(u.Msun / u.pc**3) #.reshape(nx, ny, nz)\nr = rho.flatten()\n\ngrid = pv.StructuredGrid(X, Y, Z)\ngrid[\"rho\"] = rho.ravel()\n\nplotter = pv.Plotter(notebook=True,lighting='three lights')\nplotter.enable_shadows()\n\ndef plot_iso(threshold=np.log10(np.percentile(r, 75.))):\n    plotter.clear()\n    iso = grid.contour(isosurfaces=[10**threshold/2,10**threshold,10**threshold*2], scalars='rho')\n    \n    # Compute per-vertex normals\n    iso = iso.compute_normals(cell_normals=False, split_vertices=True, auto_orient_normals=True)\n    \n    # Add the isosurface mesh\n    plotter.add_mesh(\n        iso, opacity=0.3,\n        smooth_shading=False, \n        show_edges=False, cmap=\"plasma\")\n\n    \n    # Eye-dome lighting can help\n#    plotter.enable_eye_dome_lighting()\n\n    # Update the scene in the same cell\n    plotter.show(interactive_update=True)\n\nwidgets.interact(plot_iso, threshold=((np.log10(np.percentile(r, 0.1)), np.log10(np.percentile(r, 99.9)), \n                                    (np.log10(np.percentile(r, 99.9))-np.log10(np.percentile(r, 0.1)))/100)));\n```"
  },
  {
    "objectID": "tutorials/Intro_3D_visualization.html#pyvista",
    "href": "tutorials/Intro_3D_visualization.html#pyvista",
    "title": "Intro to 3D Visualization in python",
    "section": "",
    "text": "pyvista is your best bet to create informative visualizations of 3D data from within python. Yes, matplotlib and veusz have beautiful 3D plots as well but these are mostly restricted to relatively simple types of visualizations.\nYour best bet to install pyvista maybe\npip install 'jupyterlab&gt;=3' ipywidgets 'pyvista[all,trame]'\nas described at their userguide.\n```{python}\nimport numpy as np\nimport pyvista as pv\nimport ipywidgets as widgets\nimport gala.potential as gp\nimport astropy.units as u\npv.set_jupyter_backend('trame')  # or 'server'\n\nnx, ny, nz = 140, 140, 140\nextent = 60. \nx = np.linspace(-extent, extent, nx)\ny = np.linspace(-extent, extent, ny)\nz = np.linspace(-extent, extent, nz)\nX, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n\n\npotential = gp.MilkyWayPotential()\nrho = potential.density([X, Y, Z] * u.kpc).to_value(u.Msun / u.pc**3) #.reshape(nx, ny, nz)\nr = rho.flatten()\n\ngrid = pv.StructuredGrid(X, Y, Z)\ngrid[\"rho\"] = rho.ravel()\n\nplotter = pv.Plotter(notebook=True,lighting='three lights')\nplotter.enable_shadows()\n\ndef plot_iso(threshold=np.log10(np.percentile(r, 75.))):\n    plotter.clear()\n    iso = grid.contour(isosurfaces=[10**threshold/2,10**threshold,10**threshold*2], scalars='rho')\n    \n    # Compute per-vertex normals\n    iso = iso.compute_normals(cell_normals=False, split_vertices=True, auto_orient_normals=True)\n    \n    # Add the isosurface mesh\n    plotter.add_mesh(\n        iso, opacity=0.3,\n        smooth_shading=False, \n        show_edges=False, cmap=\"plasma\")\n\n    \n    # Eye-dome lighting can help\n#    plotter.enable_eye_dome_lighting()\n\n    # Update the scene in the same cell\n    plotter.show(interactive_update=True)\n\nwidgets.interact(plot_iso, threshold=((np.log10(np.percentile(r, 0.1)), np.log10(np.percentile(r, 99.9)), \n                                    (np.log10(np.percentile(r, 99.9))-np.log10(np.percentile(r, 0.1)))/100)));\n```"
  },
  {
    "objectID": "tutorials/python_setup.html",
    "href": "tutorials/python_setup.html",
    "title": "Setting Up a Python Virtual Environment",
    "section": "",
    "text": "For this class, we will use a dedicated Python virtual environment with Python version 3.10. A virtual environment is an isolated space where you can manage dependencies specific to a project, without interfering with other Python installations on your system. Follow these steps to set up the environment:\n\n\nFirst, check if Python 3.10 is installed on your system. Open a terminal or command prompt and run:\npython3.10 --version\nIf this returns something like Python 3.10.x, you’re good to go. If Python 3.10 is not installed, you can download it from the official Python website or use your system’s package manager to install it.\n\n\n\nNavigate to a directory where you’d like to store your virtual environment. If you already have a class folder called 360 you may change into it and execute the commands below:\nThen run:\npython3.10 -m venv myenv\nThis command creates a new virtual environment named myenv in the current directory. Replace myenv with a name of your choice if desired.\n\n\n\nTo activate the virtual environment: - On Linux/macOS:\nsource myenv/bin/activate\n\nOn Windows:\n\nmyenv\\Scripts\\activate\nAfter activation, your terminal prompt will change to indicate that the virtual environment is active. All Python packages installed while the virtual environment is active will be isolated from your global Python installation.\n\n\n\nWith the virtual environment activated, you can now install the required Python packages for this class. Use pip to install packages:\npip install numpy matplotlib scipy gala jax taichi plotly\n\n\n\nWhen you’re done working in the virtual environment, deactivate it by running:\ndeactivate\nThis will return your terminal to its normal state.\n\n\n\n\n\nAlways activate the virtual environment before running scripts for this class to ensure the correct Python version and dependencies are used.\nIf you ever need to delete the virtual environment, simply remove the myenv directory.\n\nThis process ensures an organized and isolated Python development environment, making it easier to manage dependencies for your coursework."
  },
  {
    "objectID": "tutorials/python_setup.html#setting-up-a-python-3.10-virtual-environment",
    "href": "tutorials/python_setup.html#setting-up-a-python-3.10-virtual-environment",
    "title": "Setting Up a Python Virtual Environment",
    "section": "",
    "text": "For this class, we will use a dedicated Python virtual environment with Python version 3.10. A virtual environment is an isolated space where you can manage dependencies specific to a project, without interfering with other Python installations on your system. Follow these steps to set up the environment:\n\n\nFirst, check if Python 3.10 is installed on your system. Open a terminal or command prompt and run:\npython3.10 --version\nIf this returns something like Python 3.10.x, you’re good to go. If Python 3.10 is not installed, you can download it from the official Python website or use your system’s package manager to install it.\n\n\n\nNavigate to a directory where you’d like to store your virtual environment. If you already have a class folder called 360 you may change into it and execute the commands below:\nThen run:\npython3.10 -m venv myenv\nThis command creates a new virtual environment named myenv in the current directory. Replace myenv with a name of your choice if desired.\n\n\n\nTo activate the virtual environment: - On Linux/macOS:\nsource myenv/bin/activate\n\nOn Windows:\n\nmyenv\\Scripts\\activate\nAfter activation, your terminal prompt will change to indicate that the virtual environment is active. All Python packages installed while the virtual environment is active will be isolated from your global Python installation.\n\n\n\nWith the virtual environment activated, you can now install the required Python packages for this class. Use pip to install packages:\npip install numpy matplotlib scipy gala jax taichi plotly\n\n\n\nWhen you’re done working in the virtual environment, deactivate it by running:\ndeactivate\nThis will return your terminal to its normal state.\n\n\n\n\n\nAlways activate the virtual environment before running scripts for this class to ensure the correct Python version and dependencies are used.\nIf you ever need to delete the virtual environment, simply remove the myenv directory.\n\nThis process ensures an organized and isolated Python development environment, making it easier to manage dependencies for your coursework."
  },
  {
    "objectID": "lectures/preliminaries.html",
    "href": "lectures/preliminaries.html",
    "title": "Preliminaries",
    "section": "",
    "text": "Have a good understanding of what to expect from this course\nLearn about the grading policy, assignments and final project scope\n\n\n\n\nThis course is directed at first/second year graduate students interested in astrophysics research. We cover a few of the important physical processes necessary to understand astronomical objects and observations. The course will use python notebooks throughout helping with experiential learning and give the student resources to explore the code/formulas and algorithms behind the plots and animations.\n\n\n\n\n\n\nA useful free textbook for a number of theoretical concepts by Nick Kaiser: Elements of Astrophysics: Link to PDF\nBinney and Tremaine (2008) is a key reference for Galactic Dynamics.\nFundamentals of Astrophysical Fluid Dynamics by Kato and Fukue (2020) is recent and has a large scope with interesting discussion of fluids and radiation physics.\nIf you have access through Stanford libraries I’ll also add some .pdf files to the files section in the course Canvas site.\n\n\n\n\nIn short: 4 lectures on gravity,  4 on fluids,  4 on radiation, \n          4 on special topics and 4 with student presentations = 20 meeting times\n\nRough Calendar [will change]                     Reading              Problem Set              \nTu  1 Jan 7   Intro/Overview/Gravity             K:285-300            Workflow+\nTh  2 Jan 9   Gravity 3 ways | Stellar dynamics                       K: 26.7.1 p295 + 1-2 page Proposal\nTu  3 Jan 14  Cosmology + Zeldovich approx.      K:303+5,337+3,385+3  Bertschinger Dust Solution      \nTh  4 Jan 16  Hydrodynamics           I)         K:246-247,251-253                                   \nTu  5 Jan 21  Hydrodynamics          II)                                                                     \nTh  6 Jan 23  Sound Waves, Shocks & Sedov Taylor K:258,22.2,23.2      K:20.10.3 + Bertsch. g=5/3  \nTu  7 Jan 28  Radiation                          K:61-69                                             \nTh  8 Jan 30  Radiation Transport                K:81-89              K:6.12.1-4 +                \nTu  9 Feb  4  Radiative Processes   I)                                                               \nTh 10 Feb  6  Radiative Processes  II)                                                               \nTu 11 Feb 11  Radiative Processes III)                                K:14.9.2-3 +                \nTh 12 Feb 13  AT   I)  Spectra of Galaxies       Notes\nTu 13 Feb 18  AT  II)  HII regions               Notes                                           \nTh 14 Feb 20  AT III)  Press Schechter theory    Notes               reproduce Mo & White 98                                            \nTu 15 Feb 25  AT  IV)  Summary Statistics        Notes \nTh 16 Feb 27  AT   V)  Plasmas/Acceleration      Notes                                          \nTu 17 Mar  4  Presentations   I\nTh 18 Mar  6  Presentations  II                                                                       \nTu 19 Mar 11  Presentations III                                                                       \nTh 20 Mar 13  Presentations  IV                                                                       \n\n\n\n\n40% Final project and presentation\n\n60% Problem set (worst dropped)\n\n\nTesting our python code setup:\n\n\nCode\nimport sys\nsys.path.append('../code')\nfrom astro_utils import hello_astrophysics\n\nhello_astrophysics()\nimport sys\nprint(sys.executable)\n\n\nHello astrophysics! \n/opt/hostedtoolcache/Python/3.12.8/x64/bin/python3"
  },
  {
    "objectID": "lectures/preliminaries.html#learning-goals",
    "href": "lectures/preliminaries.html#learning-goals",
    "title": "Preliminaries",
    "section": "",
    "text": "Have a good understanding of what to expect from this course\nLearn about the grading policy, assignments and final project scope"
  },
  {
    "objectID": "lectures/preliminaries.html#modern-astrophysics",
    "href": "lectures/preliminaries.html#modern-astrophysics",
    "title": "Preliminaries",
    "section": "",
    "text": "This course is directed at first/second year graduate students interested in astrophysics research. We cover a few of the important physical processes necessary to understand astronomical objects and observations. The course will use python notebooks throughout helping with experiential learning and give the student resources to explore the code/formulas and algorithms behind the plots and animations."
  },
  {
    "objectID": "lectures/preliminaries.html#course-notes-and-schedule",
    "href": "lectures/preliminaries.html#course-notes-and-schedule",
    "title": "Preliminaries",
    "section": "",
    "text": "A useful free textbook for a number of theoretical concepts by Nick Kaiser: Elements of Astrophysics: Link to PDF\nBinney and Tremaine (2008) is a key reference for Galactic Dynamics.\nFundamentals of Astrophysical Fluid Dynamics by Kato and Fukue (2020) is recent and has a large scope with interesting discussion of fluids and radiation physics.\nIf you have access through Stanford libraries I’ll also add some .pdf files to the files section in the course Canvas site.\n\n\n\n\nIn short: 4 lectures on gravity,  4 on fluids,  4 on radiation, \n          4 on special topics and 4 with student presentations = 20 meeting times\n\nRough Calendar [will change]                     Reading              Problem Set              \nTu  1 Jan 7   Intro/Overview/Gravity             K:285-300            Workflow+\nTh  2 Jan 9   Gravity 3 ways | Stellar dynamics                       K: 26.7.1 p295 + 1-2 page Proposal\nTu  3 Jan 14  Cosmology + Zeldovich approx.      K:303+5,337+3,385+3  Bertschinger Dust Solution      \nTh  4 Jan 16  Hydrodynamics           I)         K:246-247,251-253                                   \nTu  5 Jan 21  Hydrodynamics          II)                                                                     \nTh  6 Jan 23  Sound Waves, Shocks & Sedov Taylor K:258,22.2,23.2      K:20.10.3 + Bertsch. g=5/3  \nTu  7 Jan 28  Radiation                          K:61-69                                             \nTh  8 Jan 30  Radiation Transport                K:81-89              K:6.12.1-4 +                \nTu  9 Feb  4  Radiative Processes   I)                                                               \nTh 10 Feb  6  Radiative Processes  II)                                                               \nTu 11 Feb 11  Radiative Processes III)                                K:14.9.2-3 +                \nTh 12 Feb 13  AT   I)  Spectra of Galaxies       Notes\nTu 13 Feb 18  AT  II)  HII regions               Notes                                           \nTh 14 Feb 20  AT III)  Press Schechter theory    Notes               reproduce Mo & White 98                                            \nTu 15 Feb 25  AT  IV)  Summary Statistics        Notes \nTh 16 Feb 27  AT   V)  Plasmas/Acceleration      Notes                                          \nTu 17 Mar  4  Presentations   I\nTh 18 Mar  6  Presentations  II                                                                       \nTu 19 Mar 11  Presentations III                                                                       \nTh 20 Mar 13  Presentations  IV                                                                       \n\n\n\n\n40% Final project and presentation\n\n60% Problem set (worst dropped)\n\n\nTesting our python code setup:\n\n\nCode\nimport sys\nsys.path.append('../code')\nfrom astro_utils import hello_astrophysics\n\nhello_astrophysics()\nimport sys\nprint(sys.executable)\n\n\nHello astrophysics! \n/opt/hostedtoolcache/Python/3.12.8/x64/bin/python3"
  },
  {
    "objectID": "lectures/gravity.html",
    "href": "lectures/gravity.html",
    "title": "Gravity",
    "section": "",
    "text": "Explore Newtonian Gravity via fores, potentials, and least action principle.\nCover some commonly used spherical distributions\nExplore stellar dynamics ins more realistic (yet static) potentials using gala package.\nLearn key principles of numerical methods used in gravitational dynamics"
  },
  {
    "objectID": "lectures/gravity.html#newtonian-gravity-3-ways",
    "href": "lectures/gravity.html#newtonian-gravity-3-ways",
    "title": "Gravity",
    "section": "Newtonian Gravity 3 Ways",
    "text": "Newtonian Gravity 3 Ways\n\n Newtonian gravity can be understood from three complementary perspectives, each providing unique insights into the nature of gravitational interactions. In the following sections, we will explore these perspectives: Forces, where we consider how gravitational acceleration arises directly from pairwise interactions or a continuous mass distribution; Potentials, where we describe the gravitational field as a scalar potential that satisfies Poisson’s equation and links mass to field strength; and Action, where the motion of self-gravitating systems is derived from a variational principle. Together, these approaches offer a comprehensive view of the dynamics governed by Newtonian gravity. If it has been a while you may appreciate (re-)watch Feynman’s Messenger lectures on these topics. At the very least they may help to motivate further study.\n\nFor gravity the 4th way please sign up for the General Relativity course physics PHYSICS 262: General Relativity\n\nForces\nIn Newton’s theory the acceleration of a particle is the sum over all other particles of \\(G\\) times the mass times the inverse square of the distance.\n\\[\n\\ddot{\\mathbf{x}}_j=\\sum_{i \\neq j} \\frac{G m_i\\left(\\mathbf{x}_i-\\mathbf{x}_j\\right)}{\\left|\\mathbf{x}_i-\\mathbf{x}_j\\right|^3}\n\\]\nwhere\n\\[\nG \\simeq 6.67 \\times 10^{-8} \\mathrm{~cm}^3 \\mathrm{~g}^{-1} \\mathrm{~s}^{-2}\n\\]\nFor a continuous density distribution this is\n\\[\n\\ddot{\\mathbf{x}}=\\mathbf{g}(\\mathbf{x})=G \\int d^3 x^{\\prime} \\rho\\left(\\mathbf{x}^{\\prime}\\right) \\frac{\\left(\\mathbf{x}^{\\prime}-\\mathbf{x}\\right)}{\\left|\\mathbf{x}^{\\prime}-\\mathbf{x}\\right|^3}\n\\]\n\n\nPotentials\nThe gravitational acceleration \\(\\mathbf{g}\\) can be written as the negative of the gradient of the gravitational potential \\(\\mathbf{g}=-\\nabla \\Phi\\) where\n\\[\n\\Phi(\\mathbf{x})=-G \\int d^3 x^{\\prime} \\frac{\\rho\\left(\\mathbf{x}^{\\prime}\\right)}{\\left|\\mathbf{x}^{\\prime}-\\mathbf{x}\\right|}\n\\]\nTaking the gradient of \\(\\Phi(\\mathbf{x})\\) one recovers In addition to the explicit formula for the potential as an spatial integral (25.4) there is also an equivalent local relationship between the Laplacian of the potential \\(\\nabla^2 \\Phi\\) and the density \\(\\rho\\)\n\\[\n\\nabla^2 \\Phi=4 \\pi G \\rho\n\\tag{1}\\]\nwhich is Poisson’s equation.\nIf we divide by \\(4 \\pi G\\) and integrate both sides of equation (Equation 1) over an arbitrary volume \\(V\\), and then apply the divergence theorem, we obtain\n\\[\nM = \\int_{V} \\mathrm{~d}^3 \\mathbf{x} \\rho= \\frac{1}{4 \\pi G} \\int_{V} \\mathrm{d}^3 \\mathbf{x} \\nabla^2 \\Phi =\n\\frac{1}{4 \\pi G} \\oint_{\\partial V} \\mathrm{d}^2 \\mathbf{S} \\cdot \\boldsymbol{\\nabla} \\Phi\n\\]\nThis is Gauss’s theorem and says that the integral of the normal component of \\(\\nabla \\Phi\\) over any closed surface, \\(\\partial V\\), divided by \\(4 \\pi G\\) equals the mass contained within that surface. This says average accelerations on the surface are only directly related to the mass contained inside it.\n\n\nAction for N Self-Gravitating Bodies\nThe action for \\(N\\) self-gravitating bodies is the starting point for deriving their equations of motion using the variational principle. In classical mechanics, the action is expressed as the time integral of the Lagrangian. For self-gravitating bodies, the Lagrangian has two components: the kinetic energy of the particles and the gravitational potential energy between them.\n\nGeneral Form of the Action\nThe action \\(S\\) for \\(N\\) self-gravitating bodies is:\n\\[\nS = \\int \\mathcal{L} \\, \\mathrm{d}t,\n\\]\nwhere the Lagrangian \\(\\mathcal{L}\\) is given by:\n\\[\n\\mathcal{L} = T - U.\n\\]\nHere:\n\n\\(T\\) is the total kinetic energy of the system.\n\\(U\\) is the total gravitational potential energy of the system.\n\n\nKinetic Energy\nThe kinetic energy is:\n\\[\nT = \\frac{1}{2} \\sum_{i=1}^N m_i \\|\\dot{\\mathbf{r}}_i\\|^2,\n\\]\nwhere:\n\n\\(m_i\\) is the mass of the \\(i\\)-th particle.\n\\(\\dot{\\mathbf{r}}_i = \\frac{\\mathrm{d}\\mathbf{r}_i}{\\mathrm{d}t}\\) is the velocity of the \\(i\\)-th particle.\n\n\n\nGravitational Potential Energy\nThe gravitational potential energy is:\n\\[\nU = - \\frac{1}{2} \\sum_{i=1}^N \\sum_{j \\neq i}^N \\frac{G m_i m_j}{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|},\n\\]\nwhere:\n\n\\(G\\) is the gravitational constant.\n\n\\(\\|\\mathbf{r}_i - \\mathbf{r}_j\\|\\) is the Euclidean distance between the \\(i\\)-th and \\(j\\)-th particles.\n\nThe factor \\(\\frac{1}{2}\\) accounts for double-counting each pair of interactions.\n\n\n\nFull Expression for the Action\nSubstituting the kinetic and potential energy terms, the action becomes:\n\\[\nS = \\int \\left( \\frac{1}{2} \\sum_{i=1}^N m_i \\|\\dot{\\mathbf{r}}_i\\|^2 + \\frac{1}{2} \\sum_{i=1}^N \\sum_{j \\neq i}^N \\frac{G m_i m_j}{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|} \\right) \\mathrm{d}t.\n\\]\nThis action governs the dynamics of \\(N\\) self-gravitating bodies under Newtonian gravity.\n\n\nDeriving Equations of Motion\nTo find the equations of motion, apply the principle of stationary action:\n\\[\n\\delta S = 0.\n\\]\nVarying \\(S\\) with respect to \\(\\mathbf{r}_i\\) leads to the Euler-Lagrange equations:\n\\[\nm_i \\ddot{\\mathbf{r}}_i = -\\sum_{j \\neq i}^N \\frac{G m_i m_j}{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|^3} (\\mathbf{r}_i - \\mathbf{r}_j).\n\\]\nThis is Newton’s second law for the \\(i\\)-th particle in the gravitational field created by the other particles."
  },
  {
    "objectID": "lectures/gravity.html#spherical-systems",
    "href": "lectures/gravity.html#spherical-systems",
    "title": "Gravity",
    "section": "25.3 Spherical Systems",
    "text": "25.3 Spherical Systems\n\n25.3.1 Newton’s Theorems\nNewton found that\n\n\\(\\mathbf{g}=0\\) inside a spherical shell of mass.\nThe gravity outside such a shell is the same as for an equivalent mass at the origin.\n\nThese can be proved geometrically (see Binney and Tremaine (2008)), and they also follow directly from Gauss’ law and spherical symmetry.\nThese theorems imply that the gravity \\(\\mathbf{g}(\\mathbf{r})\\) for an arbitrary spherical system with cumulative mass profile \\(M(r)\\) is\n\\[\n\\mathbf{g}=-\\frac{G M(r)}{r^2} \\hat{\\mathbf{r}}\n\\]\n\n\n25.3.2 Circular and Escape Speed\nThe speed of a particle on a circular orbit satisfies\n\\[\n\\frac{d v}{d t}=\\frac{v^2}{r}=\\frac{G M(r)}{r^2} \\quad \\rightarrow \\quad v_{\\mathrm{circ}}=\\sqrt{G M(r) / r}\n\\]\nThe escape speed is\n\\[\nv_{\\mathrm{esc}}=\\sqrt{2 \\Phi(r)}\n\\]\nwhere \\(\\Phi\\) is measured relative to its value at spatial infinity.\n\n\n25.3.3 Point Mass\nFor a point mass \\(M(r)=m\\):\n\nThe potential is \\(\\Phi=-G m / r\\).\nThe circular velocity is \\(v_{\\text {circ }}=\\sqrt{G m / r}\\).\nThe escape velocity is \\(v_{\\text {esc }}=\\sqrt{2} v_{\\text {circ }}\\).\nThe \\(v_{\\text {circ }} \\propto r^{-1 / 2}\\) circular speed profile is usually referred to as a Keplerian profile.\n\n\n\n25.3.3 Uniform Density Sphere\nFor a static uniform sphere of density \\(\\rho\\) - The gravity is\n\\[\ng=\\frac{G M(r)}{r^2}=\\frac{4 \\pi}{3} G \\rho r .\n\\]\n\nThe circular speed is\n\n\\[\nv_{\\mathrm{circ}}=\\sqrt{\\frac{4 \\pi G \\rho}{3}} r\n\\]\n\nThe orbital period is\n\n\\[\nt_{\\text {orbit }}=\\frac{2 \\pi r}{v_{\\text {circ }}}=\\sqrt{\\frac{3 \\pi}{G \\rho}}\n\\]\nwhich is independent of the radius of the orbit. - The potential, measured with respect to the origin, is a parabola and the equation of motion for test particles within the sphere is\n\\[\n\\ddot{\\mathbf{r}}=-\\frac{4 \\pi G \\rho}{3} \\mathbf{r}\n\\]\nThe period of any orbit in this potential is the same as that for a circular orbit.\n\nThe dynamical time scales corresponding to density \\(\\rho\\) have various definitions and you will find orbital time, the collapse time, the free fall time etc.. These are always on the order of \\(t_{\\mathrm{dyn}}=1 / \\sqrt{G \\rho}\\).\n\nThis is the gravitational spherical harmonic oscillator. No phase mixing occurs in such a potential. Nearby particles stay nearby.\n\n\nPower Law Density Profile\nA power law density profile \\(\\rho(r)=\\rho_0\\left(r / r_0\\right)^{-\\alpha}\\) has - Mass \\(M(r) \\propto r^{3-\\alpha}\\). - We need \\(\\alpha&lt;3\\) if the mass at the origin is to be finite. - The density cusp at the origin can be ‘softened’ as in the NFW models. - A flat rotation curve results for \\(\\alpha=2\\) and is referred to as a singular isothermal sphere profile.\n\n\nHernquist and NFW Models\nMass condensations that grow in cosmological simulations have been found to be quite well described by double power-law models.\nThe Navarro, Frenk, and White (1996) (NFW) model is\n\\[\n\\rho(r) \\propto \\frac{1}{r\\left(r^2+r_c^2\\right)}\n\\]\nwhich has asymptotic forms\n\\[\n\\rho \\propto\\left\\{\\begin{array}{l}\nr^{-1} \\\\\nr^{-3}\n\\end{array}\\right\\} \\quad \\text { for } \\quad\\left\\{\\begin{array}{l}\nr \\ll r_c \\\\\nr \\gg r_c\n\\end{array}\\right.\n\\]"
  },
  {
    "objectID": "lectures/gravity.html#the-virial-theorem",
    "href": "lectures/gravity.html#the-virial-theorem",
    "title": "Gravity",
    "section": "26.3 The Virial Theorem",
    "text": "26.3 The Virial Theorem\nConsider the moment of inertia of a system of point masses \\(I \\equiv \\sum m r^2\\). The time derivative is \\(\\dot{I}=2 \\sum m \\mathbf{r} \\cdot \\dot{\\mathbf{r}}\\) and taking a further time derivative gives\n\\[\n\\frac{1}{2} \\ddot{I}=\\sum m \\dot{r}^2+\\sum m \\mathbf{r} \\cdot \\ddot{\\mathbf{r}}\n\\]\nRequiring that \\(\\ddot{I}\\) vanish for a stable system and expressing the acceleration \\(\\ddot{\\mathbf{r}}\\) as a sum of the gravity from all the other particles gives\n\\[\n2 T+\\sum_{\\mathbf{r}} m \\mathbf{r} \\cdot \\sum_{\\mathbf{r}^{\\prime} \\neq \\mathbf{r}} G m^{\\prime} \\frac{\\mathbf{r}^{\\prime}-\\mathbf{r}}{\\left|\\mathbf{r}^{\\prime}-\\mathbf{r}\\right|^3}=0\n\\]\nwith \\(T\\) the kinetic energy of the particles. Now switching \\(\\mathbf{r} \\leftrightarrow \\mathbf{r}^{\\prime}\\) in the last term simply changes the sign, so we can write this as\n\\[\n\\begin{gathered}\n\\sum_{\\mathbf{r}} \\sum_{\\mathbf{r}^{\\prime} \\neq \\mathbf{r}} G m m^{\\prime} \\mathbf{r} \\cdot \\frac{\\mathbf{r}^{\\prime}-\\mathbf{r}}{\\left|\\mathbf{r}^{\\prime}-\\mathbf{r}\\right|^3} \\\\\n=\\frac{1}{2}\\left[\\sum_{\\mathbf{r}} \\sum_{\\mathbf{r}^{\\prime} \\neq \\mathbf{r}} G m m^{\\prime} \\mathbf{r} \\cdot \\frac{\\mathbf{r}^{\\prime}-\\mathbf{r}}{\\left|\\mathbf{r}^{\\prime}-\\mathbf{r}\\right|^3}-\\sum_{\\mathbf{r}} \\sum_{\\mathbf{r}^{\\prime} \\neq \\mathbf{r}} G m m^{\\prime} \\mathbf{r}^{\\prime} \\cdot \\frac{\\mathbf{r}^{\\prime}-\\mathbf{r}}{\\left|\\mathbf{r}^{\\prime}-\\mathbf{r}\\right|^3}\\right] \\\\\n=-\\frac{1}{2} \\sum_{\\mathbf{r}} \\sum_{\\mathbf{r}^{\\prime} \\neq \\mathbf{r}} \\frac{G m m^{\\prime}}{\\left|\\mathbf{r}^{\\prime}-\\mathbf{r}\\right|}=W\n\\end{gathered}\n\\]\nand we therefore have the virial theorem\n\\[\n2 T+W=0\n\\]\nThe virial theorem provides a useful way to estimate the mass of bound systems. For example, if we assume equal mass particles, then the particle mass \\(m\\) is given by\n\\[\nm=\\frac{2}{G} \\frac{\\sum \\dot{r}^2}{\\sum_{\\text {pairs }} 1 / r_{12}}\n\\]\nFor a roughly spherical system it is reasonable to assume that the 3-dimensional velocity dispersion in the numerator is 3 times the observed line of sight velocity dispersion. Similarly, the mean harmonic radius which appears in the denominator can be estimated from the observed distribution of projected separations, and this provides a useful way to determine the mass of a gravitating system.\nThe virial theorem gives the correct answer if the luminous particles trace the mass, but will fail if, for example, the dark matter has a different profile from the luminous particles."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html",
    "href": "tutorials/integrate-1D-poissonEquation.html",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "In physics we often write \\(\\nabla^2\\) instead of \\(\\Delta\\) but we mean the same thing, suming the second derivatives along each value.\nHere we explore a solution strategy for the one dimensional Poisson equation. This is purely an example and most of the solution strategies will work for almost all second order partial differential equations. Let us first make the equation dimension-less. We can use the mean density \\(\\bar{\\rho}=\\int\\rho dV/\\int dV\\) to define the overdensity \\[D\\equiv \\frac{\\rho}{\\bar{\\rho}}\\] and rescale the potential\n\\[\n\\tilde{\\Phi}\\equiv (C \\bar{\\rho} L^2)^{-1}\\Phi\n\\]\nwhich we can insert into the original equation \\(\\Delta \\tilde{\\Phi} C \\bar{\\rho} L^2 = C \\rho\\) and get a new equation for \\(\\tilde{\\Phi}\\):\n\\[\nL^{2}\\Delta \\tilde{\\Phi} =  D.\n\\]\n\\(L\\) is just a constant length. It could be just a typical length scale of the problem. This is now convenient as the over density is a nice dimensionless intuitively easy to grasp description of the density. Also all the length intervals we have in the problem as just measured in units of \\(L\\) and once we have a solution we can use these relations to back out the SI/cgs values of the potential.\nSo let us also measure all distances in units of \\(L\\) so we define \\[\\tilde{x}\\equiv x/L\\] and have \\(d\\tilde{x}/dx = 1/L\\)\nThe Force is just \\(-\\nabla \\tilde{\\Phi}\\), so in one dimension\n\\[\n-\\frac{\\partial F}{\\partial \\tilde{x}} = D\n\\]\nwe now simply have\n\\[\nF(X) = -\\int_0^X D(\\tilde{x}) d\\tilde{x} + F(x=0),\n\\]\nwith the integration constant being recognized as \\(F(x=0)\\) which must be obtained from a boundary condition. Its meaning is clear it is the Force at \\(x=0\\). Also the integral over the density on the right hand side has a simple meaning. It is the mass (charge) in the interval \\([0..X]\\). We also can see this from Gauss’ law that\n\\[\nF(1)-F(0)= -\\int_0^1 D(\\tilde{x}) d\\tilde{x}\n\\]\nso that in a periodic domain where we have \\(F(0)=F(1)\\) it follows that \\(C_1 = F(0)\\). The problem is though that a priori we do not know \\(F(0)\\). However, in the case where no external forces are applied the system must conserve momentum. I.e. the total momentum change must remain zero\n\\[\n\\int_0^1 \\frac{dp}{dt} d\\tilde{x} = \\int_0^1 F(\\tilde{x}) d\\tilde{x} = 0\n\\]\nSo we have\n\\[\n-\\int_0^X \\int_0^X D(\\tilde{x})d\\tilde{x} + X F(x=0) = 0\n\\]\nso\n\\[\nF(0) = -\\int_0^1 \\int_0^1 D(\\tilde{x})d\\tilde{x}  \n\\]\nIntegrating this once more and we get the Potential\n\\[\n- \\tilde{\\Phi}(X) = \\int_0^X F(\\tilde{x}) d\\tilde{x}  + C_2\n\\]\n\n\n&lt;&gt;:24: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:26: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:24: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:26: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/3129958682.py:24: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/3129958682.py:26: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\nF(x=0) =  -0.07082481931956612\n\n\n\n\n\n\n\n\n\n\n\n- Calculate the potential and force in and around a homogeneous sphere reusing the numerical integration and differentiation as in the example above. \n- Have the sphere be at position x=0.4 and have a radius 0.025\n- What did you notice about our assumption of periodic boundaries? How does the mean density enter?\n- Plot it for the grid resolution 60 and 240\n- Discuss the solution\n\n\nF(x=0) =  0.6019793898581776\n\n\n&lt;&gt;:26: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:28: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:26: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:28: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/968438071.py:26: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/968438071.py:28: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe trick we just used above is only possible in one dimensions. In two or more the Poisson equation is essentially always a boundary value problem. I.e. we need to specify the values of \\(\\Phi\\) on the boundary and the interate to find a convergent solution. We introduce this style of solving it here next but stay in one dimensions to keep things simple at first. So we start out by discretizing the Poisson equation using the central difference for the second derivative.\n\\[\n\\frac{1}{h^2} \\left( \\Phi_{i+1} + \\Phi_{i-1} - 2\\Phi_i \\right) = C\\ D(x_i)\n\\]\nwhere we took the liberty and drop the ~ symbols for \\(\\tilde{\\Phi}\\) and \\(d\\tilde{x}\\) while still working in these dimensionless quantities.\nThis gives us an obvious solution strategy. We just solve for \\(\\Phi_i\\) and remember to specify boundary values on the left and right so that the resulting formula is always defined. I.e.\n\\[\n\\Phi_i = \\frac{1}{2}\\left( \\Phi_{i+1} + \\Phi_{i-1} - C\\ D(x_i)\\ h^2 \\right)\n\\]\nFor our first implementation we will assume periodic boundaries.\nThe overdensity \\(D(x)\\) will be defined at cell centers and similarly \\(\\Phi\\) is recorded at the same positions.\n\n\n&lt;&gt;:15: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:18: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:15: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:18: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/1351949014.py:15: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/1351949014.py:18: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\nWow. That takes an enormous amount of iterations to converge. In particular if the solution has long wavelength components. This method is known an Jacobi’s iterative method.\nAh yes. But we could use the update values as we march through. Perhaps that converges faster?\n\n\n&lt;&gt;:16: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:19: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:16: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:19: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/3725170206.py:16: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/3725170206.py:19: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\nThat is indeed somewhat of an improvement. It is called the Gauss Seidel iteration.\n\n\n\nIf we wouldn’ change the values completely just on the neighbors but keep some information from previous steps we can weight the update. This is known as successive over-relaxation. \\[\n\\Phi_i^{n+1} = (1-\\omega)\\ \\Phi_i^n + \\omega/2\\ \\left( \\Phi^n_{i+1} + \\Phi^n_{i-1} - c h^2 D \\right),\n\\] first for \\(i=0,2,4,\\cdots\\) and then for \\(i=1,3,5,\\cdots\\). It is the same number of operations as before but does converge somewhat quicker.\n\n\n&lt;&gt;:19: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:22: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:19: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:22: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/3512576029.py:19: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/3512576029.py:22: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\nOk. This is better! It, however, added another parameter which is left to the user to choose. It is only convergent in $ 0 &lt; w &lt; 2 $.\n\n\n\nThere is a variant of Gauss Seidel and succesive over-relaxation that is known as red-black ordering. This realizes that even positions are only dependent on odd neighbors and odd ones only on even. So first updates the one half and then the other. We do our SOR update \\[\n\\Phi_i^{n+1} = (1-\\omega)\\ \\Phi_i^N + \\omega/2\\ \\left( \\Phi^n_{i+1} + \\Phi^n_{i-1} - c h^2 D \\right),\n\\] first for \\(i=0,2,4,\\cdots\\) and then for \\(i=1,3,5,\\cdots\\). It is the same number of operations as before but does converge somewhat quicker.\n\n\n&lt;&gt;:21: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:24: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:26: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:21: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:24: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:26: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/681110147.py:21: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/681110147.py:24: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/681110147.py:26: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\nThis is indeed a further improvement.\n\n\n\nOur discretization we used in the relaxation method can also be written in matrix form:\n\\[ A\\ \\Phi = h^2 C\\ D =\n\\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 & 0 & 1 \\\\\\\\\n1 & -2 & 1 & 0 & \\cdots & 0 & 0 \\\\\\\\\n0 & 1 & -2 & 1 & 0 & \\cdots & 0 \\\\\\\\\n\\vdots  & \\vdots  & \\ddots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\\\\\n0 & 0 & ... & 0 & 1 & -2 & 1 \\\\\\\\\n1 & 0 & 0 & ... & 0 & 1 & -2\n\\end{pmatrix}\n\\\n\\begin{pmatrix}\n\\Phi_1 \\\\\\\\\n\\Phi_2 \\\\\\\\\n\\Phi_3 \\\\\\\\\n\\vdots \\\\\\\\\n\\Phi_{n-1} \\\\\\\\\n\\Phi_n\n\\end{pmatrix}\n= h^2 C\\\n\\begin{pmatrix}\nD_1 \\\\\\\\\nD_2 \\\\\\\\\nD_3 \\\\\\\\\n\\vdots \\\\\\\\\nD_{n-1} \\\\\\\\\nD_n\n\\end{pmatrix}\n\\]\nSo in the relaxation technique we iterated until we got \\(\\Phi\\) to agree with this formula.\nSo let us define this Matrix:\n\n\n[[-2.  1.  0. ...  0.  0.  1.]\n [ 1. -2.  1. ...  0.  0.  0.]\n [ 0.  1. -2. ...  0.  0.  0.]\n ...\n [ 0.  0.  0. ... -2.  1.  0.]\n [ 0.  0.  0. ...  1. -2.  1.]\n [ 1.  0.  0. ...  0.  1. -2.]]\nDeterminant of A is: 1.3322676295502058e-13\n\n\nand now invert it\n\n\narray([[ 1.   , -0.125,  0.   , ...,  0.   ,  0.   ,  0.   ],\n       [ 0.125,  0.875, -0.125, ...,  0.   ,  0.   ,  0.   ],\n       [ 0.   ,  0.   ,  0.875, ...,  0.125, -0.125,  0.   ],\n       ...,\n       [ 0.   , -0.125,  0.   , ...,  1.   ,  0.   ,  0.   ],\n       [ 0.   ,  0.   , -0.125, ...,  0.   ,  1.   ,  0.   ],\n       [ 0.   ,  0.   , -0.125, ...,  0.   ,  0.   ,  0.75 ]],\n      shape=(100, 100))\n\n\nThis did not work … It failed to correctly invert the matrix. I.e. we do not get identity matrix back when we multiply the original matrix and its supposed inverse. In hindsight we may have guessed that since the potential is not fixed up to a constant. So consequently the matrix has a determinant of zero and no unique solution is obtained.\nHowever, we can add one row in which we set a constant \\(\\Phi\\) value. I.e.\n\\[ A\\ \\Phi = h^2 C\\ D =\n\\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 & 0 & 1& 0  \\\\\\\\\n1 & -2 & 1 & 0 & \\cdots & 0 & 0& 0 \\\\\\\\\n0 & 1 & -2 & 1 & 0 & \\cdots & 0& 0 \\\\\\\\\n\\vdots  & \\vdots  & \\ddots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\\\\\n0 & 0 & ... & 0 & 1 & -2 & 1& 0 \\\\\\\\\n1 & 0 & 0 & ... & 0 & 1 & -2& 0 \\\\\\\\\n1 & 1 & 1 & ... & 1 & 1 & 1 & 0\n\\end{pmatrix}\n\\\n\\begin{pmatrix}\n\\Phi_1 \\\\\\\\\n\\Phi_2 \\\\\\\\\n\\Phi_3 \\\\\\\\\n\\vdots \\\\\\\\\n\\Phi_{n-1} \\\\\\\\\n\\Phi_n \\\\\\\\\n\\Phi_{n+1}\n\\end{pmatrix}\n= h^2 C\\\n\\begin{pmatrix}\nD_1 \\\\\\\\\nD_2 \\\\\\\\\nD_3 \\\\\\\\\n\\vdots \\\\\\\\\nD_{n-1} \\\\\\\\\nD_n \\\\\\\\\n0\n\\end{pmatrix}\n\\]\nOnce we have the solution to \\(\\Phi\\) we throw away \\(\\Phi_{n+1}\\) and subtract the mean of the potential \\(\\int_0^1 \\Phi dx\\) just by convention.\n\n\n[[-1.38777878e-16  4.94444444e-01  9.77777778e-01 ...  9.77777778e-01\n   4.94444444e-01  1.11111111e-02]\n [-8.32667268e-17 -4.94444444e-01 -1.73688224e-15 ...  9.55555556e-01\n   4.83333333e-01  1.11111111e-02]\n [-2.77555756e-16 -4.83333333e-01 -9.77777778e-01 ...  9.33333333e-01\n   4.72222222e-01  1.11111111e-02]\n ...\n [ 2.49800181e-16  4.72222222e-01  9.33333333e-01 ... -9.77777778e-01\n  -4.83333333e-01  1.11111111e-02]\n [ 1.94289029e-16  4.83333333e-01  9.55555556e-01 ... -1.11022302e-16\n  -4.94444444e-01  1.11111111e-02]\n [ 1.00000000e+00  1.48333333e+00  1.95555556e+00 ...  1.00000000e+00\n   5.05555556e-01  1.11111111e-02]]\nDeterminant of the input matrix is : 8100.0000000000355\n\n\n&lt;&gt;:29: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:32: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:33: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:29: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:32: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:33: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/247100793.py:29: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/247100793.py:32: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/247100793.py:33: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\n\n\nDeterminant of A is: 8100.0000000000355\n\n\n\n\n\n\n\n\n\n\n\nSo clearly all the matrix values are filled. This is now very similar to the \\(N^2\\) operations we saw in the gravitational N-body problem. Every cell contibutes to the potential of every other cell and our matrix inversion gives the formula of how to do that.\n\n\n\nLet us for a second though think of what would happen if we had the density and the potential given by their Fourier transforms. \\[\n\\Phi(x) =  \\int \\phi(k)\\ e^{2\\pi\\ ikx} dk, \\ \\ D(x) =  \\int \\delta(k)\\ e^{2\\pi\\ ikx} dk\n\\] If we enter this in our starting equation \\(\\Delta \\Phi=c\\ D\\) we find that \\[\n-4\\pi\\ k^2\\phi(k) = c\\ \\delta(k), \\ \\ \\rightarrow \\ \\ \\phi(k) = -\\frac{c}{4\\pi}\\ \\delta(k)/k^2.\n\\] Oh fantastic. This means that if we Fourier transform the density, then multiply it with \\(-c/k^2\\) in Fourier space we already get the Fourier transformed potential. If we then just do the inverse Fourier transform back to real space we should have the correct potential we were looking for!\nThis may sound at first like a fairly complicated roundabaout way of getting at our problem. However, discrete Fourier transforms are only of complexity \\(log\\ N \\ \\ N\\) and some of the best optimized routines available on computers. So this can be an extraordinarily useful way of solving the Poisson equation in any dimension.\nThis is so elegant we just have to try it. Fortunately python makes this easy for us since it comes with Fourier transforms and helper functions included.\nThe conventions in numpy for the discrete Fourier transform are \\[\nA_k = \\sum_{m=0}^{N-1}\\ a_m\\ e^{-2\\pi\\ i\\ m\\ k/N}, \\ \\ k=0,1,...,n-2,n-1\n\\] and the inverse transform is given by \\[\na_m = \\frac{1}{N}\\sum_{m=0}^{n-1}\\ A_m\\ e^{2\\pi\\ i\\ m\\ k/N}\n\\] See the FFT documentation for more details.\n\n\n&lt;&gt;:25: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:28: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:29: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:25: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:28: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:29: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/450823216.py:25: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/450823216.py:28: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/450823216.py:29: SyntaxWarning:\n\ninvalid escape sequence '\\P'"
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#using-relaxation",
    "href": "tutorials/integrate-1D-poissonEquation.html#using-relaxation",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "The trick we just used above is only possible in one dimensions. In two or more the Poisson equation is essentially always a boundary value problem. I.e. we need to specify the values of \\(\\Phi\\) on the boundary and the interate to find a convergent solution. We introduce this style of solving it here next but stay in one dimensions to keep things simple at first. So we start out by discretizing the Poisson equation using the central difference for the second derivative.\n\\[\n\\frac{1}{h^2} \\left( \\Phi_{i+1} + \\Phi_{i-1} - 2\\Phi_i \\right) = C\\ D(x_i)\n\\]\nwhere we took the liberty and drop the ~ symbols for \\(\\tilde{\\Phi}\\) and \\(d\\tilde{x}\\) while still working in these dimensionless quantities.\nThis gives us an obvious solution strategy. We just solve for \\(\\Phi_i\\) and remember to specify boundary values on the left and right so that the resulting formula is always defined. I.e.\n\\[\n\\Phi_i = \\frac{1}{2}\\left( \\Phi_{i+1} + \\Phi_{i-1} - C\\ D(x_i)\\ h^2 \\right)\n\\]\nFor our first implementation we will assume periodic boundaries.\nThe overdensity \\(D(x)\\) will be defined at cell centers and similarly \\(\\Phi\\) is recorded at the same positions.\n\n\n&lt;&gt;:15: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:18: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:15: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:18: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/1351949014.py:15: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/1351949014.py:18: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\nWow. That takes an enormous amount of iterations to converge. In particular if the solution has long wavelength components. This method is known an Jacobi’s iterative method.\nAh yes. But we could use the update values as we march through. Perhaps that converges faster?\n\n\n&lt;&gt;:16: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:19: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:16: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:19: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/3725170206.py:16: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/3725170206.py:19: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\nThat is indeed somewhat of an improvement. It is called the Gauss Seidel iteration."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#using-successive-over-relaxation",
    "href": "tutorials/integrate-1D-poissonEquation.html#using-successive-over-relaxation",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "If we wouldn’ change the values completely just on the neighbors but keep some information from previous steps we can weight the update. This is known as successive over-relaxation. \\[\n\\Phi_i^{n+1} = (1-\\omega)\\ \\Phi_i^n + \\omega/2\\ \\left( \\Phi^n_{i+1} + \\Phi^n_{i-1} - c h^2 D \\right),\n\\] first for \\(i=0,2,4,\\cdots\\) and then for \\(i=1,3,5,\\cdots\\). It is the same number of operations as before but does converge somewhat quicker.\n\n\n&lt;&gt;:19: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:22: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:19: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:22: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/3512576029.py:19: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/3512576029.py:22: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\nOk. This is better! It, however, added another parameter which is left to the user to choose. It is only convergent in $ 0 &lt; w &lt; 2 $."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#succesive-over-relaxation-with-red-black-ordering",
    "href": "tutorials/integrate-1D-poissonEquation.html#succesive-over-relaxation-with-red-black-ordering",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "There is a variant of Gauss Seidel and succesive over-relaxation that is known as red-black ordering. This realizes that even positions are only dependent on odd neighbors and odd ones only on even. So first updates the one half and then the other. We do our SOR update \\[\n\\Phi_i^{n+1} = (1-\\omega)\\ \\Phi_i^N + \\omega/2\\ \\left( \\Phi^n_{i+1} + \\Phi^n_{i-1} - c h^2 D \\right),\n\\] first for \\(i=0,2,4,\\cdots\\) and then for \\(i=1,3,5,\\cdots\\). It is the same number of operations as before but does converge somewhat quicker.\n\n\n&lt;&gt;:21: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:24: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:26: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:21: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:24: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:26: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/681110147.py:21: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/681110147.py:24: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/681110147.py:26: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\nThis is indeed a further improvement."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#recognizing-this-is-a-linear-algebra-problem",
    "href": "tutorials/integrate-1D-poissonEquation.html#recognizing-this-is-a-linear-algebra-problem",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "Our discretization we used in the relaxation method can also be written in matrix form:\n\\[ A\\ \\Phi = h^2 C\\ D =\n\\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 & 0 & 1 \\\\\\\\\n1 & -2 & 1 & 0 & \\cdots & 0 & 0 \\\\\\\\\n0 & 1 & -2 & 1 & 0 & \\cdots & 0 \\\\\\\\\n\\vdots  & \\vdots  & \\ddots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\\\\\n0 & 0 & ... & 0 & 1 & -2 & 1 \\\\\\\\\n1 & 0 & 0 & ... & 0 & 1 & -2\n\\end{pmatrix}\n\\\n\\begin{pmatrix}\n\\Phi_1 \\\\\\\\\n\\Phi_2 \\\\\\\\\n\\Phi_3 \\\\\\\\\n\\vdots \\\\\\\\\n\\Phi_{n-1} \\\\\\\\\n\\Phi_n\n\\end{pmatrix}\n= h^2 C\\\n\\begin{pmatrix}\nD_1 \\\\\\\\\nD_2 \\\\\\\\\nD_3 \\\\\\\\\n\\vdots \\\\\\\\\nD_{n-1} \\\\\\\\\nD_n\n\\end{pmatrix}\n\\]\nSo in the relaxation technique we iterated until we got \\(\\Phi\\) to agree with this formula.\nSo let us define this Matrix:\n\n\n[[-2.  1.  0. ...  0.  0.  1.]\n [ 1. -2.  1. ...  0.  0.  0.]\n [ 0.  1. -2. ...  0.  0.  0.]\n ...\n [ 0.  0.  0. ... -2.  1.  0.]\n [ 0.  0.  0. ...  1. -2.  1.]\n [ 1.  0.  0. ...  0.  1. -2.]]\nDeterminant of A is: 1.3322676295502058e-13\n\n\nand now invert it\n\n\narray([[ 1.   , -0.125,  0.   , ...,  0.   ,  0.   ,  0.   ],\n       [ 0.125,  0.875, -0.125, ...,  0.   ,  0.   ,  0.   ],\n       [ 0.   ,  0.   ,  0.875, ...,  0.125, -0.125,  0.   ],\n       ...,\n       [ 0.   , -0.125,  0.   , ...,  1.   ,  0.   ,  0.   ],\n       [ 0.   ,  0.   , -0.125, ...,  0.   ,  1.   ,  0.   ],\n       [ 0.   ,  0.   , -0.125, ...,  0.   ,  0.   ,  0.75 ]],\n      shape=(100, 100))\n\n\nThis did not work … It failed to correctly invert the matrix. I.e. we do not get identity matrix back when we multiply the original matrix and its supposed inverse. In hindsight we may have guessed that since the potential is not fixed up to a constant. So consequently the matrix has a determinant of zero and no unique solution is obtained.\nHowever, we can add one row in which we set a constant \\(\\Phi\\) value. I.e.\n\\[ A\\ \\Phi = h^2 C\\ D =\n\\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 & 0 & 1& 0  \\\\\\\\\n1 & -2 & 1 & 0 & \\cdots & 0 & 0& 0 \\\\\\\\\n0 & 1 & -2 & 1 & 0 & \\cdots & 0& 0 \\\\\\\\\n\\vdots  & \\vdots  & \\ddots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\\\\\n0 & 0 & ... & 0 & 1 & -2 & 1& 0 \\\\\\\\\n1 & 0 & 0 & ... & 0 & 1 & -2& 0 \\\\\\\\\n1 & 1 & 1 & ... & 1 & 1 & 1 & 0\n\\end{pmatrix}\n\\\n\\begin{pmatrix}\n\\Phi_1 \\\\\\\\\n\\Phi_2 \\\\\\\\\n\\Phi_3 \\\\\\\\\n\\vdots \\\\\\\\\n\\Phi_{n-1} \\\\\\\\\n\\Phi_n \\\\\\\\\n\\Phi_{n+1}\n\\end{pmatrix}\n= h^2 C\\\n\\begin{pmatrix}\nD_1 \\\\\\\\\nD_2 \\\\\\\\\nD_3 \\\\\\\\\n\\vdots \\\\\\\\\nD_{n-1} \\\\\\\\\nD_n \\\\\\\\\n0\n\\end{pmatrix}\n\\]\nOnce we have the solution to \\(\\Phi\\) we throw away \\(\\Phi_{n+1}\\) and subtract the mean of the potential \\(\\int_0^1 \\Phi dx\\) just by convention.\n\n\n[[-1.38777878e-16  4.94444444e-01  9.77777778e-01 ...  9.77777778e-01\n   4.94444444e-01  1.11111111e-02]\n [-8.32667268e-17 -4.94444444e-01 -1.73688224e-15 ...  9.55555556e-01\n   4.83333333e-01  1.11111111e-02]\n [-2.77555756e-16 -4.83333333e-01 -9.77777778e-01 ...  9.33333333e-01\n   4.72222222e-01  1.11111111e-02]\n ...\n [ 2.49800181e-16  4.72222222e-01  9.33333333e-01 ... -9.77777778e-01\n  -4.83333333e-01  1.11111111e-02]\n [ 1.94289029e-16  4.83333333e-01  9.55555556e-01 ... -1.11022302e-16\n  -4.94444444e-01  1.11111111e-02]\n [ 1.00000000e+00  1.48333333e+00  1.95555556e+00 ...  1.00000000e+00\n   5.05555556e-01  1.11111111e-02]]\nDeterminant of the input matrix is : 8100.0000000000355\n\n\n&lt;&gt;:29: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:32: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:33: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:29: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:32: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:33: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/247100793.py:29: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/247100793.py:32: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/247100793.py:33: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n\n\n\n\n\n\n\n\n\n\n\nDeterminant of A is: 8100.0000000000355\n\n\n\n\n\n\n\n\n\n\n\nSo clearly all the matrix values are filled. This is now very similar to the \\(N^2\\) operations we saw in the gravitational N-body problem. Every cell contibutes to the potential of every other cell and our matrix inversion gives the formula of how to do that."
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#using-fast-fourier-transforms",
    "href": "tutorials/integrate-1D-poissonEquation.html#using-fast-fourier-transforms",
    "title": "Solving the Poisson Equation tutorial",
    "section": "",
    "text": "Let us for a second though think of what would happen if we had the density and the potential given by their Fourier transforms. \\[\n\\Phi(x) =  \\int \\phi(k)\\ e^{2\\pi\\ ikx} dk, \\ \\ D(x) =  \\int \\delta(k)\\ e^{2\\pi\\ ikx} dk\n\\] If we enter this in our starting equation \\(\\Delta \\Phi=c\\ D\\) we find that \\[\n-4\\pi\\ k^2\\phi(k) = c\\ \\delta(k), \\ \\ \\rightarrow \\ \\ \\phi(k) = -\\frac{c}{4\\pi}\\ \\delta(k)/k^2.\n\\] Oh fantastic. This means that if we Fourier transform the density, then multiply it with \\(-c/k^2\\) in Fourier space we already get the Fourier transformed potential. If we then just do the inverse Fourier transform back to real space we should have the correct potential we were looking for!\nThis may sound at first like a fairly complicated roundabaout way of getting at our problem. However, discrete Fourier transforms are only of complexity \\(log\\ N \\ \\ N\\) and some of the best optimized routines available on computers. So this can be an extraordinarily useful way of solving the Poisson equation in any dimension.\nThis is so elegant we just have to try it. Fortunately python makes this easy for us since it comes with Fourier transforms and helper functions included.\nThe conventions in numpy for the discrete Fourier transform are \\[\nA_k = \\sum_{m=0}^{N-1}\\ a_m\\ e^{-2\\pi\\ i\\ m\\ k/N}, \\ \\ k=0,1,...,n-2,n-1\n\\] and the inverse transform is given by \\[\na_m = \\frac{1}{N}\\sum_{m=0}^{n-1}\\ A_m\\ e^{2\\pi\\ i\\ m\\ k/N}\n\\] See the FFT documentation for more details.\n\n\n&lt;&gt;:25: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:28: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:29: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:25: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n&lt;&gt;:28: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n&lt;&gt;:29: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/450823216.py:25: SyntaxWarning:\n\ninvalid escape sequence '\\d'\n\n/tmp/ipykernel_2452/450823216.py:28: SyntaxWarning:\n\ninvalid escape sequence '\\P'\n\n/tmp/ipykernel_2452/450823216.py:29: SyntaxWarning:\n\ninvalid escape sequence '\\P'"
  },
  {
    "objectID": "tutorials/integrate-1D-poissonEquation.html#the-laplace-operator-in-spherical-coordinates",
    "href": "tutorials/integrate-1D-poissonEquation.html#the-laplace-operator-in-spherical-coordinates",
    "title": "Solving the Poisson Equation tutorial",
    "section": "The Laplace operator in spherical coordinates",
    "text": "The Laplace operator in spherical coordinates\nThe Laplace operator in spherical coordinates is: \\[\n\\begin{align}\n\\nabla^2 f &=& {1 \\over r^2}{\\partial \\over \\partial r}\\!\\left(r^2 {\\partial f \\over \\partial r}\\right)\n  \\!+\\!{1 \\over r^2\\!\\sin\\theta}{\\partial \\over \\partial \\theta}\\!\\left(\\sin\\theta {\\partial f \\over \\partial \\theta}\\right)\n  \\!+\\!{1 \\over r^2\\!\\sin^2\\theta}{\\partial^2 f \\over \\partial \\varphi^2}\n= \\\\\n& = &\\left(\\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r} \\frac{\\partial}{\\partial r}\\right)f \\!+\n{1 \\over r^2\\!\\sin\\theta}{\\partial \\over \\partial \\theta}\\!\\left(\\sin\\theta \\frac{\\partial}{\\partial \\theta}\\right)f +\\frac{1}{r^2\\!\\sin^2\\theta}\\frac{\\partial^2}{\\partial \\varphi^2}f.\n\\end{align}\n\\]\nHere we care only for the radial part: \\[\n\\nabla^2_r f =  {1 \\over r^2}{\\partial \\over \\partial r}\\!\\left(r^2 {\\partial f \\over \\partial r}\\right) = \\left(\\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r} \\frac{\\partial}{\\partial r}\\right)f\n\\] and also make note of the gradient in radial direction: \\[\n\\nabla_r\\ f = {\\partial f \\over \\partial r}\n\\]"
  },
  {
    "objectID": "tutorials/gala_tutorial.html",
    "href": "tutorials/gala_tutorial.html",
    "title": "gala tutorial",
    "section": "",
    "text": "Learning Outcomes\n\n\n\n\n\n\nGain familiarity with gala package\nExplore some static potentials of the MW\nDo some orbit integrations and get some first impressions\n\n\n\n\n\n\nCode\n# Orbits\nimport astropy.units as u\n#%matplotlib widget\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport gala.integrate as gi\nimport gala.dynamics as gd\nimport gala.potential as gp\nfrom gala.units import galactic\nimport plotly.graph_objects as go\n\nt_f = 4_000 # Myrs  # final time to integrate to\nn_steps = 4_000     # how many timesteps\ndt = t_f/n_steps\n\npot = gp.NFWPotential.from_circular_velocity(v_c=200*u.km/u.s,\n                                             r_s=10.*u.kpc,\n                                             units=galactic)\n\nmpot = gp.MilkyWayPotential()\n\nics = gd.PhaseSpacePosition(pos=[10,0,0.] * u.kpc,\n                            vel=[0,214,0] * u.km/u.s)\n#orbit = gp.Hamiltonian(pot).integrate_orbit(ics, dt=dt, n_steps=n_steps)\n\norbit = gp.Hamiltonian(pot).integrate_orbit(ics, dt=dt, n_steps=n_steps,\n                            Integrator=gi.DOPRI853Integrator)\n\nmorbit = gp.Hamiltonian(mpot).integrate_orbit(ics, dt=dt, n_steps=n_steps,\n                            Integrator=gi.DOPRI853Integrator)\n\n\n\n\nCode\ngrid = np.linspace(-15,15,64)\nfig,ax = plt.subplots(1, 1, figsize=(5,5))\nfig = pot.plot_contours(grid=(grid,grid,0), cmap='Greys', ax=ax)\nfig = orbit[:].plot(['x', 'y'], color='#9ecae1', alpha=0.35, axes=[ax], auto_aspect=False) \nfig = morbit[:].plot(['x', 'y'], color='#fecae1', alpha=0.35, axes=[ax], auto_aspect=False) \nplt.title(\"orbit\");\n\n\n\n\n\n\n\n\n\n\n\nCode\nnorbits = 128\nnp.random.seed(3)\nnew_pos = np.random.normal(ics.pos.xyz.to(u.pc).value, 100.,\n                           size=(norbits,3)).T * u.pc\nnew_vel = np.random.normal(ics.vel.d_xyz.to(u.km/u.s).value, 1.,\n                           size=(norbits,3)).T * u.km/u.s\nnew_ics = gd.PhaseSpacePosition(pos=new_pos, vel=new_vel)\norbits = gp.Hamiltonian(mpot).integrate_orbit(new_ics, dt=0.4, n_steps=10_000,\n                            Integrator=gi.DOPRI853Integrator)\n\n\n\n\nCode\ngrid = np.linspace(-15,15,64)\nfig,ax = plt.subplots(1, 1, figsize=(5,5))\nfig = pot.plot_contours(grid=(grid,grid,0), cmap='Greys', ax=ax)\nfig = orbits[0].plot(['x', 'y'], color='#9ecae1', s=3., alpha=0.5,\n                      axes=[ax], auto_aspect=False) \nplt.title(\"Initial distribution\");\n\n\n\n\n\n\n\n\n\n\n\nCode\ngrid = np.linspace(-15,15,64)\nfig,ax = plt.subplots(1, 1, figsize=(5,5))\nfig = pot.plot_contours(grid=(grid,grid,0), cmap='Greys', ax=ax)\nfig = orbits[-1].plot(['x', 'y'], color='#9ecae1', s=3., alpha=0.5,\n                      axes=[ax], auto_aspect=False) \nplt.title(\"final distribution\");\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport plotly.graph_objects as go\nfrom astropy import units as u\n\n# Subsample orbit data and convert units\nvorbits = orbits[::5]\nx, y, z = [getattr(vorbits, coord).to(u.kpc).value for coord in ['x', 'y', 'z']]\ntime = vorbits.t.to(u.Myr).value\n\n# Fixed camera view\ncamera = dict(eye=dict(x=1.2, y=1.2, z=1.2))\n\n# Create animation frames\nframes = [\n    go.Frame(\n        data=[\n            go.Scatter3d(\n                x=x[i], y=y[i], z=z[i],  # Current position\n                mode='markers',\n                marker=dict(color='blue', size=4,opacity=0.25)\n            )\n        ],\n        name=f\"Frame {i}\"\n    )\n    for i in range(len(time))\n]\n\n# Define the figure\nfig = go.Figure(\n    data=[\n        go.Scatter3d(x=x[0], y=y[0], z=z[0], mode='markers', marker=dict(color='blue', size=7))\n    ],\n    layout=dict(\n        title=\"Interactive Orbit Visualization\",\n        scene=dict(\n            xaxis=dict(title=\"X [kpc]\", range=[x.min(), x.max()]),\n            yaxis=dict(title=\"Y [kpc]\", range=[y.min(), y.max()]),\n            zaxis=dict(title=\"Z [kpc]\", range=[x.min(), x.max()]),\n            camera=camera\n        ),\n        updatemenus=[{\n            \"buttons\": [\n                {\"args\": [None, {\"frame\": {\"duration\": 50}, \"fromcurrent\": True}], \"label\": \"Play\", \"method\": \"animate\"},\n                {\"args\": [[None], {\"frame\": {\"duration\": 0}, \"mode\": \"immediate\"}], \"label\": \"Pause\", \"method\": \"animate\"}\n            ],\n            \"type\": \"buttons\",\n        }],\n        width=700,  # Make the plot area larger\n        height=900\n    ),\n    frames=frames\n)\n\n# Add slider\nfig.update_layout(\n    sliders=[{\n        \"steps\": [\n            {\n                \"args\": [[f.name], {\"frame\": {\"duration\": 0}, \"mode\": \"immediate\"}],\n                \"label\": f\"t={time[i]:.1f} Myr\",\n                \"method\": \"animate\"\n            }\n            for i, f in enumerate(frames)\n        ],\n        \"len\": 0.5,  # Half the slider width\n        \"currentvalue\": {\"prefix\": \"Time: \", \"font\": {\"size\": 14}},\n        \"pad\": {\"t\": 50}  # Adjust padding for compactness,\n    }]\n)\n\nfig.show()"
  },
  {
    "objectID": "assignments/assignment_1.html",
    "href": "assignments/assignment_1.html",
    "title": "Assignment 1",
    "section": "",
    "text": "One key aspect of all our work is that we communicate with a wide range of audiences our research methodology, our approach and our findings. These reports come in a wide range of formats as well. From talk slides, to research blogs, to popular science writing, to github repositories, to code pull requests, to research articles and even a PhD thesis. Very often this means that we have similar content but variations of our work. The same figures I made for my research paper are usually not adequate for a talk slide. We need larger fonts, more legible axes labels, titles, backgrounds, etc. The publications style, citations style, and style guidance all change depending on which journal we are writing for.\nSimilarly for our daily work flow, time management and project progress tracking we employ productivity hacks. We strive to get to know ourselves better and experiment with what works and what doesn’t. There are many ways to personalize how we approach tracking and keeping progress towards our goals.\nLast but not least we work a lot with code and data. Whether we are experimental, observational, theoretical, computational, historical, philosophical physicists, or any combination of those labels, chances are we are wrangling quite a bit of data, CAD files, survey data, telescope archives, simulation suites, to thesis mile-stones.\nIn this first assignment we are asking to describe a workflow that is helpful to these goals. I.e. how to best organize everything needed to write a successful thesis and the many other things related to it. The talk for the thesis defense, the qual exam, the assembly of the thesis. Make the assignment follow more the “do as I say, rather than do what I do” mantra. I.e. talk more about how you think it might best be done and how you might try to change your own workflow rather than describing parts that do not work to well. Let us know about any tools that are helping you and any tips you may have for using them. Nothing is too small a tip. Which keyboard shortcuts are your most useful ones?, what directory structure keeps things organized, what cloud-service / external hard-drives powers your backup strategy?, What web bookmarks are essential for a Physics PhD at Stanford? Which for research at KIPAC/SLAC?.\nHand in you personal take on this next week. This version can happily offer strong opinions. However, also already think about organizing yourself so you can turn all this eventually into a large shared document that can be helpful to all of us as a resource. For the larger resource we may tone down our strongest opinions. I would suggest a structure that separates the writing on publishing/authoring from time management, project tracking as well as from data wrangling and coding while at the same explicitly highlights the threads that connect these areas in as much as it makes sense in your approach.\nHand in your write up through Canvas."
  },
  {
    "objectID": "assignments/assignment_1.html#describe-your-workflow",
    "href": "assignments/assignment_1.html#describe-your-workflow",
    "title": "Assignment 1",
    "section": "",
    "text": "One key aspect of all our work is that we communicate with a wide range of audiences our research methodology, our approach and our findings. These reports come in a wide range of formats as well. From talk slides, to research blogs, to popular science writing, to github repositories, to code pull requests, to research articles and even a PhD thesis. Very often this means that we have similar content but variations of our work. The same figures I made for my research paper are usually not adequate for a talk slide. We need larger fonts, more legible axes labels, titles, backgrounds, etc. The publications style, citations style, and style guidance all change depending on which journal we are writing for.\nSimilarly for our daily work flow, time management and project progress tracking we employ productivity hacks. We strive to get to know ourselves better and experiment with what works and what doesn’t. There are many ways to personalize how we approach tracking and keeping progress towards our goals.\nLast but not least we work a lot with code and data. Whether we are experimental, observational, theoretical, computational, historical, philosophical physicists, or any combination of those labels, chances are we are wrangling quite a bit of data, CAD files, survey data, telescope archives, simulation suites, to thesis mile-stones.\nIn this first assignment we are asking to describe a workflow that is helpful to these goals. I.e. how to best organize everything needed to write a successful thesis and the many other things related to it. The talk for the thesis defense, the qual exam, the assembly of the thesis. Make the assignment follow more the “do as I say, rather than do what I do” mantra. I.e. talk more about how you think it might best be done and how you might try to change your own workflow rather than describing parts that do not work to well. Let us know about any tools that are helping you and any tips you may have for using them. Nothing is too small a tip. Which keyboard shortcuts are your most useful ones?, what directory structure keeps things organized, what cloud-service / external hard-drives powers your backup strategy?, What web bookmarks are essential for a Physics PhD at Stanford? Which for research at KIPAC/SLAC?.\nHand in you personal take on this next week. This version can happily offer strong opinions. However, also already think about organizing yourself so you can turn all this eventually into a large shared document that can be helpful to all of us as a resource. For the larger resource we may tone down our strongest opinions. I would suggest a structure that separates the writing on publishing/authoring from time management, project tracking as well as from data wrangling and coding while at the same explicitly highlights the threads that connect these areas in as much as it makes sense in your approach.\nHand in your write up through Canvas."
  },
  {
    "objectID": "assignments/assignment_1.html#install-gala-and-plotly-libraries-in-your-own-python-setup",
    "href": "assignments/assignment_1.html#install-gala-and-plotly-libraries-in-your-own-python-setup",
    "title": "Assignment 1",
    "section": "Install gala and plotly libraries in your own python setup",
    "text": "Install gala and plotly libraries in your own python setup\nWe will carry out a few galactic dynamics calculations using gala and visualize some of it with plotly. Make sure to install these before next class time on Thursday. Our setup python tutorial maybe helpful to you to get started."
  }
]