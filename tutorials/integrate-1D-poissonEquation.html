<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Solving the Poisson Equation tutorial</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-79108a0fc1995748cbd19a5b0e3e3e7c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../website/index.html"> 
<span class="menu-text">Physics 360: Modern Astrophysics</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-lectures" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Lectures</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-lectures">    
        <li>
    <a class="dropdown-item" href="../lectures/preliminaries.html">
 <span class="dropdown-text">Preliminaries</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/gravity.html">
 <span class="dropdown-text">Gravity</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="../tutorials/python_setup.html">
 <span class="dropdown-text">Setup python</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/gala_tutorial.html">
 <span class="dropdown-text">gala tutorial</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/integrate-1D-poissonEquation.html">
 <span class="dropdown-text">Poisson equation tutorial</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/Intro_3D_visualization.html">
 <span class="dropdown-text">3D vis tutorial</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/lagrangian-hydrodynamics.html">
 <span class="dropdown-text">Lagrangian Hydro</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/pyro_tutorial.html">
 <span class="dropdown-text">2D Hydro</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href=".././tutorials/plasma_pic_1d.ipynb">
 <span class="dropdown-text">1D PIC plasma code</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-assignments" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Assignments</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-assignments">    
        <li>
    <a class="dropdown-item" href="../assignments/assignment_1.html">
 <span class="dropdown-text">Workflow</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-final-project" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Final Project</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-final-project">    
        <li>
    <a class="dropdown-item" href="../final_project/project_ideas.html">
 <span class="dropdown-text">Project Suggestions</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/KIPAC/360"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Poisson equation tutorial</h2>
   
  <ul>
  <li><a href="#solving-the-poisson-equation-deltaphicrho" id="toc-solving-the-poisson-equation-deltaphicrho" class="nav-link active" data-scroll-target="#solving-the-poisson-equation-deltaphicrho">Solving the Poisson equation <span class="math inline">\(\Delta\Phi=C\rho\)</span></a>
  <ul class="collapse">
  <li><a href="#in-class-exercise" id="toc-in-class-exercise" class="nav-link" data-scroll-target="#in-class-exercise">In class Exercise</a></li>
  <li><a href="#using-relaxation" id="toc-using-relaxation" class="nav-link" data-scroll-target="#using-relaxation">Using relaxation</a></li>
  <li><a href="#using-successive-over-relaxation" id="toc-using-successive-over-relaxation" class="nav-link" data-scroll-target="#using-successive-over-relaxation">Using Successive Over Relaxation</a></li>
  <li><a href="#succesive-over-relaxation-with-red-black-ordering" id="toc-succesive-over-relaxation-with-red-black-ordering" class="nav-link" data-scroll-target="#succesive-over-relaxation-with-red-black-ordering">Succesive Over-Relaxation with Red Black Ordering</a></li>
  <li><a href="#recognizing-this-is-a-linear-algebra-problem" id="toc-recognizing-this-is-a-linear-algebra-problem" class="nav-link" data-scroll-target="#recognizing-this-is-a-linear-algebra-problem">Recognizing this is a linear algebra problem</a></li>
  <li><a href="#using-fast-fourier-transforms" id="toc-using-fast-fourier-transforms" class="nav-link" data-scroll-target="#using-fast-fourier-transforms">Using Fast Fourier Transforms</a></li>
  </ul></li>
  <li><a href="#the-conjugate-gradient-method" id="toc-the-conjugate-gradient-method" class="nav-link" data-scroll-target="#the-conjugate-gradient-method">The Conjugate Gradient Method</a>
  <ul class="collapse">
  <li><a href="#in-class-exercise-1" id="toc-in-class-exercise-1" class="nav-link" data-scroll-target="#in-class-exercise-1">In class Exercise:</a></li>
  <li><a href="#the-laplace-operator-in-spherical-coordinates" id="toc-the-laplace-operator-in-spherical-coordinates" class="nav-link" data-scroll-target="#the-laplace-operator-in-spherical-coordinates">The Laplace operator in spherical coordinates</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="integrate-1D-poissonEquation.ipynb" download="integrate-1D-poissonEquation.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Solving the Poisson Equation tutorial</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta column-page-left">

    
  
    
  </div>
  


</header>


<section id="solving-the-poisson-equation-deltaphicrho" class="level1">
<h1>Solving the Poisson equation <span class="math inline">\(\Delta\Phi=C\rho\)</span></h1>
<p>In physics we often write <span class="math inline">\(\nabla^2\)</span> instead of <span class="math inline">\(\Delta\)</span> but we mean the same thing, suming the second derivatives along each value.</p>
<p>Here we explore a solution strategy for the one dimensional Poisson equation. This is purely an example and most of the solution strategies will work for almost all second order partial differential equations. Let us first make the equation dimension-less. We can use the mean density <span class="math inline">\(\bar{\rho}=\int\rho dV/\int dV\)</span> to define the <b>overdensity</b> <span class="math display">\[D\equiv \frac{\rho}{\bar{\rho}}\]</span> and rescale the potential</p>
<p><span class="math display">\[
\tilde{\Phi}\equiv (C \bar{\rho} L^2)^{-1}\Phi
\]</span></p>
<p>which we can insert into the original equation <span class="math inline">\(\Delta \tilde{\Phi} C \bar{\rho} L^2 = C \rho\)</span> and get a new equation for <span class="math inline">\(\tilde{\Phi}\)</span>:</p>
<p><span class="math display">\[
L^{2}\Delta \tilde{\Phi} =  D.
\]</span></p>
<p><span class="math inline">\(L\)</span> is just a constant length. It could be just a typical length scale of the problem. This is now convenient as the over density is a nice dimensionless intuitively easy to grasp description of the density. Also all the length intervals we have in the problem as just measured in units of <span class="math inline">\(L\)</span> and once we have a solution we can use these relations to back out the SI/cgs values of the potential.</p>
<p>So let us also measure all distances in units of <span class="math inline">\(L\)</span> so we define <span class="math display">\[\tilde{x}\equiv x/L\]</span> and have <span class="math inline">\(d\tilde{x}/dx = 1/L\)</span></p>
<p>The Force is just <span class="math inline">\(-\nabla \tilde{\Phi}\)</span>, so in one dimension</p>
<p><span class="math display">\[
-\frac{\partial F}{\partial \tilde{x}} = D
\]</span></p>
<p>we now simply have</p>
<p><span class="math display">\[
F(X) = -\int_0^X D(\tilde{x}) d\tilde{x} + F(x=0),
\]</span></p>
<p>with the integration constant being recognized as <span class="math inline">\(F(x=0)\)</span> which must be obtained from a boundary condition. Its meaning is clear it is the Force at <span class="math inline">\(x=0\)</span>. Also the integral over the density on the right hand side has a simple meaning. It is the mass (charge) in the interval <span class="math inline">\([0..X]\)</span>. We also can see this from Gauss’ law that</p>
<p><span class="math display">\[
F(1)-F(0)= -\int_0^1 D(\tilde{x}) d\tilde{x}
\]</span></p>
<p>so that in a periodic domain where we have <span class="math inline">\(F(0)=F(1)\)</span> it follows that <span class="math inline">\(C_1 = F(0)\)</span>. The problem is though that a priori we do not know <span class="math inline">\(F(0)\)</span>. However, in the case where no external forces are applied the system must conserve momentum. I.e. the total momentum change must remain zero</p>
<p><span class="math display">\[
\int_0^1 \frac{dp}{dt} d\tilde{x} = \int_0^1 F(\tilde{x}) d\tilde{x} = 0
\]</span></p>
<p>So we have</p>
<p><span class="math display">\[
-\int_0^X \int_0^X D(\tilde{x})d\tilde{x} + X F(x=0) = 0
\]</span></p>
<p>so</p>
<p><span class="math display">\[
F(0) = -\int_0^1 \int_0^1 D(\tilde{x})d\tilde{x}  
\]</span></p>
<p>Integrating this once more and we get the Potential</p>
<p><span class="math display">\[
- \tilde{\Phi}(X) = \int_0^X F(\tilde{x}) d\tilde{x}  + C_2
\]</span></p>
<div id="2dafb527" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="2">
<div class="cell-output cell-output-stdout">
<pre><code>F(x=0) =  -0.07082481931956612</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-3-output-2.png" width="739" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="in-class-exercise" class="level3">
<h3 class="anchored" data-anchor-id="in-class-exercise">In class Exercise</h3>
<pre><code>- Calculate the potential and force in and around a homogeneous sphere reusing the numerical integration and differentiation as in the example above. 
- Have the sphere be at position x=0.4 and have a radius 0.025
- What did you notice about our assumption of periodic boundaries? How does the mean density enter?
- Plot it for the grid resolution 60 and 240
- Discuss the solution</code></pre>
<div id="78ca565c" class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>F(x=0) =  0.6019793898581776</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-4-output-2.png" width="730" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="using-relaxation" class="level2">
<h2 class="anchored" data-anchor-id="using-relaxation">Using relaxation</h2>
<p>The trick we just used above is only possible in one dimensions. In two or more the Poisson equation is essentially always a boundary value problem. I.e. we need to specify the values of <span class="math inline">\(\Phi\)</span> on the boundary and the interate to find a convergent solution. We introduce this style of solving it here next but stay in one dimensions to keep things simple at first. So we start out by discretizing the Poisson equation using the <a href="https://en.wikipedia.org/wiki/Numerical_differentiation">central difference</a> for the second derivative.</p>
<p><span class="math display">\[
\frac{1}{h^2} \left( \Phi_{i+1} + \Phi_{i-1} - 2\Phi_i \right) = C\ D(x_i)
\]</span></p>
<p>where we took the liberty and drop the ~ symbols for <span class="math inline">\(\tilde{\Phi}\)</span> and <span class="math inline">\(d\tilde{x}\)</span> while still working in these dimensionless quantities.</p>
<p>This gives us an obvious solution strategy. We just solve for <span class="math inline">\(\Phi_i\)</span> and remember to specify boundary values on the left and right so that the resulting formula is always defined. I.e.</p>
<p><span class="math display">\[
\Phi_i = \frac{1}{2}\left( \Phi_{i+1} + \Phi_{i-1} - C\ D(x_i)\ h^2 \right)
\]</span></p>
<p>For our first implementation we will assume periodic boundaries.</p>
<p>The overdensity <span class="math inline">\(D(x)\)</span> will be defined at cell centers and similarly <span class="math inline">\(\Phi\)</span> is recorded at the same positions.</p>
<div id="d492b6d0" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="4">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-5-output-1.png" width="739" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Wow. That takes an enormous amount of iterations to converge. In particular if the solution has long wavelength components. This method is known an <b>Jacobi’s iterative method</b>.</p>
<p>Ah yes. But we could use the update values as we march through. Perhaps that converges faster?</p>
<div id="aeea0927" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="5">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-6-output-1.png" width="739" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>That is indeed somewhat of an improvement. It is called the <b>Gauss Seidel</b> iteration.</p>
</section>
<section id="using-successive-over-relaxation" class="level2">
<h2 class="anchored" data-anchor-id="using-successive-over-relaxation">Using Successive Over Relaxation</h2>
<p>If we wouldn’ change the values completely just on the neighbors but keep some information from previous steps we can weight the update. This is known as successive over-relaxation. <span class="math display">\[
\Phi_i^{n+1} = (1-\omega)\ \Phi_i^n + \omega/2\ \left( \Phi^n_{i+1} + \Phi^n_{i-1} - c h^2 D \right),
\]</span> first for <span class="math inline">\(i=0,2,4,\cdots\)</span> and then for <span class="math inline">\(i=1,3,5,\cdots\)</span>. It is the same number of operations as before but does converge somewhat quicker.</p>
<div id="214f512f" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="6">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-7-output-1.png" width="739" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Ok. This is better! It, however, added another parameter which is left to the user to choose. It is only convergent in $ 0 &lt; w &lt; 2 $.</p>
</section>
<section id="succesive-over-relaxation-with-red-black-ordering" class="level2">
<h2 class="anchored" data-anchor-id="succesive-over-relaxation-with-red-black-ordering">Succesive Over-Relaxation with Red Black Ordering</h2>
<p>There is a variant of <b>Gauss Seidel</b> and succesive over-relaxation that is known as <b>red-black</b> ordering. This realizes that even positions are only dependent on odd neighbors and odd ones only on even. So first updates the one half and then the other. We do our SOR update <span class="math display">\[
\Phi_i^{n+1} = (1-\omega)\ \Phi_i^N + \omega/2\ \left( \Phi^n_{i+1} + \Phi^n_{i-1} - c h^2 D \right),
\]</span> first for <span class="math inline">\(i=0,2,4,\cdots\)</span> and then for <span class="math inline">\(i=1,3,5,\cdots\)</span>. It is the same number of operations as before but does converge somewhat quicker.</p>
<div id="042e3eea" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="7">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-8-output-1.png" width="739" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>This is indeed a further improvement.</p>
</section>
<section id="recognizing-this-is-a-linear-algebra-problem" class="level2">
<h2 class="anchored" data-anchor-id="recognizing-this-is-a-linear-algebra-problem">Recognizing this is a linear algebra problem</h2>
<p>Our discretization we used in the relaxation method can also be written in matrix form:</p>
<p><span class="math display">\[ A\ \Phi = h^2 C\ D =
\begin{pmatrix}
-2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 1 \\\\
1 &amp; -2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\\\
0 &amp; 1 &amp; -2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\\\
\vdots  &amp; \vdots  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots &amp; \vdots \\\\
0 &amp; 0 &amp; ... &amp; 0 &amp; 1 &amp; -2 &amp; 1 \\\\
1 &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; 1 &amp; -2
\end{pmatrix}
\
\begin{pmatrix}
\Phi_1 \\\\
\Phi_2 \\\\
\Phi_3 \\\\
\vdots \\\\
\Phi_{n-1} \\\\
\Phi_n
\end{pmatrix}
= h^2 C\
\begin{pmatrix}
D_1 \\\\
D_2 \\\\
D_3 \\\\
\vdots \\\\
D_{n-1} \\\\
D_n
\end{pmatrix}
\]</span></p>
<p>So in the relaxation technique we iterated until we got <span class="math inline">\(\Phi\)</span> to agree with this formula.</p>
<p>So let us define this Matrix:</p>
<div id="384c47f5" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="8">
<div class="cell-output cell-output-stdout">
<pre><code>[[-2.  1.  0. ...  0.  0.  1.]
 [ 1. -2.  1. ...  0.  0.  0.]
 [ 0.  1. -2. ...  0.  0.  0.]
 ...
 [ 0.  0.  0. ... -2.  1.  0.]
 [ 0.  0.  0. ...  1. -2.  1.]
 [ 1.  0.  0. ...  0.  1. -2.]]
Determinant of A is: 1.1147087742196166e-13</code></pre>
</div>
</div>
<p>and now invert it</p>
<div id="2441eb5b" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="9">
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>array([[ 1.   , -0.125, -0.125, ...,  0.   ,  0.   ,  0.   ],
       [ 0.   ,  1.   , -0.25 , ...,  0.   ,  0.   ,  0.   ],
       [-0.125, -0.125,  0.875, ...,  0.   ,  0.   ,  0.   ],
       ...,
       [-0.125,  0.   , -0.125, ...,  1.125,  0.   ,  0.   ],
       [ 0.   , -0.125, -0.125, ...,  0.125,  1.   ,  0.   ],
       [ 0.   , -0.125, -0.125, ...,  0.   ,  0.   ,  1.   ]])</code></pre>
</div>
</div>
<p>This did not work … It failed to correctly invert the matrix. I.e. we do not get identity matrix back when we multiply the original matrix and its supposed inverse. In hindsight we may have guessed that since the potential is not fixed up to a constant. So consequently the matrix has a determinant of zero and no unique solution is obtained.</p>
<p>However, we can add one row in which we set a constant <span class="math inline">\(\Phi\)</span> value. I.e.</p>
<p><span class="math display">\[ A\ \Phi = h^2 C\ D =
\begin{pmatrix}
-2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 1&amp; 0  \\\\
1 &amp; -2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0&amp; 0 \\\\
0 &amp; 1 &amp; -2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0&amp; 0 \\\\
\vdots  &amp; \vdots  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots &amp; \vdots \\\\
0 &amp; 0 &amp; ... &amp; 0 &amp; 1 &amp; -2 &amp; 1&amp; 0 \\\\
1 &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; 1 &amp; -2&amp; 0 \\\\
1 &amp; 1 &amp; 1 &amp; ... &amp; 1 &amp; 1 &amp; 1 &amp; 0
\end{pmatrix}
\
\begin{pmatrix}
\Phi_1 \\\\
\Phi_2 \\\\
\Phi_3 \\\\
\vdots \\\\
\Phi_{n-1} \\\\
\Phi_n \\\\
\Phi_{n+1}
\end{pmatrix}
= h^2 C\
\begin{pmatrix}
D_1 \\\\
D_2 \\\\
D_3 \\\\
\vdots \\\\
D_{n-1} \\\\
D_n \\\\
0
\end{pmatrix}
\]</span></p>
<p>Once we have the solution to <span class="math inline">\(\Phi\)</span> we throw away <span class="math inline">\(\Phi_{n+1}\)</span> and subtract the mean of the potential <span class="math inline">\(\int_0^1 \Phi dx\)</span> just by convention.</p>
<div id="ca0dfcf8" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="10">
<div class="cell-output cell-output-stdout">
<pre><code>[[ 5.55111512e-17  4.94444444e-01  9.77777778e-01 ...  9.77777778e-01
   4.94444444e-01  1.11111111e-02]
 [-5.55111512e-17 -4.94444444e-01 -1.66183640e-15 ...  9.55555556e-01
   4.83333333e-01  1.11111111e-02]
 [-1.66533454e-16 -4.83333333e-01 -9.77777778e-01 ...  9.33333333e-01
   4.72222222e-01  1.11111111e-02]
 ...
 [ 0.00000000e+00  4.72222222e-01  9.33333333e-01 ... -9.77777778e-01
  -4.83333333e-01  1.11111111e-02]
 [ 1.66533454e-16  4.83333333e-01  9.55555556e-01 ...  1.47945607e-15
  -4.94444444e-01  1.11111111e-02]
 [ 1.00000000e+00  1.48333333e+00  1.95555556e+00 ...  1.00000000e+00
   5.05555556e-01  1.11111111e-02]]
Determinant of the input matrix is : 8100.000000000035</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-11-output-2.png" width="739" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="ac572f96" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="11">
<div class="cell-output cell-output-stdout">
<pre><code>Determinant of A is: 8100.000000000035</code></pre>
</div>
</div>
<div id="6e509af7" class="cell" data-execution_count="12">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-13-output-1.png" width="726" height="485" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>So clearly all the matrix values are filled. This is now very similar to the <span class="math inline">\(N^2\)</span> operations we saw in the gravitational N-body problem. Every cell contibutes to the potential of every other cell and our matrix inversion gives the formula of how to do that.</p>
</section>
<section id="using-fast-fourier-transforms" class="level2">
<h2 class="anchored" data-anchor-id="using-fast-fourier-transforms">Using Fast Fourier Transforms</h2>
<p>Let us for a second though think of what would happen if we had the density and the potential given by their Fourier transforms. <span class="math display">\[
\Phi(x) =  \int \phi(k)\ e^{2\pi\ ikx} dk, \ \ D(x) =  \int \delta(k)\ e^{2\pi\ ikx} dk
\]</span> If we enter this in our starting equation <span class="math inline">\(\Delta \Phi=c\ D\)</span> we find that <span class="math display">\[
-4\pi\ k^2\phi(k) = c\ \delta(k), \ \ \rightarrow \ \ \phi(k) = -\frac{c}{4\pi}\ \delta(k)/k^2.
\]</span> Oh fantastic. This means that if we Fourier transform the density, then multiply it with <span class="math inline">\(-c/k^2\)</span> in Fourier space we already get the Fourier transformed potential. If we then just do the inverse Fourier transform back to real space we should have the correct potential we were looking for!</p>
<p>This may sound at first like a fairly complicated roundabaout way of getting at our problem. However, discrete Fourier transforms are only of complexity <span class="math inline">\(log\ N \ \ N\)</span> and some of the best optimized routines available on computers. So this can be an extraordinarily useful way of solving the Poisson equation in any dimension.</p>
<p>This is so elegant we just have to try it. Fortunately python makes this easy for us since it comes with Fourier transforms and helper functions included.</p>
<p>The conventions in numpy for the discrete Fourier transform are <span class="math display">\[
A_k = \sum_{m=0}^{N-1}\ a_m\ e^{-2\pi\ i\ m\ k/N}, \ \ k=0,1,...,n-2,n-1
\]</span> and the inverse transform is given by <span class="math display">\[
a_m = \frac{1}{N}\sum_{m=0}^{n-1}\ A_m\ e^{2\pi\ i\ m\ k/N}
\]</span> See the <a href="http://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" target="_blank">FFT documentation</a> for more details.</p>
<div id="247241ed" class="cell" data-execution_count="13">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-14-output-1.png" width="739" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="278e2347" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="14">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-15-output-1.png" width="715" height="485" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="the-conjugate-gradient-method" class="level1">
<h1>The Conjugate Gradient Method</h1>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/bf/Conjugate_gradient_illustration.svg" width="300" align="right"></p>
<p>The <a href="http://en.wikipedia.org/wiki/Conjugate_gradient_method">conjugate gradient method</a> is typically employed as an iterative approach to solving the linear equation</p>
<p><span class="math display">\[
\mathbf{A}\,\mathbf{x}=\mathbf{b}
\]</span></p>
<p>where <b>A</b> is a matrix and <b>x</b> and <b>b</b> are vectors.</p>
<p>So we want to find a good approximate solution <span class="math inline">\(\mathbf{x}_F\)</span>. We will want to start with a guess for <span class="math inline">\(x_0\)</span> and go through a number of iterations that we stop at <span class="math inline">\(\mathbf{x}_F\)</span> and call the intermediate results <span class="math inline">\(\mathbf{x}_k\)</span>.</p>
<p>For any guess <span class="math inline">\(\mathbf{x}_k\)</span> we can measure how far off from the correct solution we are</p>
<p><span class="math display">\[
\mathbf{r} = \mathbf{b} - \mathbf{A}\,\mathbf{x}.
\]</span></p>
<p><span class="math inline">\(\mathbf{r}\)</span> is called the <b>residual</b> (or residue) at the <span class="math inline">\(k\)</span>-th step.</p>
<p>If we now think of this quadratic equation:</p>
<p><span class="math display">\[
f(\mathbf{x}) = \frac12 \mathbf{x}^\mathrm{T} \mathbf{A}\mathbf{x} - \mathbf{x}^\mathrm{T} \mathbf{b} , \quad \mathbf{x}\in\mathbf{R}^n.
\]</span></p>
<p>we can see that <span class="math inline">\(-\mathbf{r}\)</span> is the gradient of <span class="math inline">\(f\)</span> at <span class="math inline">\(\mathbf{x}_k\)</span>. So to find an <span class="math inline">\(\mathbf{x}_F\)</span> for which <span class="math inline">\(\mathbf{r}\approx 0\)</span> is equivalent to finding the minimum of <span class="math inline">\(f\)</span>. There are methods which follow the steepest decent i.e.&nbsp;move along <span class="math inline">\(\mathbf{r}\)</span> to get towards the minimum. The trick in the conjugant gradient method is that it takes steps in orthogonal vectors to converge towards the minimum. The remarkable aspect of this algorithm is that it converges in at most <span class="math inline">\(n\)</span> steps where <span class="math inline">\(\mathbf{A}\)</span> is a <span class="math inline">\(n\times n\)</span> matrix.</p>
<p>So the key is to learn how to pick the search directions <span class="math inline">\(\mathbf{p}_k\)</span>. The most common choice here is to find vectors ortho-normal to the last residue so our quantities only depend on the last step taken and not say on a large number of previous steps.</p>
<p>For the first step we pick <span class="math inline">\(\mathbf{p}_0=\mathbf{r}_0=\mathbf{b}-\mathbf{A\,x}_0\)</span> as the search direction.</p>
<p>Let us pick</p>
<p><span class="math display">\[
\mathbf{x}_{k+1} = \mathbf{x}_k+\alpha_k\,\mathbf{p}_k,\ \ \ \  \alpha_k=\frac{\mathbf{r}^T_k \mathbf{r}_k}{\mathbf{p}_k^T\,\mathbf{A}\,\mathbf{p}_k}
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\mathbf{p}_{k+1} = \mathbf{r}_{k+1} + \beta_k \, \mathbf{p}_k, \ \ \ \ \beta = \frac{\mathbf{r}_{k+1}^T\, \mathbf{r}_{k+1}}{ \mathbf{r}_{k}^T \, \mathbf{r}_{k}}
\]</span></p>
<p>i.e.&nbsp;a combination of the current residual and the previous search direction, for the next search direction. Different conjugate gradient methods differ typically in their choice of <span class="math inline">\(\beta\)</span> and of how many previous search directions are considered. Please also have a look at <a href="http://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf">Jonathan Shewchuk’s fantastic detailed description</a> of this method.</p>
<div id="8cfb9dc3" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="15">
<div class="cell-output cell-output-stdout">
<pre><code>2.23606797749979 1e-10
iterated  6  times to get to tolerance= 1e-10
x= [0.09073552 0.63642149]</code></pre>
</div>
</div>
<p>Double check the Answer. Is <span class="math inline">\(\mathbf{A\,x}=\mathbf{b}\)</span> ?</p>
<div id="4c59aa0a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="16">
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>matrix([[5.40056888e-12],
        [3.98747702e-12]])</code></pre>
</div>
</div>
<div id="0ecb733f" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="17">
<div class="cell-output cell-output-stdout">
<pre><code>step: 1  distance to minimum: 0.4880232063220932
step: 2  distance to minimum: 0.00019970168811959504
step: 3  distance to minimum: 1.33331579273615e-05
step: 4  distance to minimum: 1.604829311924901e-08
step: 5  distance to minimum: 5.532337408608809e-10
step: 6  distance to minimum: 1.519990794322524e-12
step: 7  distance to minimum: 2.675290464622487e-14
step: 8  distance to minimum: 1.5362729766613488e-16</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-18-output-2.png" width="504" height="490" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="a365af2d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-execution_count="18">
<div class="cell-output cell-output-stdout">
<pre><code>F(x=0) =  -0.07086394966370409
8.122607918947157 0.1
iterated  56  times to get to tolerance= 0.1
8.122607918947157 0.0001
iterated  65  times to get to tolerance= 0.0001
8.122607918947157 1e-05
iterated  65  times to get to tolerance= 1e-05
8.122607918947157 1e-07
iterated  65  times to get to tolerance= 1e-07</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="integrate-1D-poissonEquation_files/figure-html/cell-19-output-2.png" width="553" height="434" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="in-class-exercise-1" class="level3">
<h3 class="anchored" data-anchor-id="in-class-exercise-1">In class Exercise:</h3>
<ul>
<li>Let’s see whether we can figure out how to use the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.cg.html">conjugate gradient method in scipy</a>.</li>
<li>Explore <a href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq">Best least square solution</a></li>
</ul>
</section>
<section id="the-laplace-operator-in-spherical-coordinates" class="level2">
<h2 class="anchored" data-anchor-id="the-laplace-operator-in-spherical-coordinates">The Laplace operator in spherical coordinates</h2>
<p>The Laplace operator in spherical coordinates is: <span class="math display">\[
\begin{align}
\nabla^2 f &amp;=&amp; {1 \over r^2}{\partial \over \partial r}\!\left(r^2 {\partial f \over \partial r}\right)
  \!+\!{1 \over r^2\!\sin\theta}{\partial \over \partial \theta}\!\left(\sin\theta {\partial f \over \partial \theta}\right)
  \!+\!{1 \over r^2\!\sin^2\theta}{\partial^2 f \over \partial \varphi^2}
= \\
&amp; = &amp;\left(\frac{\partial^2}{\partial r^2} + \frac{2}{r} \frac{\partial}{\partial r}\right)f \!+
{1 \over r^2\!\sin\theta}{\partial \over \partial \theta}\!\left(\sin\theta \frac{\partial}{\partial \theta}\right)f +\frac{1}{r^2\!\sin^2\theta}\frac{\partial^2}{\partial \varphi^2}f.
\end{align}
\]</span></p>
<p>Here we care only for the radial part: <span class="math display">\[
\nabla^2_r f =  {1 \over r^2}{\partial \over \partial r}\!\left(r^2 {\partial f \over \partial r}\right) = \left(\frac{\partial^2}{\partial r^2} + \frac{2}{r} \frac{\partial}{\partial r}\right)f
\]</span> and also make note of the gradient in radial direction: <span class="math display">\[
\nabla_r\ f = {\partial f \over \partial r}
\]</span></p>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/KIPAC\.github\.io\/360\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb12" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Solving the Poisson Equation tutorial</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">  echo: false</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: true</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools: true</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">    toc: true</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-title: Poisson equation tutorial</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">    page-layout: full</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co">    callout-icon: false</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co">  ipynb: default</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="fu"># Solving the Poisson equation $\Delta\Phi=C\rho$</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>In physics we often write $\nabla^2$ instead of $\Delta$ but we mean the same thing, suming the second derivatives along each value. </span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.integrate <span class="im">as</span> integrate</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'figure.figsize'</span>] <span class="op">=</span> (<span class="dv">9</span>, <span class="dv">6</span>)</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>Here we explore a solution strategy for the one dimensional Poisson equation. This is purely an example and most of the solution strategies will work for almost all second order partial differential equations. Let us first make the equation dimension-less. We can use the mean density $\bar{\rho}=\int\rho dV/\int dV$ to define the &lt;b&gt;overdensity&lt;/b&gt; $$D\equiv \frac{\rho}{\bar{\rho}}$$ and rescale the potential </span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>\tilde{\Phi}\equiv (C \bar{\rho} L^2)^{-1}\Phi</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>which we can insert into the original equation $\Delta \tilde{\Phi} C \bar{\rho} L^2 = C \rho$ and get a new equation for $\tilde{\Phi}$:</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>L^{2}\Delta \tilde{\Phi} =  D.</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>$L$ is just a constant length. It could be just a typical length scale of the problem. This is now convenient as the over density is a nice dimensionless intuitively easy to grasp description of the density. Also all the length intervals we have in the problem as just measured in units of $L$ and once we have a solution we can use these relations to back out the SI/cgs values of the potential. </span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>So let us also measure all distances in units of $L$ so we define </span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>$$\tilde{x}\equiv x/L$$ </span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>and have $d\tilde{x}/dx = 1/L$</span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>The Force is just $-\nabla \tilde{\Phi}$, so in one dimension </span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a>-\frac{\partial F}{\partial \tilde{x}} = D</span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a>we now simply have </span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true" tabindex="-1"></a>F(X) = -\int_0^X D(\tilde{x}) d\tilde{x} + F(x=0),</span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true" tabindex="-1"></a>with the integration constant being recognized as $F(x=0)$ which must be obtained from a boundary condition. Its meaning is clear it is the Force at $x=0$. </span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true" tabindex="-1"></a>Also the integral over the density on the right hand side has a simple meaning. It is the mass (charge) in the interval $<span class="co">[</span><span class="ot">0..X</span><span class="co">]</span>$.</span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true" tabindex="-1"></a>We also can see this from Gauss' law that </span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true" tabindex="-1"></a>F(1)-F(0)= -\int_0^1 D(\tilde{x}) d\tilde{x}</span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true" tabindex="-1"></a>so that in a periodic domain where we have $F(0)=F(1)$ it follows that $C_1 = F(0)$.</span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true" tabindex="-1"></a>The problem is though that a priori we do not know $F(0)$. However, in the case where no external forces are applied the system must conserve momentum. I.e. the total momentum change must remain zero </span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true" tabindex="-1"></a>\int_0^1 \frac{dp}{dt} d\tilde{x} = \int_0^1 F(\tilde{x}) d\tilde{x} = 0</span>
<span id="cb12-78"><a href="#cb12-78" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-79"><a href="#cb12-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-80"><a href="#cb12-80" aria-hidden="true" tabindex="-1"></a>So we have </span>
<span id="cb12-81"><a href="#cb12-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-82"><a href="#cb12-82" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-83"><a href="#cb12-83" aria-hidden="true" tabindex="-1"></a>-\int_0^X \int_0^X D(\tilde{x})d\tilde{x} + X F(x=0) = 0</span>
<span id="cb12-84"><a href="#cb12-84" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-85"><a href="#cb12-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-86"><a href="#cb12-86" aria-hidden="true" tabindex="-1"></a>so </span>
<span id="cb12-87"><a href="#cb12-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-88"><a href="#cb12-88" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-89"><a href="#cb12-89" aria-hidden="true" tabindex="-1"></a>F(0) = -\int_0^1 \int_0^1 D(\tilde{x})d\tilde{x}  </span>
<span id="cb12-90"><a href="#cb12-90" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-91"><a href="#cb12-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-92"><a href="#cb12-92" aria-hidden="true" tabindex="-1"></a>Integrating this once more and we get the Potential </span>
<span id="cb12-93"><a href="#cb12-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-94"><a href="#cb12-94" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-95"><a href="#cb12-95" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>\tilde{\Phi}(X) = \int_0^X F(\tilde{x}) d\tilde{x}  + C_2 </span>
<span id="cb12-96"><a href="#cb12-96" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-97"><a href="#cb12-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-100"><a href="#cb12-100" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-101"><a href="#cb12-101" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-102"><a href="#cb12-102" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-103"><a href="#cb12-103" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> density(x,k<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb12-104"><a href="#cb12-104" aria-hidden="true" tabindex="-1"></a>    phase <span class="op">=</span> <span class="fl">1.1</span></span>
<span id="cb12-105"><a href="#cb12-105" aria-hidden="true" tabindex="-1"></a>    od <span class="op">=</span> np.cos(k <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> math.pi <span class="op">*</span> x <span class="op">+</span> phase) <span class="co"># set up a periodic density</span></span>
<span id="cb12-106"><a href="#cb12-106" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> od</span>
<span id="cb12-107"><a href="#cb12-107" aria-hidden="true" tabindex="-1"></a><span class="co">#    dmean = integrate.simps(od,x=x)/1.   # mean density </span></span>
<span id="cb12-108"><a href="#cb12-108" aria-hidden="true" tabindex="-1"></a><span class="co">#    d = od - dmean # for periodic forces the mean of the right hand side needs to be zero</span></span>
<span id="cb12-109"><a href="#cb12-109" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb12-110"><a href="#cb12-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d</span>
<span id="cb12-111"><a href="#cb12-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-112"><a href="#cb12-112" aria-hidden="true" tabindex="-1"></a>N<span class="op">=</span><span class="dv">100</span></span>
<span id="cb12-113"><a href="#cb12-113" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,N) <span class="co"># uniform grid </span></span>
<span id="cb12-114"><a href="#cb12-114" aria-hidden="true" tabindex="-1"></a><span class="co">#x = np.insert(np.insert(sort(np.random.rand(N-2)),0,0),N-1,1) # non-uniform grid</span></span>
<span id="cb12-115"><a href="#cb12-115" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> density(x)</span>
<span id="cb12-116"><a href="#cb12-116" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-117"><a href="#cb12-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-118"><a href="#cb12-118" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="op">-</span>integrate.cumulative_trapezoid(c<span class="op">*</span>d,x<span class="op">=</span>x,initial<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-119"><a href="#cb12-119" aria-hidden="true" tabindex="-1"></a>F0 <span class="op">=</span> <span class="op">-</span>integrate.simpson(F,x<span class="op">=</span>x) <span class="co"># fix the force constant to keep momentum change=0</span></span>
<span id="cb12-120"><a href="#cb12-120" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'F(x=0) = '</span>, F0)</span>
<span id="cb12-121"><a href="#cb12-121" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> F <span class="op">+</span> F0</span>
<span id="cb12-122"><a href="#cb12-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-123"><a href="#cb12-123" aria-hidden="true" tabindex="-1"></a>Phi <span class="op">=</span> <span class="op">-</span>integrate.cumulative_trapezoid(F,x,initial<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-124"><a href="#cb12-124" aria-hidden="true" tabindex="-1"></a>Phi <span class="op">=</span> Phi <span class="op">-</span> integrate.simpson(Phi,x<span class="op">=</span>x)<span class="op">/</span><span class="fl">1.</span>    <span class="co"># set potential to mean</span></span>
<span id="cb12-125"><a href="#cb12-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-126"><a href="#cb12-126" aria-hidden="true" tabindex="-1"></a>plt.plot(x,d<span class="op">/</span>N,<span class="st">'x'</span>,label<span class="op">=</span><span class="st">"$\delta$"</span>)<span class="op">;</span></span>
<span id="cb12-127"><a href="#cb12-127" aria-hidden="true" tabindex="-1"></a>plt.plot(x,F,label<span class="op">=</span><span class="st">"Force"</span>)<span class="op">;</span></span>
<span id="cb12-128"><a href="#cb12-128" aria-hidden="true" tabindex="-1"></a>plt.plot(x,Phi,label<span class="op">=</span><span class="st">"$\Phi$"</span>)<span class="op">;</span></span>
<span id="cb12-129"><a href="#cb12-129" aria-hidden="true" tabindex="-1"></a>plt.plot(np.zeros(<span class="dv">2</span>))</span>
<span id="cb12-130"><a href="#cb12-130" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'position'</span>)</span>
<span id="cb12-131"><a href="#cb12-131" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Solution to the 1D Poisson equation'</span>)</span>
<span id="cb12-132"><a href="#cb12-132" aria-hidden="true" tabindex="-1"></a>plt.legend()<span class="op">;</span></span>
<span id="cb12-133"><a href="#cb12-133" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-134"><a href="#cb12-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-135"><a href="#cb12-135" aria-hidden="true" tabindex="-1"></a><span class="fu">### In class Exercise</span></span>
<span id="cb12-136"><a href="#cb12-136" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span>Calculate the potential and force in and around a homogeneous sphere reusing the numerical integration and differentiation as in the example above. </span>
<span id="cb12-137"><a href="#cb12-137" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span>Have the sphere be at position x=0.4 and have a radius 0.025</span>
<span id="cb12-138"><a href="#cb12-138" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span>What did you notice about our assumption of periodic boundaries? How does the mean density enter?</span>
<span id="cb12-139"><a href="#cb12-139" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span>Plot it for the grid resolution 60 and 240</span>
<span id="cb12-140"><a href="#cb12-140" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span>Discuss the solution</span>
<span id="cb12-141"><a href="#cb12-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-144"><a href="#cb12-144" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-145"><a href="#cb12-145" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mydensity(x,k<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb12-146"><a href="#cb12-146" aria-hidden="true" tabindex="-1"></a><span class="co">#    phase = 1.1</span></span>
<span id="cb12-147"><a href="#cb12-147" aria-hidden="true" tabindex="-1"></a><span class="co">#    od = np.cos(k * 2 * math.pi * x + phase) # set up a periodic density</span></span>
<span id="cb12-148"><a href="#cb12-148" aria-hidden="true" tabindex="-1"></a>    od <span class="op">=</span> np.ones_like(x)<span class="op">*</span><span class="dv">20</span></span>
<span id="cb12-149"><a href="#cb12-149" aria-hidden="true" tabindex="-1"></a>    od[np.<span class="bu">abs</span>((x <span class="op">-</span><span class="fl">0.4</span>)) <span class="op">&gt;</span> <span class="fl">0.025</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-150"><a href="#cb12-150" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> od</span>
<span id="cb12-151"><a href="#cb12-151" aria-hidden="true" tabindex="-1"></a><span class="co">#    dmean = integrate.simpson(od,x=x)/1.   # mean density </span></span>
<span id="cb12-152"><a href="#cb12-152" aria-hidden="true" tabindex="-1"></a><span class="co">#    d = od - dmean # for periodic forces the mean of the right hand side needs to be zero</span></span>
<span id="cb12-153"><a href="#cb12-153" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb12-154"><a href="#cb12-154" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d</span>
<span id="cb12-155"><a href="#cb12-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-156"><a href="#cb12-156" aria-hidden="true" tabindex="-1"></a>N<span class="op">=</span><span class="dv">100</span></span>
<span id="cb12-157"><a href="#cb12-157" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,N) <span class="co"># uniform grid </span></span>
<span id="cb12-158"><a href="#cb12-158" aria-hidden="true" tabindex="-1"></a><span class="co">#x = np.insert(np.insert(sort(np.random.rand(N-2)),0,0),N-1,1) # non-uniform grid</span></span>
<span id="cb12-159"><a href="#cb12-159" aria-hidden="true" tabindex="-1"></a>md <span class="op">=</span> mydensity(x)</span>
<span id="cb12-160"><a href="#cb12-160" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-161"><a href="#cb12-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-162"><a href="#cb12-162" aria-hidden="true" tabindex="-1"></a>mF <span class="op">=</span> <span class="op">-</span>integrate.cumulative_trapezoid(c<span class="op">*</span>md,x<span class="op">=</span>x,initial<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-163"><a href="#cb12-163" aria-hidden="true" tabindex="-1"></a>mF0 <span class="op">=</span> <span class="op">-</span>integrate.simpson(mF,x<span class="op">=</span>x) <span class="co"># fix the force constant to keep momentum change=0</span></span>
<span id="cb12-164"><a href="#cb12-164" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'F(x=0) = '</span>, mF0)</span>
<span id="cb12-165"><a href="#cb12-165" aria-hidden="true" tabindex="-1"></a>mF <span class="op">=</span> mF <span class="op">+</span> mF0</span>
<span id="cb12-166"><a href="#cb12-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-167"><a href="#cb12-167" aria-hidden="true" tabindex="-1"></a>mPhi <span class="op">=</span> <span class="op">-</span>integrate.cumulative_trapezoid(mF,x,initial<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-168"><a href="#cb12-168" aria-hidden="true" tabindex="-1"></a>mPhi <span class="op">=</span> mPhi <span class="op">-</span> integrate.simpson(mPhi,x<span class="op">=</span>x)<span class="op">/</span><span class="fl">1.</span>    <span class="co"># set potential to mean</span></span>
<span id="cb12-169"><a href="#cb12-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-170"><a href="#cb12-170" aria-hidden="true" tabindex="-1"></a>plt.plot(x,md<span class="op">/</span>N,<span class="st">'x'</span>,label<span class="op">=</span><span class="st">"$\delta$"</span>)<span class="op">;</span></span>
<span id="cb12-171"><a href="#cb12-171" aria-hidden="true" tabindex="-1"></a>plt.plot(x,mF,label<span class="op">=</span><span class="st">"Force"</span>)<span class="op">;</span></span>
<span id="cb12-172"><a href="#cb12-172" aria-hidden="true" tabindex="-1"></a>plt.plot(x,mPhi,label<span class="op">=</span><span class="st">"$\Phi$"</span>)<span class="op">;</span></span>
<span id="cb12-173"><a href="#cb12-173" aria-hidden="true" tabindex="-1"></a>plt.plot(np.zeros(<span class="dv">2</span>))</span>
<span id="cb12-174"><a href="#cb12-174" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'position'</span>)</span>
<span id="cb12-175"><a href="#cb12-175" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Solution to the 1D Poisson equation'</span>)</span>
<span id="cb12-176"><a href="#cb12-176" aria-hidden="true" tabindex="-1"></a>plt.legend()<span class="op">;</span></span>
<span id="cb12-177"><a href="#cb12-177" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-178"><a href="#cb12-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-179"><a href="#cb12-179" aria-hidden="true" tabindex="-1"></a><span class="fu">## Using relaxation</span></span>
<span id="cb12-180"><a href="#cb12-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-181"><a href="#cb12-181" aria-hidden="true" tabindex="-1"></a>The trick we just used above is only possible in one dimensions. In two or more the Poisson equation is essentially always a boundary value problem. I.e. we need to specify the values of $\Phi$ on the boundary and the interate to find a convergent solution. We introduce this style of solving it here next but stay in one dimensions to keep things simple at first. So we start out by discretizing the Poisson equation using the <span class="co">[</span><span class="ot">central difference</span><span class="co">](https://en.wikipedia.org/wiki/Numerical_differentiation)</span> for the second derivative. </span>
<span id="cb12-182"><a href="#cb12-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-183"><a href="#cb12-183" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-184"><a href="#cb12-184" aria-hidden="true" tabindex="-1"></a>\frac{1}{h^2} \left( \Phi_{i+1} + \Phi_{i-1} - 2\Phi_i \right) = C\ D(x_i)</span>
<span id="cb12-185"><a href="#cb12-185" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-186"><a href="#cb12-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-187"><a href="#cb12-187" aria-hidden="true" tabindex="-1"></a>where we took the liberty and drop the ~ symbols for $\tilde{\Phi}$ and $d\tilde{x}$ while still working in these dimensionless quantities.</span>
<span id="cb12-188"><a href="#cb12-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-189"><a href="#cb12-189" aria-hidden="true" tabindex="-1"></a>This gives us an obvious solution strategy. We just solve for $\Phi_i$ and remember to specify boundary values on the left and right so that the resulting formula is always defined. I.e.</span>
<span id="cb12-190"><a href="#cb12-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-191"><a href="#cb12-191" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-192"><a href="#cb12-192" aria-hidden="true" tabindex="-1"></a>\Phi_i = \frac{1}{2}\left( \Phi_{i+1} + \Phi_{i-1} - C\ D(x_i)\ h^2 \right) </span>
<span id="cb12-193"><a href="#cb12-193" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-194"><a href="#cb12-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-195"><a href="#cb12-195" aria-hidden="true" tabindex="-1"></a>For our first implementation we will assume periodic boundaries. </span>
<span id="cb12-196"><a href="#cb12-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-197"><a href="#cb12-197" aria-hidden="true" tabindex="-1"></a>The overdensity $D(x)$ will be defined at cell centers and similarly $\Phi$ is recorded at the same positions. </span>
<span id="cb12-198"><a href="#cb12-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-201"><a href="#cb12-201" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-202"><a href="#cb12-202" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-203"><a href="#cb12-203" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-204"><a href="#cb12-204" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">100</span> </span>
<span id="cb12-205"><a href="#cb12-205" aria-hidden="true" tabindex="-1"></a>rx <span class="op">=</span> (<span class="fl">0.5</span><span class="op">+</span>np.arange(N))<span class="op">/</span>N</span>
<span id="cb12-206"><a href="#cb12-206" aria-hidden="true" tabindex="-1"></a>rd <span class="op">=</span> density(rx)</span>
<span id="cb12-207"><a href="#cb12-207" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="fl">1.</span><span class="op">/</span>N</span>
<span id="cb12-208"><a href="#cb12-208" aria-hidden="true" tabindex="-1"></a>Niter <span class="op">=</span> <span class="dv">140</span></span>
<span id="cb12-209"><a href="#cb12-209" aria-hidden="true" tabindex="-1"></a>ip1 <span class="op">=</span> (np.arange(N) <span class="op">+</span> <span class="dv">1</span>) <span class="co"># define arrays that are the indeces i+1 and i-1</span></span>
<span id="cb12-210"><a href="#cb12-210" aria-hidden="true" tabindex="-1"></a>ip1[N<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-211"><a href="#cb12-211" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> (np.arange(N) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb12-212"><a href="#cb12-212" aria-hidden="true" tabindex="-1"></a>rPhi <span class="op">=</span> np.zeros(N,dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb12-213"><a href="#cb12-213" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(Niter):</span>
<span id="cb12-214"><a href="#cb12-214" aria-hidden="true" tabindex="-1"></a>    rPhi <span class="op">=</span> (rPhi[ip1]<span class="op">+</span>rPhi[im1] <span class="op">-</span> c<span class="op">*</span>rd<span class="op">*</span>dx<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="fl">2.</span></span>
<span id="cb12-215"><a href="#cb12-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-216"><a href="#cb12-216" aria-hidden="true" tabindex="-1"></a>rF <span class="op">=</span> <span class="op">-</span>(rPhi[ip1]<span class="op">-</span>rPhi[im1])<span class="op">/</span>(<span class="fl">2.</span><span class="op">*</span>dx)</span>
<span id="cb12-217"><a href="#cb12-217" aria-hidden="true" tabindex="-1"></a><span class="co"># show results</span></span>
<span id="cb12-218"><a href="#cb12-218" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,rd<span class="op">/</span>N,<span class="st">'x'</span>,label<span class="op">=</span><span class="st">"$\delta$"</span>)<span class="op">;</span></span>
<span id="cb12-219"><a href="#cb12-219" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,rF,label<span class="op">=</span><span class="st">"Force"</span>)<span class="op">;</span></span>
<span id="cb12-220"><a href="#cb12-220" aria-hidden="true" tabindex="-1"></a>plt.plot(x,F,<span class="st">':'</span>, label<span class="op">=</span><span class="st">"Force Ref."</span>)</span>
<span id="cb12-221"><a href="#cb12-221" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,rPhi,label<span class="op">=</span><span class="st">"$\Phi$"</span>)<span class="op">;</span></span>
<span id="cb12-222"><a href="#cb12-222" aria-hidden="true" tabindex="-1"></a>plt.plot(np.zeros(<span class="dv">2</span>))</span>
<span id="cb12-223"><a href="#cb12-223" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'position'</span>)</span>
<span id="cb12-224"><a href="#cb12-224" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Solution to the 1D Poisson equation using '</span><span class="op">+</span><span class="bu">str</span>(Niter)<span class="op">+</span><span class="st">' iterations'</span>)</span>
<span id="cb12-225"><a href="#cb12-225" aria-hidden="true" tabindex="-1"></a>leg<span class="op">=</span>plt.legend()<span class="op">;</span></span>
<span id="cb12-226"><a href="#cb12-226" aria-hidden="true" tabindex="-1"></a>leg.get_frame().set_alpha(<span class="fl">0.7</span>)</span>
<span id="cb12-227"><a href="#cb12-227" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-228"><a href="#cb12-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-229"><a href="#cb12-229" aria-hidden="true" tabindex="-1"></a>Wow. That takes an enormous amount of iterations to converge. In particular if the solution has long wavelength components. This method is known an &lt;b&gt;Jacobi's iterative method&lt;/b&gt;.</span>
<span id="cb12-230"><a href="#cb12-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-231"><a href="#cb12-231" aria-hidden="true" tabindex="-1"></a>Ah yes. But we could use the update values as we march through. Perhaps that converges faster?</span>
<span id="cb12-232"><a href="#cb12-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-235"><a href="#cb12-235" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-236"><a href="#cb12-236" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-237"><a href="#cb12-237" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-238"><a href="#cb12-238" aria-hidden="true" tabindex="-1"></a>rx <span class="op">=</span> (<span class="fl">0.5</span><span class="op">+</span>np.arange(N))<span class="op">/</span>N</span>
<span id="cb12-239"><a href="#cb12-239" aria-hidden="true" tabindex="-1"></a>rd <span class="op">=</span> density(rx)</span>
<span id="cb12-240"><a href="#cb12-240" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="fl">1.</span><span class="op">/</span>N</span>
<span id="cb12-241"><a href="#cb12-241" aria-hidden="true" tabindex="-1"></a>Niter <span class="op">=</span> <span class="dv">199</span></span>
<span id="cb12-242"><a href="#cb12-242" aria-hidden="true" tabindex="-1"></a>ip1 <span class="op">=</span> (np.arange(N) <span class="op">+</span> <span class="dv">1</span>) <span class="co"># define arrays that are the indeces i+1 and i-1</span></span>
<span id="cb12-243"><a href="#cb12-243" aria-hidden="true" tabindex="-1"></a>ip1[N<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-244"><a href="#cb12-244" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> (np.arange(N) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb12-245"><a href="#cb12-245" aria-hidden="true" tabindex="-1"></a>rPhi <span class="op">=</span> np.zeros(N,dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb12-246"><a href="#cb12-246" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> count <span class="kw">in</span> <span class="bu">range</span>(Niter):</span>
<span id="cb12-247"><a href="#cb12-247" aria-hidden="true" tabindex="-1"></a><span class="co">#    rPhi = (rPhi[ip1]+rPhi[im1] - c*rd*dx**2)/2.</span></span>
<span id="cb12-248"><a href="#cb12-248" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb12-249"><a href="#cb12-249" aria-hidden="true" tabindex="-1"></a>        rPhi[i] <span class="op">=</span> (rPhi[ip1[i]]<span class="op">+</span>rPhi[im1[i]] <span class="op">-</span> c<span class="op">*</span>rd[i]<span class="op">*</span>dx<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="fl">2.</span>    </span>
<span id="cb12-250"><a href="#cb12-250" aria-hidden="true" tabindex="-1"></a>rF <span class="op">=</span> <span class="op">-</span>(rPhi[ip1]<span class="op">-</span>rPhi[im1])<span class="op">/</span>(<span class="fl">2.</span><span class="op">*</span>dx)</span>
<span id="cb12-251"><a href="#cb12-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-252"><a href="#cb12-252" aria-hidden="true" tabindex="-1"></a><span class="co"># show results</span></span>
<span id="cb12-253"><a href="#cb12-253" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,rd<span class="op">/</span>N,<span class="st">'x'</span>,label<span class="op">=</span><span class="st">"$\delta$"</span>)<span class="op">;</span></span>
<span id="cb12-254"><a href="#cb12-254" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,rF,label<span class="op">=</span><span class="st">"Force"</span>)<span class="op">;</span></span>
<span id="cb12-255"><a href="#cb12-255" aria-hidden="true" tabindex="-1"></a>plt.plot(x,F,<span class="st">':'</span>, label<span class="op">=</span><span class="st">"Force Ref."</span>)</span>
<span id="cb12-256"><a href="#cb12-256" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,rPhi,label<span class="op">=</span><span class="st">"$\Phi$"</span>)<span class="op">;</span></span>
<span id="cb12-257"><a href="#cb12-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-258"><a href="#cb12-258" aria-hidden="true" tabindex="-1"></a>plt.plot(np.zeros(<span class="dv">2</span>))</span>
<span id="cb12-259"><a href="#cb12-259" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'position'</span>)</span>
<span id="cb12-260"><a href="#cb12-260" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Solution to the 1D Poisson equation using '</span><span class="op">+</span><span class="bu">str</span>(Niter)<span class="op">+</span><span class="st">' iterations'</span>)</span>
<span id="cb12-261"><a href="#cb12-261" aria-hidden="true" tabindex="-1"></a>leg<span class="op">=</span>plt.legend()<span class="op">;</span></span>
<span id="cb12-262"><a href="#cb12-262" aria-hidden="true" tabindex="-1"></a>leg.get_frame().set_alpha(<span class="fl">0.7</span>)</span>
<span id="cb12-263"><a href="#cb12-263" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-264"><a href="#cb12-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-265"><a href="#cb12-265" aria-hidden="true" tabindex="-1"></a>That is indeed somewhat of an improvement. It is called the &lt;b&gt;Gauss Seidel&lt;/b&gt; iteration. </span>
<span id="cb12-266"><a href="#cb12-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-267"><a href="#cb12-267" aria-hidden="true" tabindex="-1"></a><span class="fu">## Using Successive Over Relaxation</span></span>
<span id="cb12-268"><a href="#cb12-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-269"><a href="#cb12-269" aria-hidden="true" tabindex="-1"></a>If we wouldn' change the values completely just on the neighbors but keep some information from previous steps we can weight the update. This is known as successive over-relaxation. </span>
<span id="cb12-270"><a href="#cb12-270" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-271"><a href="#cb12-271" aria-hidden="true" tabindex="-1"></a>\Phi_i^{n+1} = (1-\omega)\ \Phi_i^n + \omega/2\ \left( \Phi^n_{i+1} + \Phi^n_{i-1} - c h^2 D \right),</span>
<span id="cb12-272"><a href="#cb12-272" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-273"><a href="#cb12-273" aria-hidden="true" tabindex="-1"></a>first for $i=0,2,4,\cdots$ and then for $i=1,3,5,\cdots$. It is the same number of operations as before but does converge somewhat quicker. </span>
<span id="cb12-274"><a href="#cb12-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-277"><a href="#cb12-277" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-278"><a href="#cb12-278" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-279"><a href="#cb12-279" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-280"><a href="#cb12-280" aria-hidden="true" tabindex="-1"></a>srx <span class="op">=</span> (<span class="fl">0.5</span><span class="op">+</span>np.arange(N))<span class="op">/</span>N</span>
<span id="cb12-281"><a href="#cb12-281" aria-hidden="true" tabindex="-1"></a>srd <span class="op">=</span> density(x)</span>
<span id="cb12-282"><a href="#cb12-282" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="fl">1.</span><span class="op">/</span>N</span>
<span id="cb12-283"><a href="#cb12-283" aria-hidden="true" tabindex="-1"></a>Niter <span class="op">=</span> <span class="dv">80</span></span>
<span id="cb12-284"><a href="#cb12-284" aria-hidden="true" tabindex="-1"></a>ip1 <span class="op">=</span> (np.arange(N) <span class="op">+</span> <span class="dv">1</span>) <span class="co"># define arrays that are the indeces i+1 and i-1</span></span>
<span id="cb12-285"><a href="#cb12-285" aria-hidden="true" tabindex="-1"></a>ip1[N<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-286"><a href="#cb12-286" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> (np.arange(N) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb12-287"><a href="#cb12-287" aria-hidden="true" tabindex="-1"></a>srPhi <span class="op">=</span> np.zeros(N,dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb12-288"><a href="#cb12-288" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="fl">1.8</span></span>
<span id="cb12-289"><a href="#cb12-289" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> count <span class="kw">in</span> <span class="bu">range</span>(Niter):</span>
<span id="cb12-290"><a href="#cb12-290" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb12-291"><a href="#cb12-291" aria-hidden="true" tabindex="-1"></a>        sigma <span class="op">=</span> srPhi[ip1[i]]<span class="op">+</span> srPhi[im1[i]]</span>
<span id="cb12-292"><a href="#cb12-292" aria-hidden="true" tabindex="-1"></a>        srPhi[i] <span class="op">=</span> (<span class="fl">1.</span><span class="op">-</span>w)<span class="op">*</span>srPhi[i] <span class="op">-</span> w<span class="op">/</span><span class="dv">2</span><span class="op">*</span>(c<span class="op">*</span>rd[i]<span class="op">*</span>dx<span class="op">**</span><span class="dv">2</span><span class="op">-</span>sigma)</span>
<span id="cb12-293"><a href="#cb12-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-294"><a href="#cb12-294" aria-hidden="true" tabindex="-1"></a>srF <span class="op">=</span> <span class="op">-</span>(srPhi[ip1]<span class="op">-</span>srPhi[im1])<span class="op">/</span>(<span class="fl">2.</span><span class="op">*</span>dx)</span>
<span id="cb12-295"><a href="#cb12-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-296"><a href="#cb12-296" aria-hidden="true" tabindex="-1"></a><span class="co"># show results</span></span>
<span id="cb12-297"><a href="#cb12-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-298"><a href="#cb12-298" aria-hidden="true" tabindex="-1"></a>plt.plot(srx,rd<span class="op">/</span>N,<span class="st">'x'</span>,label<span class="op">=</span><span class="st">"$\delta$"</span>)<span class="op">;</span></span>
<span id="cb12-299"><a href="#cb12-299" aria-hidden="true" tabindex="-1"></a>plt.plot(srx,srF,label<span class="op">=</span><span class="st">"Force"</span>)<span class="op">;</span></span>
<span id="cb12-300"><a href="#cb12-300" aria-hidden="true" tabindex="-1"></a>plt.plot(x,F,<span class="st">':'</span>, label<span class="op">=</span><span class="st">"Force Ref."</span>)</span>
<span id="cb12-301"><a href="#cb12-301" aria-hidden="true" tabindex="-1"></a>plt.plot(srx,srPhi,label<span class="op">=</span><span class="st">"$\Phi$"</span>)<span class="op">;</span></span>
<span id="cb12-302"><a href="#cb12-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-303"><a href="#cb12-303" aria-hidden="true" tabindex="-1"></a>plt.plot(np.zeros(<span class="dv">2</span>))</span>
<span id="cb12-304"><a href="#cb12-304" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'position'</span>)</span>
<span id="cb12-305"><a href="#cb12-305" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Solution to the 1D Poisson equation using '</span><span class="op">+</span><span class="bu">str</span>(Niter)<span class="op">+</span><span class="st">' iterations'</span>)</span>
<span id="cb12-306"><a href="#cb12-306" aria-hidden="true" tabindex="-1"></a>leg<span class="op">=</span>plt.legend()<span class="op">;</span></span>
<span id="cb12-307"><a href="#cb12-307" aria-hidden="true" tabindex="-1"></a>leg.get_frame().set_alpha(<span class="fl">0.7</span>)</span>
<span id="cb12-308"><a href="#cb12-308" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-309"><a href="#cb12-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-310"><a href="#cb12-310" aria-hidden="true" tabindex="-1"></a>Ok. This is better!  It, however, added another parameter which is left to the user to choose. It is only convergent in $ 0 &lt; w &lt; 2 $.</span>
<span id="cb12-311"><a href="#cb12-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-312"><a href="#cb12-312" aria-hidden="true" tabindex="-1"></a><span class="fu">## Succesive Over-Relaxation with Red Black Ordering</span></span>
<span id="cb12-313"><a href="#cb12-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-314"><a href="#cb12-314" aria-hidden="true" tabindex="-1"></a>There is a variant of &lt;b&gt;Gauss Seidel&lt;/b&gt; and succesive over-relaxation that is known as &lt;b&gt;red-black&lt;/b&gt; ordering. This realizes that even positions are only dependent on odd neighbors and odd ones only on even. So first updates the one half and then the other. We do our SOR update</span>
<span id="cb12-315"><a href="#cb12-315" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-316"><a href="#cb12-316" aria-hidden="true" tabindex="-1"></a>\Phi_i^{n+1} = (1-\omega)\ \Phi_i^N + \omega/2\ \left( \Phi^n_{i+1} + \Phi^n_{i-1} - c h^2 D \right),</span>
<span id="cb12-317"><a href="#cb12-317" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-318"><a href="#cb12-318" aria-hidden="true" tabindex="-1"></a>first for $i=0,2,4,\cdots$ and then for $i=1,3,5,\cdots$. It is the same number of operations as before but does converge somewhat quicker.</span>
<span id="cb12-319"><a href="#cb12-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-322"><a href="#cb12-322" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-323"><a href="#cb12-323" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-324"><a href="#cb12-324" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-325"><a href="#cb12-325" aria-hidden="true" tabindex="-1"></a>srx <span class="op">=</span> (<span class="fl">0.5</span><span class="op">+</span>np.arange(N))<span class="op">/</span>N</span>
<span id="cb12-326"><a href="#cb12-326" aria-hidden="true" tabindex="-1"></a>srd <span class="op">=</span> density(srx)</span>
<span id="cb12-327"><a href="#cb12-327" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="fl">1.</span><span class="op">/</span>N</span>
<span id="cb12-328"><a href="#cb12-328" aria-hidden="true" tabindex="-1"></a>Niter <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb12-329"><a href="#cb12-329" aria-hidden="true" tabindex="-1"></a>ip1 <span class="op">=</span> (np.arange(N) <span class="op">+</span> <span class="dv">1</span>) <span class="co"># define arrays that are the indeces i+1 and i-1</span></span>
<span id="cb12-330"><a href="#cb12-330" aria-hidden="true" tabindex="-1"></a>ip1[N<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-331"><a href="#cb12-331" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> (np.arange(N) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb12-332"><a href="#cb12-332" aria-hidden="true" tabindex="-1"></a>srPhi <span class="op">=</span> np.zeros(N,dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb12-333"><a href="#cb12-333" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="fl">1.8</span></span>
<span id="cb12-334"><a href="#cb12-334" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> count <span class="kw">in</span> <span class="bu">range</span>(Niter):</span>
<span id="cb12-335"><a href="#cb12-335" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,N,<span class="dv">2</span>):</span>
<span id="cb12-336"><a href="#cb12-336" aria-hidden="true" tabindex="-1"></a>        sigma <span class="op">=</span> srPhi[ip1[i]]<span class="op">+</span> srPhi[im1[i]]</span>
<span id="cb12-337"><a href="#cb12-337" aria-hidden="true" tabindex="-1"></a>        srPhi[i] <span class="op">=</span> (<span class="fl">1.</span><span class="op">-</span>w)<span class="op">*</span>srPhi[i] <span class="op">-</span> w<span class="op">/</span><span class="dv">2</span><span class="op">*</span>(c<span class="op">*</span>srd[i]<span class="op">*</span>dx<span class="op">**</span><span class="dv">2</span><span class="op">-</span>sigma)</span>
<span id="cb12-338"><a href="#cb12-338" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,N,<span class="dv">2</span>):</span>
<span id="cb12-339"><a href="#cb12-339" aria-hidden="true" tabindex="-1"></a>        sigma <span class="op">=</span> srPhi[ip1[i]]<span class="op">+</span> srPhi[im1[i]]</span>
<span id="cb12-340"><a href="#cb12-340" aria-hidden="true" tabindex="-1"></a>        srPhi[i] <span class="op">=</span> (<span class="fl">1.</span><span class="op">-</span>w)<span class="op">*</span>srPhi[i] <span class="op">-</span> w<span class="op">/</span><span class="dv">2</span><span class="op">*</span>(c<span class="op">*</span>srd[i]<span class="op">*</span>dx<span class="op">**</span><span class="dv">2</span><span class="op">-</span>sigma)</span>
<span id="cb12-341"><a href="#cb12-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-342"><a href="#cb12-342" aria-hidden="true" tabindex="-1"></a>srF <span class="op">=</span> <span class="op">-</span>(srPhi[ip1]<span class="op">-</span>srPhi[im1])<span class="op">/</span>(<span class="fl">2.</span><span class="op">*</span>dx)</span>
<span id="cb12-343"><a href="#cb12-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-344"><a href="#cb12-344" aria-hidden="true" tabindex="-1"></a><span class="co"># show results</span></span>
<span id="cb12-345"><a href="#cb12-345" aria-hidden="true" tabindex="-1"></a>plt.plot(srx,srd<span class="op">/</span>N,<span class="st">'x'</span>,label<span class="op">=</span><span class="st">"$\delta$"</span>)<span class="op">;</span></span>
<span id="cb12-346"><a href="#cb12-346" aria-hidden="true" tabindex="-1"></a>plt.plot(srx,srF,label<span class="op">=</span><span class="st">"Force"</span>)<span class="op">;</span></span>
<span id="cb12-347"><a href="#cb12-347" aria-hidden="true" tabindex="-1"></a>plt.plot(x,F,<span class="st">':'</span>, label<span class="op">=</span><span class="st">"Force Ref."</span>)</span>
<span id="cb12-348"><a href="#cb12-348" aria-hidden="true" tabindex="-1"></a>plt.plot(srx,srPhi,label<span class="op">=</span><span class="st">"$\Phi$"</span>)<span class="op">;</span></span>
<span id="cb12-349"><a href="#cb12-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-350"><a href="#cb12-350" aria-hidden="true" tabindex="-1"></a>plt.plot(x,Phi,<span class="st">':'</span>,label<span class="op">=</span><span class="st">"$\Phi$ Ref"</span>)<span class="op">;</span></span>
<span id="cb12-351"><a href="#cb12-351" aria-hidden="true" tabindex="-1"></a>plt.plot(np.zeros(<span class="dv">2</span>))</span>
<span id="cb12-352"><a href="#cb12-352" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'position'</span>)</span>
<span id="cb12-353"><a href="#cb12-353" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Solution to the 1D Poisson equation using '</span><span class="op">+</span><span class="bu">str</span>(Niter)<span class="op">+</span><span class="st">' iterations'</span>)</span>
<span id="cb12-354"><a href="#cb12-354" aria-hidden="true" tabindex="-1"></a>leg<span class="op">=</span>plt.legend()<span class="op">;</span></span>
<span id="cb12-355"><a href="#cb12-355" aria-hidden="true" tabindex="-1"></a>leg.get_frame().set_alpha(<span class="fl">0.7</span>)</span>
<span id="cb12-356"><a href="#cb12-356" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-357"><a href="#cb12-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-358"><a href="#cb12-358" aria-hidden="true" tabindex="-1"></a>This is indeed a further improvement. </span>
<span id="cb12-359"><a href="#cb12-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-360"><a href="#cb12-360" aria-hidden="true" tabindex="-1"></a><span class="fu">## Recognizing this is a linear algebra problem</span></span>
<span id="cb12-361"><a href="#cb12-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-362"><a href="#cb12-362" aria-hidden="true" tabindex="-1"></a>Our discretization we used in the relaxation method can also be written in matrix form:</span>
<span id="cb12-363"><a href="#cb12-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-364"><a href="#cb12-364" aria-hidden="true" tabindex="-1"></a>$$ A\ \Phi = h^2 C\ D = </span>
<span id="cb12-365"><a href="#cb12-365" aria-hidden="true" tabindex="-1"></a>\begin{pmatrix} </span>
<span id="cb12-366"><a href="#cb12-366" aria-hidden="true" tabindex="-1"></a>-2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 1 <span class="sc">\\\\</span> </span>
<span id="cb12-367"><a href="#cb12-367" aria-hidden="true" tabindex="-1"></a>1 &amp; -2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 <span class="sc">\\\\</span> </span>
<span id="cb12-368"><a href="#cb12-368" aria-hidden="true" tabindex="-1"></a>0 &amp; 1 &amp; -2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 <span class="sc">\\\\</span> </span>
<span id="cb12-369"><a href="#cb12-369" aria-hidden="true" tabindex="-1"></a>\vdots  &amp; \vdots  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots &amp; \vdots <span class="sc">\\\\</span> </span>
<span id="cb12-370"><a href="#cb12-370" aria-hidden="true" tabindex="-1"></a>0 &amp; 0 &amp; ... &amp; 0 &amp; 1 &amp; -2 &amp; 1 <span class="sc">\\\\</span> </span>
<span id="cb12-371"><a href="#cb12-371" aria-hidden="true" tabindex="-1"></a>1 &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; 1 &amp; -2 </span>
<span id="cb12-372"><a href="#cb12-372" aria-hidden="true" tabindex="-1"></a>\end{pmatrix}</span>
<span id="cb12-373"><a href="#cb12-373" aria-hidden="true" tabindex="-1"></a>\ </span>
<span id="cb12-374"><a href="#cb12-374" aria-hidden="true" tabindex="-1"></a>\begin{pmatrix} </span>
<span id="cb12-375"><a href="#cb12-375" aria-hidden="true" tabindex="-1"></a>\Phi_1 <span class="sc">\\\\</span></span>
<span id="cb12-376"><a href="#cb12-376" aria-hidden="true" tabindex="-1"></a>\Phi_2 <span class="sc">\\\\</span></span>
<span id="cb12-377"><a href="#cb12-377" aria-hidden="true" tabindex="-1"></a>\Phi_3 <span class="sc">\\\\</span></span>
<span id="cb12-378"><a href="#cb12-378" aria-hidden="true" tabindex="-1"></a>\vdots <span class="sc">\\\\</span></span>
<span id="cb12-379"><a href="#cb12-379" aria-hidden="true" tabindex="-1"></a>\Phi_{n-1} <span class="sc">\\\\</span></span>
<span id="cb12-380"><a href="#cb12-380" aria-hidden="true" tabindex="-1"></a>\Phi_n </span>
<span id="cb12-381"><a href="#cb12-381" aria-hidden="true" tabindex="-1"></a>\end{pmatrix}</span>
<span id="cb12-382"><a href="#cb12-382" aria-hidden="true" tabindex="-1"></a>= h^2 C\ </span>
<span id="cb12-383"><a href="#cb12-383" aria-hidden="true" tabindex="-1"></a>\begin{pmatrix} </span>
<span id="cb12-384"><a href="#cb12-384" aria-hidden="true" tabindex="-1"></a>D_1 <span class="sc">\\\\</span></span>
<span id="cb12-385"><a href="#cb12-385" aria-hidden="true" tabindex="-1"></a>D_2 <span class="sc">\\\\</span></span>
<span id="cb12-386"><a href="#cb12-386" aria-hidden="true" tabindex="-1"></a>D_3 <span class="sc">\\\\</span></span>
<span id="cb12-387"><a href="#cb12-387" aria-hidden="true" tabindex="-1"></a>\vdots <span class="sc">\\\\</span></span>
<span id="cb12-388"><a href="#cb12-388" aria-hidden="true" tabindex="-1"></a>D_{n-1} <span class="sc">\\\\</span></span>
<span id="cb12-389"><a href="#cb12-389" aria-hidden="true" tabindex="-1"></a>D_n</span>
<span id="cb12-390"><a href="#cb12-390" aria-hidden="true" tabindex="-1"></a>\end{pmatrix}</span>
<span id="cb12-391"><a href="#cb12-391" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-392"><a href="#cb12-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-393"><a href="#cb12-393" aria-hidden="true" tabindex="-1"></a>So in the relaxation technique we iterated until we got $\Phi$ to agree with this formula. </span>
<span id="cb12-394"><a href="#cb12-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-395"><a href="#cb12-395" aria-hidden="true" tabindex="-1"></a>So let us define this Matrix:</span>
<span id="cb12-396"><a href="#cb12-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-399"><a href="#cb12-399" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-400"><a href="#cb12-400" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-401"><a href="#cb12-401" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-402"><a href="#cb12-402" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> linalg</span>
<span id="cb12-403"><a href="#cb12-403" aria-hidden="true" tabindex="-1"></a><span class="co">#A = np.asmatrix(np.zeros((N,N))) # mat turns the numpy array into an object of matrix type</span></span>
<span id="cb12-404"><a href="#cb12-404" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> (np.zeros((N,N))) <span class="co"># numpy array  of matrix type</span></span>
<span id="cb12-405"><a href="#cb12-405" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(A)):</span>
<span id="cb12-406"><a href="#cb12-406" aria-hidden="true" tabindex="-1"></a>    A[i,i]<span class="op">=-</span><span class="dv">2</span></span>
<span id="cb12-407"><a href="#cb12-407" aria-hidden="true" tabindex="-1"></a>    A[i,im1[i]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-408"><a href="#cb12-408" aria-hidden="true" tabindex="-1"></a>    A[i,ip1[i]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-409"><a href="#cb12-409" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A.view())</span>
<span id="cb12-410"><a href="#cb12-410" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Determinant of A is:'</span>, linalg.det(A))</span>
<span id="cb12-411"><a href="#cb12-411" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-412"><a href="#cb12-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-413"><a href="#cb12-413" aria-hidden="true" tabindex="-1"></a>and now invert it</span>
<span id="cb12-414"><a href="#cb12-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-417"><a href="#cb12-417" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-418"><a href="#cb12-418" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-419"><a href="#cb12-419" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-420"><a href="#cb12-420" aria-hidden="true" tabindex="-1"></a>Am1 <span class="op">=</span> linalg.inv(A)</span>
<span id="cb12-421"><a href="#cb12-421" aria-hidden="true" tabindex="-1"></a>np.matmul(Am1,A)</span>
<span id="cb12-422"><a href="#cb12-422" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-423"><a href="#cb12-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-424"><a href="#cb12-424" aria-hidden="true" tabindex="-1"></a>This did not work ... It failed to correctly invert the matrix. I.e. we do not get identity matrix back when we multiply the original matrix and its supposed inverse. In hindsight we may have guessed that since the potential is not fixed up to a constant. So consequently the matrix has a determinant of zero and no unique solution is obtained. </span>
<span id="cb12-425"><a href="#cb12-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-426"><a href="#cb12-426" aria-hidden="true" tabindex="-1"></a>However, we can add one row in which we set a constant $\Phi$ value. I.e. </span>
<span id="cb12-427"><a href="#cb12-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-428"><a href="#cb12-428" aria-hidden="true" tabindex="-1"></a>$$ A\ \Phi = h^2 C\ D = </span>
<span id="cb12-429"><a href="#cb12-429" aria-hidden="true" tabindex="-1"></a>\begin{pmatrix} </span>
<span id="cb12-430"><a href="#cb12-430" aria-hidden="true" tabindex="-1"></a>-2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 1&amp; 0  <span class="sc">\\\\</span> </span>
<span id="cb12-431"><a href="#cb12-431" aria-hidden="true" tabindex="-1"></a>1 &amp; -2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0&amp; 0 <span class="sc">\\\\</span> </span>
<span id="cb12-432"><a href="#cb12-432" aria-hidden="true" tabindex="-1"></a>0 &amp; 1 &amp; -2 &amp; 1 &amp; 0 &amp; \cdots &amp; 0&amp; 0 <span class="sc">\\\\</span> </span>
<span id="cb12-433"><a href="#cb12-433" aria-hidden="true" tabindex="-1"></a>\vdots  &amp; \vdots  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots &amp; \vdots <span class="sc">\\\\</span> </span>
<span id="cb12-434"><a href="#cb12-434" aria-hidden="true" tabindex="-1"></a>0 &amp; 0 &amp; ... &amp; 0 &amp; 1 &amp; -2 &amp; 1&amp; 0 <span class="sc">\\\\</span> </span>
<span id="cb12-435"><a href="#cb12-435" aria-hidden="true" tabindex="-1"></a>1 &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; 1 &amp; -2&amp; 0 <span class="sc">\\\\</span></span>
<span id="cb12-436"><a href="#cb12-436" aria-hidden="true" tabindex="-1"></a>1 &amp; 1 &amp; 1 &amp; ... &amp; 1 &amp; 1 &amp; 1 &amp; 0 </span>
<span id="cb12-437"><a href="#cb12-437" aria-hidden="true" tabindex="-1"></a>\end{pmatrix}</span>
<span id="cb12-438"><a href="#cb12-438" aria-hidden="true" tabindex="-1"></a>\ </span>
<span id="cb12-439"><a href="#cb12-439" aria-hidden="true" tabindex="-1"></a>\begin{pmatrix} </span>
<span id="cb12-440"><a href="#cb12-440" aria-hidden="true" tabindex="-1"></a>\Phi_1 <span class="sc">\\\\</span></span>
<span id="cb12-441"><a href="#cb12-441" aria-hidden="true" tabindex="-1"></a>\Phi_2 <span class="sc">\\\\</span></span>
<span id="cb12-442"><a href="#cb12-442" aria-hidden="true" tabindex="-1"></a>\Phi_3 <span class="sc">\\\\</span></span>
<span id="cb12-443"><a href="#cb12-443" aria-hidden="true" tabindex="-1"></a>\vdots <span class="sc">\\\\</span></span>
<span id="cb12-444"><a href="#cb12-444" aria-hidden="true" tabindex="-1"></a>\Phi_{n-1} <span class="sc">\\\\</span></span>
<span id="cb12-445"><a href="#cb12-445" aria-hidden="true" tabindex="-1"></a>\Phi_n <span class="sc">\\\\</span></span>
<span id="cb12-446"><a href="#cb12-446" aria-hidden="true" tabindex="-1"></a>\Phi_{n+1} </span>
<span id="cb12-447"><a href="#cb12-447" aria-hidden="true" tabindex="-1"></a>\end{pmatrix}</span>
<span id="cb12-448"><a href="#cb12-448" aria-hidden="true" tabindex="-1"></a>= h^2 C\ </span>
<span id="cb12-449"><a href="#cb12-449" aria-hidden="true" tabindex="-1"></a>\begin{pmatrix} </span>
<span id="cb12-450"><a href="#cb12-450" aria-hidden="true" tabindex="-1"></a>D_1 <span class="sc">\\\\</span></span>
<span id="cb12-451"><a href="#cb12-451" aria-hidden="true" tabindex="-1"></a>D_2 <span class="sc">\\\\</span></span>
<span id="cb12-452"><a href="#cb12-452" aria-hidden="true" tabindex="-1"></a>D_3 <span class="sc">\\\\</span></span>
<span id="cb12-453"><a href="#cb12-453" aria-hidden="true" tabindex="-1"></a>\vdots <span class="sc">\\\\</span></span>
<span id="cb12-454"><a href="#cb12-454" aria-hidden="true" tabindex="-1"></a>D_{n-1} <span class="sc">\\\\</span></span>
<span id="cb12-455"><a href="#cb12-455" aria-hidden="true" tabindex="-1"></a>D_n <span class="sc">\\\\</span></span>
<span id="cb12-456"><a href="#cb12-456" aria-hidden="true" tabindex="-1"></a>0 </span>
<span id="cb12-457"><a href="#cb12-457" aria-hidden="true" tabindex="-1"></a>\end{pmatrix}</span>
<span id="cb12-458"><a href="#cb12-458" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-459"><a href="#cb12-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-460"><a href="#cb12-460" aria-hidden="true" tabindex="-1"></a>Once we have the solution to $\Phi$ we throw away $\Phi_{n+1}$ and subtract the mean of the potential $\int_0^1 \Phi dx$ just by convention.</span>
<span id="cb12-461"><a href="#cb12-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-464"><a href="#cb12-464" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-465"><a href="#cb12-465" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-466"><a href="#cb12-466" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-467"><a href="#cb12-467" aria-hidden="true" tabindex="-1"></a>N<span class="op">=</span><span class="dv">90</span></span>
<span id="cb12-468"><a href="#cb12-468" aria-hidden="true" tabindex="-1"></a>rx <span class="op">=</span> (<span class="fl">0.5</span><span class="op">+</span>np.arange(N))<span class="op">/</span>N</span>
<span id="cb12-469"><a href="#cb12-469" aria-hidden="true" tabindex="-1"></a>rd <span class="op">=</span> density(rx)</span>
<span id="cb12-470"><a href="#cb12-470" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="fl">1.</span><span class="op">/</span>N</span>
<span id="cb12-471"><a href="#cb12-471" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> (np.zeros((N<span class="op">+</span><span class="dv">1</span>,N<span class="op">+</span><span class="dv">1</span>))) <span class="co"># mat turns the numpy array into an object of matrix type</span></span>
<span id="cb12-472"><a href="#cb12-472" aria-hidden="true" tabindex="-1"></a>ip1 <span class="op">=</span> (np.arange(N) <span class="op">+</span> <span class="dv">1</span>) <span class="co"># define arrays that are the indeces i+1 and i-1</span></span>
<span id="cb12-473"><a href="#cb12-473" aria-hidden="true" tabindex="-1"></a>ip1[N<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-474"><a href="#cb12-474" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> (np.arange(N) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb12-475"><a href="#cb12-475" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(A)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb12-476"><a href="#cb12-476" aria-hidden="true" tabindex="-1"></a>    A[i,i]<span class="op">=-</span><span class="dv">2</span></span>
<span id="cb12-477"><a href="#cb12-477" aria-hidden="true" tabindex="-1"></a>    A[i,im1[i]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-478"><a href="#cb12-478" aria-hidden="true" tabindex="-1"></a>    A[i,ip1[i]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-479"><a href="#cb12-479" aria-hidden="true" tabindex="-1"></a>A[N,:<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-480"><a href="#cb12-480" aria-hidden="true" tabindex="-1"></a><span class="co">#A[0,-1] = 0</span></span>
<span id="cb12-481"><a href="#cb12-481" aria-hidden="true" tabindex="-1"></a><span class="co">#A[0,-2] = 1</span></span>
<span id="cb12-482"><a href="#cb12-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-483"><a href="#cb12-483" aria-hidden="true" tabindex="-1"></a>rd <span class="op">=</span> np.concatenate((rd, [<span class="fl">0.</span>]))</span>
<span id="cb12-484"><a href="#cb12-484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-485"><a href="#cb12-485" aria-hidden="true" tabindex="-1"></a>Am1 <span class="op">=</span> linalg.inv(A)</span>
<span id="cb12-486"><a href="#cb12-486" aria-hidden="true" tabindex="-1"></a>iPhi <span class="op">=</span> Am1<span class="op">*</span> np.asmatrix(rd).T <span class="op">*</span>c <span class="co"># *dx**2 let multiply this small number later</span></span>
<span id="cb12-487"><a href="#cb12-487" aria-hidden="true" tabindex="-1"></a>iPhi <span class="op">=</span> np.delete(np.ravel(iPhi), N)</span>
<span id="cb12-488"><a href="#cb12-488" aria-hidden="true" tabindex="-1"></a>iPhi <span class="op">*=</span> dx<span class="op">**</span><span class="dv">2</span></span>
<span id="cb12-489"><a href="#cb12-489" aria-hidden="true" tabindex="-1"></a>rd <span class="op">=</span> np.delete(rd,N)</span>
<span id="cb12-490"><a href="#cb12-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-491"><a href="#cb12-491" aria-hidden="true" tabindex="-1"></a><span class="co">#iPhi = iPhi - integrate.simpson(iPhi,x=rx)/1 # subtract mean as convention</span></span>
<span id="cb12-492"><a href="#cb12-492" aria-hidden="true" tabindex="-1"></a>iF <span class="op">=</span> <span class="op">-</span>(iPhi[ip1]<span class="op">-</span>iPhi[im1])<span class="op">/</span>(<span class="fl">2.</span><span class="op">*</span>dx)</span>
<span id="cb12-493"><a href="#cb12-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-494"><a href="#cb12-494" aria-hidden="true" tabindex="-1"></a><span class="co"># show results</span></span>
<span id="cb12-495"><a href="#cb12-495" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,rd<span class="op">/</span>N,<span class="st">'x'</span>,label<span class="op">=</span><span class="st">'$\delta$'</span>)<span class="op">;</span></span>
<span id="cb12-496"><a href="#cb12-496" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,iF, label<span class="op">=</span><span class="st">'F$_</span><span class="sc">{inv}</span><span class="st">$'</span>)<span class="op">;</span></span>
<span id="cb12-497"><a href="#cb12-497" aria-hidden="true" tabindex="-1"></a>plt.plot(x,F,<span class="st">':'</span>,label<span class="op">=</span><span class="st">'F$_</span><span class="sc">{ref}</span><span class="st">$'</span>)</span>
<span id="cb12-498"><a href="#cb12-498" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,iPhi,label<span class="op">=</span><span class="st">"$\Phi$"</span>)<span class="op">;</span></span>
<span id="cb12-499"><a href="#cb12-499" aria-hidden="true" tabindex="-1"></a>plt.plot(x,Phi,<span class="st">':'</span>, label<span class="op">=</span><span class="st">'$\Phi_</span><span class="sc">{ref}</span><span class="st">$'</span>)</span>
<span id="cb12-500"><a href="#cb12-500" aria-hidden="true" tabindex="-1"></a>plt.plot(np.zeros(<span class="dv">2</span>))</span>
<span id="cb12-501"><a href="#cb12-501" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'position'</span>)</span>
<span id="cb12-502"><a href="#cb12-502" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Solution to the 1D Poisson equation using matrix inversion'</span>)</span>
<span id="cb12-503"><a href="#cb12-503" aria-hidden="true" tabindex="-1"></a>leg <span class="op">=</span> plt.legend()<span class="op">;</span></span>
<span id="cb12-504"><a href="#cb12-504" aria-hidden="true" tabindex="-1"></a>leg.get_frame().set_alpha(<span class="fl">0.7</span>)</span>
<span id="cb12-505"><a href="#cb12-505" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Am1.view())</span>
<span id="cb12-506"><a href="#cb12-506" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Determinant of the input matrix is :'</span>, linalg.det(A))</span>
<span id="cb12-507"><a href="#cb12-507" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-508"><a href="#cb12-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-511"><a href="#cb12-511" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-512"><a href="#cb12-512" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-513"><a href="#cb12-513" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-514"><a href="#cb12-514" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Determinant of A is:'</span>, linalg.det(A))</span>
<span id="cb12-515"><a href="#cb12-515" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-516"><a href="#cb12-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-519"><a href="#cb12-519" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-520"><a href="#cb12-520" aria-hidden="true" tabindex="-1"></a>plt.plot(np.matmul(Am1[:,:<span class="op">-</span><span class="dv">1</span>], np.asmatrix(rd).T))</span>
<span id="cb12-521"><a href="#cb12-521" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-522"><a href="#cb12-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-523"><a href="#cb12-523" aria-hidden="true" tabindex="-1"></a>So clearly all the matrix values are filled. This is now very similar to the $N^2$ operations we saw in the gravitational N-body problem. Every cell contibutes to the potential of every other cell and our matrix inversion gives the formula of how to do that. </span>
<span id="cb12-524"><a href="#cb12-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-525"><a href="#cb12-525" aria-hidden="true" tabindex="-1"></a><span class="fu">## Using Fast Fourier Transforms</span></span>
<span id="cb12-526"><a href="#cb12-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-527"><a href="#cb12-527" aria-hidden="true" tabindex="-1"></a>Let us for a second though think of what would happen if we had the density and the potential given by their Fourier transforms. </span>
<span id="cb12-528"><a href="#cb12-528" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-529"><a href="#cb12-529" aria-hidden="true" tabindex="-1"></a>\Phi(x) =  \int \phi(k)\ e^{2\pi\ ikx} dk, \ \ D(x) =  \int \delta(k)\ e^{2\pi\ ikx} dk</span>
<span id="cb12-530"><a href="#cb12-530" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-531"><a href="#cb12-531" aria-hidden="true" tabindex="-1"></a>If we enter this in our starting equation $\Delta \Phi=c\ D$ we find that</span>
<span id="cb12-532"><a href="#cb12-532" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-533"><a href="#cb12-533" aria-hidden="true" tabindex="-1"></a>-4\pi\ k^2\phi(k) = c\ \delta(k), \ \ \rightarrow \ \ \phi(k) = -\frac{c}{4\pi}\ \delta(k)/k^2.</span>
<span id="cb12-534"><a href="#cb12-534" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-535"><a href="#cb12-535" aria-hidden="true" tabindex="-1"></a>Oh fantastic. This means that if we Fourier transform the density, then multiply it with $-c/k^2$ in Fourier space we already get the Fourier transformed potential. If we then just do the inverse Fourier transform back to real space we should have the correct potential we were looking for! </span>
<span id="cb12-536"><a href="#cb12-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-537"><a href="#cb12-537" aria-hidden="true" tabindex="-1"></a>This may sound at first like a fairly complicated roundabaout way of getting at our problem. However, discrete Fourier transforms are only of complexity $log\ N \ \ N$ and some of the best optimized routines available on computers. So this can be an extraordinarily useful way of solving the Poisson equation in any dimension. </span>
<span id="cb12-538"><a href="#cb12-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-539"><a href="#cb12-539" aria-hidden="true" tabindex="-1"></a>This is so elegant we just have to try it. Fortunately python makes this easy for us since it comes with Fourier transforms and helper functions included. </span>
<span id="cb12-540"><a href="#cb12-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-541"><a href="#cb12-541" aria-hidden="true" tabindex="-1"></a>The conventions in numpy for the discrete Fourier transform are</span>
<span id="cb12-542"><a href="#cb12-542" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-543"><a href="#cb12-543" aria-hidden="true" tabindex="-1"></a>A_k = \sum_{m=0}^{N-1}\ a_m\ e^{-2\pi\ i\ m\ k/N}, \ \ k=0,1,...,n-2,n-1</span>
<span id="cb12-544"><a href="#cb12-544" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-545"><a href="#cb12-545" aria-hidden="true" tabindex="-1"></a>and the inverse transform is given by</span>
<span id="cb12-546"><a href="#cb12-546" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-547"><a href="#cb12-547" aria-hidden="true" tabindex="-1"></a>a_m = \frac{1}{N}\sum_{m=0}^{n-1}\ A_m\ e^{2\pi\ i\ m\ k/N}</span>
<span id="cb12-548"><a href="#cb12-548" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-549"><a href="#cb12-549" aria-hidden="true" tabindex="-1"></a>See the &lt;A href="http://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" target="_blank"&gt;FFT documentation&lt;/A&gt; for more details.</span>
<span id="cb12-550"><a href="#cb12-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-553"><a href="#cb12-553" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-554"><a href="#cb12-554" aria-hidden="true" tabindex="-1"></a>N<span class="op">=</span><span class="dv">90</span></span>
<span id="cb12-555"><a href="#cb12-555" aria-hidden="true" tabindex="-1"></a>fx <span class="op">=</span> (np.arange(N)<span class="op">+</span><span class="fl">0.5</span>)<span class="op">/</span>N</span>
<span id="cb12-556"><a href="#cb12-556" aria-hidden="true" tabindex="-1"></a>fd <span class="op">=</span> density(fx)</span>
<span id="cb12-557"><a href="#cb12-557" aria-hidden="true" tabindex="-1"></a><span class="co">#fd=fd-fd.mean() # the mean has to be perfectly zero</span></span>
<span id="cb12-558"><a href="#cb12-558" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="fl">1.</span><span class="op">/</span>N</span>
<span id="cb12-559"><a href="#cb12-559" aria-hidden="true" tabindex="-1"></a>lphi <span class="op">=</span> np.zeros(N<span class="op">//</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span>,dtype<span class="op">=</span><span class="bu">complex</span>)</span>
<span id="cb12-560"><a href="#cb12-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-561"><a href="#cb12-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-562"><a href="#cb12-562" aria-hidden="true" tabindex="-1"></a>delta <span class="op">=</span> np.fft.rfft(fd)      <span class="co"># forward transform of density</span></span>
<span id="cb12-563"><a href="#cb12-563" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>np.fft.rfftfreq(<span class="bu">len</span>(fd),dx) <span class="co"># returns the wave numbers </span></span>
<span id="cb12-564"><a href="#cb12-564" aria-hidden="true" tabindex="-1"></a>lphi[<span class="dv">1</span>:] <span class="op">=</span> ((<span class="op">-</span>c<span class="op">*</span>delta[<span class="dv">1</span>:] <span class="op">/</span>k[<span class="dv">1</span>:]<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb12-565"><a href="#cb12-565" aria-hidden="true" tabindex="-1"></a>lphi[<span class="dv">0</span>] <span class="op">=</span> <span class="fl">0.</span>  </span>
<span id="cb12-566"><a href="#cb12-566" aria-hidden="true" tabindex="-1"></a>fPhi <span class="op">=</span> (np.fft.irfft(lphi)).real </span>
<span id="cb12-567"><a href="#cb12-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-568"><a href="#cb12-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-569"><a href="#cb12-569" aria-hidden="true" tabindex="-1"></a>na <span class="op">=</span> np.arange(N)</span>
<span id="cb12-570"><a href="#cb12-570" aria-hidden="true" tabindex="-1"></a>ip1 <span class="op">=</span> na.take(np.arange(N)<span class="op">+</span><span class="dv">1</span>, axis<span class="op">=</span><span class="dv">0</span>, mode<span class="op">=</span><span class="st">'wrap'</span>)</span>
<span id="cb12-571"><a href="#cb12-571" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> na.take(np.arange(N)<span class="op">-</span><span class="dv">1</span>, axis<span class="op">=</span><span class="dv">0</span>, mode<span class="op">=</span><span class="st">'wrap'</span>)</span>
<span id="cb12-572"><a href="#cb12-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-573"><a href="#cb12-573" aria-hidden="true" tabindex="-1"></a>fF <span class="op">=</span> <span class="op">-</span>(fPhi[ip1]<span class="op">-</span>fPhi[im1])<span class="op">/</span>(<span class="fl">2.</span><span class="op">*</span>dx)  <span class="co"># central difference</span></span>
<span id="cb12-574"><a href="#cb12-574" aria-hidden="true" tabindex="-1"></a><span class="co">#fF = -np.gradient(fPhi,dx)</span></span>
<span id="cb12-575"><a href="#cb12-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-576"><a href="#cb12-576" aria-hidden="true" tabindex="-1"></a><span class="co"># show results</span></span>
<span id="cb12-577"><a href="#cb12-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-578"><a href="#cb12-578" aria-hidden="true" tabindex="-1"></a>plt.plot(fx,fd<span class="op">/</span>N,<span class="st">'x'</span>,label<span class="op">=</span><span class="st">'$\delta$'</span>)<span class="op">;</span></span>
<span id="cb12-579"><a href="#cb12-579" aria-hidden="true" tabindex="-1"></a>plt.plot(fx,fF, label<span class="op">=</span><span class="st">'F$_</span><span class="sc">{fft}</span><span class="st">$'</span>)<span class="op">;</span></span>
<span id="cb12-580"><a href="#cb12-580" aria-hidden="true" tabindex="-1"></a>plt.plot(x,F,<span class="st">':'</span>,label<span class="op">=</span><span class="st">'F$_</span><span class="sc">{ref}</span><span class="st">$'</span>)</span>
<span id="cb12-581"><a href="#cb12-581" aria-hidden="true" tabindex="-1"></a>plt.plot(fx,fPhi,label<span class="op">=</span><span class="st">"$\Phi$"</span>)<span class="op">;</span></span>
<span id="cb12-582"><a href="#cb12-582" aria-hidden="true" tabindex="-1"></a>plt.plot(x,Phi,<span class="st">':'</span>, label<span class="op">=</span><span class="st">'$\Phi_</span><span class="sc">{ref}</span><span class="st">$'</span>)</span>
<span id="cb12-583"><a href="#cb12-583" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-584"><a href="#cb12-584" aria-hidden="true" tabindex="-1"></a>plt.plot(np.zeros(<span class="dv">2</span>))</span>
<span id="cb12-585"><a href="#cb12-585" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'position'</span>)</span>
<span id="cb12-586"><a href="#cb12-586" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Solution to the 1D Poisson equation using FFTs'</span>)</span>
<span id="cb12-587"><a href="#cb12-587" aria-hidden="true" tabindex="-1"></a>leg <span class="op">=</span> plt.legend()<span class="op">;</span></span>
<span id="cb12-588"><a href="#cb12-588" aria-hidden="true" tabindex="-1"></a>leg.get_frame().set_alpha(<span class="fl">0.7</span>)</span>
<span id="cb12-589"><a href="#cb12-589" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-590"><a href="#cb12-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-593"><a href="#cb12-593" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-594"><a href="#cb12-594" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-595"><a href="#cb12-595" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-596"><a href="#cb12-596" aria-hidden="true" tabindex="-1"></a>plt.plot(k,delta.real,<span class="st">'x'</span>)</span>
<span id="cb12-597"><a href="#cb12-597" aria-hidden="true" tabindex="-1"></a>plt.plot(k,delta.imag,<span class="st">'x'</span>)<span class="op">;</span></span>
<span id="cb12-598"><a href="#cb12-598" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-599"><a href="#cb12-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-600"><a href="#cb12-600" aria-hidden="true" tabindex="-1"></a><span class="fu"># The Conjugate Gradient Method </span></span>
<span id="cb12-601"><a href="#cb12-601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-602"><a href="#cb12-602" aria-hidden="true" tabindex="-1"></a>&lt;img src="http://upload.wikimedia.org/wikipedia/commons/b/bf/Conjugate_gradient_illustration.svg" width="300" align="right"&gt; </span>
<span id="cb12-603"><a href="#cb12-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-604"><a href="#cb12-604" aria-hidden="true" tabindex="-1"></a>The &lt;a href="http://en.wikipedia.org/wiki/Conjugate_gradient_method"&gt;conjugate gradient method&lt;/a&gt; is typically employed as an iterative approach to solving the linear equation</span>
<span id="cb12-605"><a href="#cb12-605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-606"><a href="#cb12-606" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-607"><a href="#cb12-607" aria-hidden="true" tabindex="-1"></a>\mathbf{A}\,\mathbf{x}=\mathbf{b}</span>
<span id="cb12-608"><a href="#cb12-608" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-609"><a href="#cb12-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-610"><a href="#cb12-610" aria-hidden="true" tabindex="-1"></a>where &lt;b&gt;A&lt;/b&gt; is a matrix and &lt;b&gt;x&lt;/b&gt; and &lt;b&gt;b&lt;/b&gt; are vectors. </span>
<span id="cb12-611"><a href="#cb12-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-612"><a href="#cb12-612" aria-hidden="true" tabindex="-1"></a>So we want to find a good approximate solution $\mathbf{x}_F$. </span>
<span id="cb12-613"><a href="#cb12-613" aria-hidden="true" tabindex="-1"></a>We will want to start with a guess for $x_0$ and go through a number of iterations that we stop at $\mathbf{x}_F$ and call the intermediate results $\mathbf{x}_k$. </span>
<span id="cb12-614"><a href="#cb12-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-615"><a href="#cb12-615" aria-hidden="true" tabindex="-1"></a>For any guess $\mathbf{x}_k$ we can measure how far off from the correct solution we are</span>
<span id="cb12-616"><a href="#cb12-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-617"><a href="#cb12-617" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-618"><a href="#cb12-618" aria-hidden="true" tabindex="-1"></a>\mathbf{r} = \mathbf{b} - \mathbf{A}\,\mathbf{x}.</span>
<span id="cb12-619"><a href="#cb12-619" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb12-620"><a href="#cb12-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-621"><a href="#cb12-621" aria-hidden="true" tabindex="-1"></a>$\mathbf{r}$ is called the &lt;b&gt;residual&lt;/b&gt; (or residue) at the $k$-th step. </span>
<span id="cb12-622"><a href="#cb12-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-623"><a href="#cb12-623" aria-hidden="true" tabindex="-1"></a>If we now think of this quadratic equation:</span>
<span id="cb12-624"><a href="#cb12-624" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-625"><a href="#cb12-625" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-626"><a href="#cb12-626" aria-hidden="true" tabindex="-1"></a>f(\mathbf{x}) = \frac12 \mathbf{x}^\mathrm{T} \mathbf{A}\mathbf{x} - \mathbf{x}^\mathrm{T} \mathbf{b} , \quad \mathbf{x}\in\mathbf{R}^n. </span>
<span id="cb12-627"><a href="#cb12-627" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-628"><a href="#cb12-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-629"><a href="#cb12-629" aria-hidden="true" tabindex="-1"></a>we can see that $-\mathbf{r}$ is the gradient of $f$ at $\mathbf{x}_k$. So to find an $\mathbf{x}_F$ for which $\mathbf{r}\approx 0$ is equivalent to finding the minimum of $f$. There are methods which follow the steepest decent i.e. move along $\mathbf{r}$ to get towards the minimum. The trick in the conjugant gradient method is that it takes steps in orthogonal vectors to converge towards the minimum. The remarkable aspect of this algorithm is that it converges in at most $n$ steps where $\mathbf{A}$ is a $n\times n$ matrix.</span>
<span id="cb12-630"><a href="#cb12-630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-631"><a href="#cb12-631" aria-hidden="true" tabindex="-1"></a>So the key is to learn how to pick the search directions $\mathbf{p}_k$. The most common choice here is to find vectors ortho-normal to the last residue so our quantities only depend on the last step taken and not say on a large number of previous steps. </span>
<span id="cb12-632"><a href="#cb12-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-633"><a href="#cb12-633" aria-hidden="true" tabindex="-1"></a>For the first step we pick $\mathbf{p}_0=\mathbf{r}_0=\mathbf{b}-\mathbf{A\,x}_0$ as the search direction. </span>
<span id="cb12-634"><a href="#cb12-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-635"><a href="#cb12-635" aria-hidden="true" tabindex="-1"></a>Let us pick </span>
<span id="cb12-636"><a href="#cb12-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-637"><a href="#cb12-637" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-638"><a href="#cb12-638" aria-hidden="true" tabindex="-1"></a>\mathbf{x}_{k+1} = \mathbf{x}_k+\alpha_k\,\mathbf{p}_k,\ \ \ \  \alpha_k=\frac{\mathbf{r}^T_k \mathbf{r}_k}{\mathbf{p}_k^T\,\mathbf{A}\,\mathbf{p}_k}</span>
<span id="cb12-639"><a href="#cb12-639" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-640"><a href="#cb12-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-641"><a href="#cb12-641" aria-hidden="true" tabindex="-1"></a>and </span>
<span id="cb12-642"><a href="#cb12-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-643"><a href="#cb12-643" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-644"><a href="#cb12-644" aria-hidden="true" tabindex="-1"></a>\mathbf{p}_{k+1} = \mathbf{r}_{k+1} + \beta_k \, \mathbf{p}_k, \ \ \ \ \beta = \frac{\mathbf{r}_{k+1}^T\, \mathbf{r}_{k+1}}{ \mathbf{r}_{k}^T \, \mathbf{r}_{k}}</span>
<span id="cb12-645"><a href="#cb12-645" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-646"><a href="#cb12-646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-647"><a href="#cb12-647" aria-hidden="true" tabindex="-1"></a>i.e. a combination of the current residual and the previous search direction, for the next search direction. Different conjugate gradient methods differ typically in their choice of $\beta$ and of how many previous search directions are considered. Please also have a look at &lt;a href="http://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf"&gt;Jonathan Shewchuk's fantastic detailed description&lt;/a&gt; of this method.</span>
<span id="cb12-648"><a href="#cb12-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-651"><a href="#cb12-651" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-652"><a href="#cb12-652" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-653"><a href="#cb12-653" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-654"><a href="#cb12-654" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ConGrad(A,b,tol,xinit<span class="op">=</span><span class="dv">0</span>,kmax<span class="op">=</span><span class="dv">5000</span>):</span>
<span id="cb12-655"><a href="#cb12-655" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Solve the linear problem A x = b</span></span>
<span id="cb12-656"><a href="#cb12-656" aria-hidden="true" tabindex="-1"></a><span class="co">    A and b have to python matrices not arrays ! </span></span>
<span id="cb12-657"><a href="#cb12-657" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb12-658"><a href="#cb12-658" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> b.copy()</span>
<span id="cb12-659"><a href="#cb12-659" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> b.copy()</span>
<span id="cb12-660"><a href="#cb12-660" aria-hidden="true" tabindex="-1"></a>    x[:] <span class="op">=</span> <span class="fl">0.</span> <span class="co"># start with x=0 as a guess</span></span>
<span id="cb12-661"><a href="#cb12-661" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(xinit) <span class="op">!=</span> <span class="bu">int</span>:</span>
<span id="cb12-662"><a href="#cb12-662" aria-hidden="true" tabindex="-1"></a>       x <span class="op">=</span> xinit</span>
<span id="cb12-663"><a href="#cb12-663" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-664"><a href="#cb12-664" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> b <span class="op">-</span> A<span class="op">*</span>x</span>
<span id="cb12-665"><a href="#cb12-665" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> r.copy()</span>
<span id="cb12-666"><a href="#cb12-666" aria-hidden="true" tabindex="-1"></a>    rsold<span class="op">=</span>np.ravel(r.T<span class="op">*</span>r)[<span class="dv">0</span>]</span>
<span id="cb12-667"><a href="#cb12-667" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(np.sqrt(rsold), tol)</span>
<span id="cb12-668"><a href="#cb12-668" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (k<span class="op">==</span><span class="dv">0</span> <span class="kw">or</span> ((np.sqrt(rsold) <span class="op">&gt;</span> tol) <span class="kw">and</span> (k <span class="op">&lt;</span> kmax))):</span>
<span id="cb12-669"><a href="#cb12-669" aria-hidden="true" tabindex="-1"></a>        Ap <span class="op">=</span> A<span class="op">*</span>p</span>
<span id="cb12-670"><a href="#cb12-670" aria-hidden="true" tabindex="-1"></a>        alphak <span class="op">=</span> rsold<span class="op">/</span>np.ravel(p.T<span class="op">*</span>Ap)[<span class="dv">0</span>]</span>
<span id="cb12-671"><a href="#cb12-671" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">+</span> alphak<span class="op">*</span>p</span>
<span id="cb12-672"><a href="#cb12-672" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> r <span class="op">-</span> alphak<span class="op">*</span>Ap</span>
<span id="cb12-673"><a href="#cb12-673" aria-hidden="true" tabindex="-1"></a>        rsnew <span class="op">=</span> (np.ravel(r.T<span class="op">*</span>r))[<span class="dv">0</span>]</span>
<span id="cb12-674"><a href="#cb12-674" aria-hidden="true" tabindex="-1"></a>        beta <span class="op">=</span> rsnew<span class="op">/</span>rsold</span>
<span id="cb12-675"><a href="#cb12-675" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> r <span class="op">+</span> beta<span class="op">*</span>p</span>
<span id="cb12-676"><a href="#cb12-676" aria-hidden="true" tabindex="-1"></a>        k <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-677"><a href="#cb12-677" aria-hidden="true" tabindex="-1"></a>        rsold<span class="op">=</span>rsnew</span>
<span id="cb12-678"><a href="#cb12-678" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'iterated '</span>, k, <span class="st">' times to get to tolerance='</span>, tol)</span>
<span id="cb12-679"><a href="#cb12-679" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (k <span class="op">==</span> kmax):</span>
<span id="cb12-680"><a href="#cb12-680" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">'reached max. iterations! '</span>, kmax)</span>
<span id="cb12-681"><a href="#cb12-681" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb12-682"><a href="#cb12-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-683"><a href="#cb12-683" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.asmatrix([[<span class="fl">4.</span>,<span class="fl">1.001</span>],[<span class="fl">1.</span>,<span class="dv">3</span>]])</span>
<span id="cb12-684"><a href="#cb12-684" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.asmatrix([<span class="fl">1.</span>,<span class="dv">2</span>]).T</span>
<span id="cb12-685"><a href="#cb12-685" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> ConGrad(A,b,<span class="fl">1e-10</span>)</span>
<span id="cb12-686"><a href="#cb12-686" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'x='</span>, np.ravel(x))</span>
<span id="cb12-687"><a href="#cb12-687" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-688"><a href="#cb12-688" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-689"><a href="#cb12-689" aria-hidden="true" tabindex="-1"></a>Double check the Answer. Is $\mathbf{A\,x}=\mathbf{b}$ ? </span>
<span id="cb12-690"><a href="#cb12-690" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-693"><a href="#cb12-693" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-694"><a href="#cb12-694" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-695"><a href="#cb12-695" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-696"><a href="#cb12-696" aria-hidden="true" tabindex="-1"></a>A<span class="op">*</span>x<span class="op">-</span>b</span>
<span id="cb12-697"><a href="#cb12-697" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-698"><a href="#cb12-698" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-701"><a href="#cb12-701" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-702"><a href="#cb12-702" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-703"><a href="#cb12-703" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-704"><a href="#cb12-704" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f2(x,A,b):</span>
<span id="cb12-705"><a href="#cb12-705" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.ravel(<span class="fl">0.5</span><span class="op">*</span>x.T<span class="op">*</span>A<span class="op">*</span>x<span class="op">-</span>x.T<span class="op">*</span>b)[<span class="dv">0</span>]</span>
<span id="cb12-706"><a href="#cb12-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-707"><a href="#cb12-707" aria-hidden="true" tabindex="-1"></a>xy <span class="op">=</span> np.linspace(<span class="fl">0.</span>,<span class="dv">1</span>)</span>
<span id="cb12-708"><a href="#cb12-708" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> np.zeros((<span class="bu">len</span>(xy),<span class="bu">len</span>(xy)))</span>
<span id="cb12-709"><a href="#cb12-709" aria-hidden="true" tabindex="-1"></a>f[:] <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb12-710"><a href="#cb12-710" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(xy)):</span>
<span id="cb12-711"><a href="#cb12-711" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(xy)):</span>
<span id="cb12-712"><a href="#cb12-712" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.asmatrix([xy[i], <span class="fl">1.</span><span class="op">-</span>xy[j]]).T</span>
<span id="cb12-713"><a href="#cb12-713" aria-hidden="true" tabindex="-1"></a>        f[i,j] <span class="op">=</span> f2(x,A,b)</span>
<span id="cb12-714"><a href="#cb12-714" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-715"><a href="#cb12-715" aria-hidden="true" tabindex="-1"></a>plt.imshow(f.T,extent<span class="op">=</span>(xy.<span class="bu">min</span>(),xy.<span class="bu">max</span>(),xy.<span class="bu">min</span>(),xy.<span class="bu">max</span>()))</span>
<span id="cb12-716"><a href="#cb12-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-717"><a href="#cb12-717" aria-hidden="true" tabindex="-1"></a>x<span class="op">=</span> np.asmatrix([<span class="fl">1.</span>,<span class="fl">.7</span>]).T</span>
<span id="cb12-718"><a href="#cb12-718" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> b.copy()<span class="op">-</span>A<span class="op">*</span>x</span>
<span id="cb12-719"><a href="#cb12-719" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> r.copy()</span>
<span id="cb12-720"><a href="#cb12-720" aria-hidden="true" tabindex="-1"></a><span class="co">#x[:] = 0. # start with x=0 as a guess</span></span>
<span id="cb12-721"><a href="#cb12-721" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-722"><a href="#cb12-722" aria-hidden="true" tabindex="-1"></a>rsold<span class="op">=</span>np.ravel(r.T<span class="op">*</span>r)[<span class="dv">0</span>]</span>
<span id="cb12-723"><a href="#cb12-723" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> ((k <span class="op">&lt;</span> <span class="dv">8</span>)):</span>
<span id="cb12-724"><a href="#cb12-724" aria-hidden="true" tabindex="-1"></a>    Ap <span class="op">=</span> A<span class="op">*</span>p</span>
<span id="cb12-725"><a href="#cb12-725" aria-hidden="true" tabindex="-1"></a>    alphak <span class="op">=</span> rsold<span class="op">/</span>np.ravel(p.T<span class="op">*</span>Ap)[<span class="dv">0</span>]</span>
<span id="cb12-726"><a href="#cb12-726" aria-hidden="true" tabindex="-1"></a>    xold <span class="op">=</span> x</span>
<span id="cb12-727"><a href="#cb12-727" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x <span class="op">+</span> alphak<span class="op">*</span>p</span>
<span id="cb12-728"><a href="#cb12-728" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> r <span class="op">-</span> alphak<span class="op">*</span>Ap</span>
<span id="cb12-729"><a href="#cb12-729" aria-hidden="true" tabindex="-1"></a>    rsnew <span class="op">=</span> np.ravel(r.T<span class="op">*</span>r)[<span class="dv">0</span>]</span>
<span id="cb12-730"><a href="#cb12-730" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> rsnew<span class="op">/</span>rsold</span>
<span id="cb12-731"><a href="#cb12-731" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> r <span class="op">+</span> beta<span class="op">*</span>p</span>
<span id="cb12-732"><a href="#cb12-732" aria-hidden="true" tabindex="-1"></a>    k <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-733"><a href="#cb12-733" aria-hidden="true" tabindex="-1"></a>    rsold<span class="op">=</span>rsnew</span>
<span id="cb12-734"><a href="#cb12-734" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'step:'</span>, k, <span class="st">' distance to minimum:'</span>,np.sqrt(rsnew))</span>
<span id="cb12-735"><a href="#cb12-735" aria-hidden="true" tabindex="-1"></a>    plt.plot([np.ravel(xold[<span class="dv">0</span>])[<span class="dv">0</span>], np.ravel(x[<span class="dv">0</span>])[<span class="dv">0</span>]], [np.ravel(xold[<span class="dv">1</span>])[<span class="dv">0</span>],np.ravel(x[<span class="dv">1</span>])[<span class="dv">0</span>]])</span>
<span id="cb12-736"><a href="#cb12-736" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-737"><a href="#cb12-737" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-740"><a href="#cb12-740" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb12-741"><a href="#cb12-741" aria-hidden="true" tabindex="-1"></a><span class="co">#| collapsed: false</span></span>
<span id="cb12-742"><a href="#cb12-742" aria-hidden="true" tabindex="-1"></a><span class="co">#| jupyter: {outputs_hidden: false}</span></span>
<span id="cb12-743"><a href="#cb12-743" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.integrate <span class="im">as</span> integrate</span>
<span id="cb12-744"><a href="#cb12-744" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-745"><a href="#cb12-745" aria-hidden="true" tabindex="-1"></a>N<span class="op">=</span><span class="dv">130</span></span>
<span id="cb12-746"><a href="#cb12-746" aria-hidden="true" tabindex="-1"></a>iPhi <span class="op">=</span><span class="dv">0</span> </span>
<span id="cb12-747"><a href="#cb12-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-748"><a href="#cb12-748" aria-hidden="true" tabindex="-1"></a><span class="co"># reference solution</span></span>
<span id="cb12-749"><a href="#cb12-749" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="fl">0.</span>,<span class="fl">1.</span>,N) <span class="co"># uniform grid </span></span>
<span id="cb12-750"><a href="#cb12-750" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> density(x)</span>
<span id="cb12-751"><a href="#cb12-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-752"><a href="#cb12-752" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="op">-</span>integrate.cumulative_trapezoid(C<span class="op">*</span>d,x<span class="op">=</span>x,initial<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-753"><a href="#cb12-753" aria-hidden="true" tabindex="-1"></a>F0 <span class="op">=</span> <span class="op">-</span>integrate.simpson(F,x<span class="op">=</span>x) <span class="co"># fix the force constant to keep momentum change=0</span></span>
<span id="cb12-754"><a href="#cb12-754" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'F(x=0) = '</span>, F0)</span>
<span id="cb12-755"><a href="#cb12-755" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> F <span class="op">+</span> F0</span>
<span id="cb12-756"><a href="#cb12-756" aria-hidden="true" tabindex="-1"></a>Phi <span class="op">=</span> <span class="op">-</span>integrate.cumulative_trapezoid(F,x,initial<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-757"><a href="#cb12-757" aria-hidden="true" tabindex="-1"></a><span class="co">#Phi = Phi - integrate.simpson(Phi,x=x)/1.    # set potential to mean</span></span>
<span id="cb12-758"><a href="#cb12-758" aria-hidden="true" tabindex="-1"></a>Phi <span class="op">=</span> Phi <span class="op">-</span> np.mean(Phi)</span>
<span id="cb12-759"><a href="#cb12-759" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-760"><a href="#cb12-760" aria-hidden="true" tabindex="-1"></a><span class="co"># now try with Conjugate Gradient</span></span>
<span id="cb12-761"><a href="#cb12-761" aria-hidden="true" tabindex="-1"></a>rx <span class="op">=</span> (<span class="fl">0.5</span><span class="op">+</span>np.arange(N))<span class="op">/</span>N</span>
<span id="cb12-762"><a href="#cb12-762" aria-hidden="true" tabindex="-1"></a>rd <span class="op">=</span> density(rx)</span>
<span id="cb12-763"><a href="#cb12-763" aria-hidden="true" tabindex="-1"></a>rd[<span class="dv">3</span>] <span class="op">=</span><span class="fl">1.</span></span>
<span id="cb12-764"><a href="#cb12-764" aria-hidden="true" tabindex="-1"></a>rd <span class="op">-=</span> np.mean(rd)</span>
<span id="cb12-765"><a href="#cb12-765" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="fl">1.</span><span class="op">/</span>N</span>
<span id="cb12-766"><a href="#cb12-766" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.asmatrix(np.zeros((N,N)),dtype<span class="op">=</span>np.float64) <span class="co"># mat turns the numpy array into an object of matrix type</span></span>
<span id="cb12-767"><a href="#cb12-767" aria-hidden="true" tabindex="-1"></a>ip1 <span class="op">=</span> (np.arange(N) <span class="op">+</span> <span class="dv">1</span>) <span class="co"># define arrays that are the indeces i+1 and i-1</span></span>
<span id="cb12-768"><a href="#cb12-768" aria-hidden="true" tabindex="-1"></a>ip1[N<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-769"><a href="#cb12-769" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> (np.arange(N) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb12-770"><a href="#cb12-770" aria-hidden="true" tabindex="-1"></a>im1[<span class="dv">0</span>] <span class="op">=</span> N<span class="op">-</span><span class="dv">1</span></span>
<span id="cb12-771"><a href="#cb12-771" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,N):</span>
<span id="cb12-772"><a href="#cb12-772" aria-hidden="true" tabindex="-1"></a>    A[i,i]<span class="op">=-</span><span class="dv">2</span></span>
<span id="cb12-773"><a href="#cb12-773" aria-hidden="true" tabindex="-1"></a>    A[i,im1[i]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-774"><a href="#cb12-774" aria-hidden="true" tabindex="-1"></a>    A[i,ip1[i]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-775"><a href="#cb12-775" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.asmatrix(rd,dtype<span class="op">=</span>np.float64).T<span class="op">*</span>C <span class="co"># *dx**2  do this small number later</span></span>
<span id="cb12-776"><a href="#cb12-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-777"><a href="#cb12-777" aria-hidden="true" tabindex="-1"></a>iPhi <span class="op">=</span> ConGrad(A,b,<span class="fl">1e-1</span>)</span>
<span id="cb12-778"><a href="#cb12-778" aria-hidden="true" tabindex="-1"></a>iPhi <span class="op">=</span> ConGrad(A,b,<span class="fl">1e-4</span>)</span>
<span id="cb12-779"><a href="#cb12-779" aria-hidden="true" tabindex="-1"></a>iPhi <span class="op">=</span> ConGrad(A,b,<span class="fl">1e-5</span>)</span>
<span id="cb12-780"><a href="#cb12-780" aria-hidden="true" tabindex="-1"></a>iPhi <span class="op">=</span> ConGrad(A,b,<span class="fl">1e-7</span>)</span>
<span id="cb12-781"><a href="#cb12-781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-782"><a href="#cb12-782" aria-hidden="true" tabindex="-1"></a>iPhi <span class="op">=</span> iPhi<span class="op">*</span>dx<span class="op">**</span><span class="dv">2</span> <span class="co"># we solved without that factor</span></span>
<span id="cb12-783"><a href="#cb12-783" aria-hidden="true" tabindex="-1"></a>iPhi <span class="op">=</span> iPhi <span class="op">-</span> np.mean(iPhi) <span class="co"># convention: \bar{\Phi} = 0</span></span>
<span id="cb12-784"><a href="#cb12-784" aria-hidden="true" tabindex="-1"></a>iF <span class="op">=</span> <span class="op">-</span>(iPhi[ip1]<span class="op">-</span>iPhi[im1])<span class="op">/</span>(<span class="fl">2.</span><span class="op">*</span>dx) <span class="co"># force from central difference</span></span>
<span id="cb12-785"><a href="#cb12-785" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-786"><a href="#cb12-786" aria-hidden="true" tabindex="-1"></a><span class="co"># show results</span></span>
<span id="cb12-787"><a href="#cb12-787" aria-hidden="true" tabindex="-1"></a>plt.figure(num<span class="op">=</span><span class="va">None</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>), dpi<span class="op">=</span><span class="dv">80</span>, facecolor<span class="op">=</span><span class="st">'w'</span>, edgecolor<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb12-788"><a href="#cb12-788" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,rd<span class="op">/</span>N,<span class="st">'x'</span>,label<span class="op">=</span><span class="st">'$\delta$'</span>)<span class="op">;</span></span>
<span id="cb12-789"><a href="#cb12-789" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,iF,label<span class="op">=</span><span class="st">'F'</span>)<span class="op">;</span></span>
<span id="cb12-790"><a href="#cb12-790" aria-hidden="true" tabindex="-1"></a>plt.plot(x,F,<span class="st">':'</span>,label<span class="op">=</span><span class="st">'$F_</span><span class="sc">{ref}</span><span class="st">$'</span>)</span>
<span id="cb12-791"><a href="#cb12-791" aria-hidden="true" tabindex="-1"></a>plt.plot(rx,iPhi<span class="op">*</span><span class="dv">30</span>,<span class="st">'.'</span>,label<span class="op">=</span><span class="st">'$\Phi$*30'</span>)<span class="op">;</span></span>
<span id="cb12-792"><a href="#cb12-792" aria-hidden="true" tabindex="-1"></a>plt.plot(x,Phi<span class="op">*</span><span class="dv">30</span>,<span class="st">':'</span>,label<span class="op">=</span><span class="st">'$\Phi_</span><span class="sc">{ref}</span><span class="st">$*30'</span>)</span>
<span id="cb12-793"><a href="#cb12-793" aria-hidden="true" tabindex="-1"></a>plt.plot(np.zeros(<span class="dv">2</span>))</span>
<span id="cb12-794"><a href="#cb12-794" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'position'</span>)</span>
<span id="cb12-795"><a href="#cb12-795" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Solution to the 1D Poisson equation using Conjugate Gradient'</span>)</span>
<span id="cb12-796"><a href="#cb12-796" aria-hidden="true" tabindex="-1"></a>leg <span class="op">=</span> plt.legend()<span class="op">;</span></span>
<span id="cb12-797"><a href="#cb12-797" aria-hidden="true" tabindex="-1"></a>leg.get_frame().set_alpha(<span class="fl">0.7</span>)</span>
<span id="cb12-798"><a href="#cb12-798" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb12-799"><a href="#cb12-799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-800"><a href="#cb12-800" aria-hidden="true" tabindex="-1"></a><span class="fu">### In class Exercise: </span></span>
<span id="cb12-801"><a href="#cb12-801" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Let's see whether we can figure out how to use the <span class="co">[</span><span class="ot">conjugate gradient method in scipy</span><span class="co">](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.cg.html)</span>.</span>
<span id="cb12-802"><a href="#cb12-802" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Explore <span class="co">[</span><span class="ot">Best least square solution</span><span class="co">](https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq)</span></span>
<span id="cb12-803"><a href="#cb12-803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-804"><a href="#cb12-804" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Laplace operator in spherical coordinates</span></span>
<span id="cb12-805"><a href="#cb12-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-806"><a href="#cb12-806" aria-hidden="true" tabindex="-1"></a>The Laplace operator in spherical coordinates is:</span>
<span id="cb12-807"><a href="#cb12-807" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-808"><a href="#cb12-808" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb12-809"><a href="#cb12-809" aria-hidden="true" tabindex="-1"></a>\nabla^2 f &amp;=&amp; {1 \over r^2}{\partial \over \partial r}<span class="sc">\!</span>\left(r^2 {\partial f \over \partial r}\right)</span>
<span id="cb12-810"><a href="#cb12-810" aria-hidden="true" tabindex="-1"></a>  <span class="sc">\!</span>+<span class="sc">\!</span>{1 \over r^2<span class="sc">\!</span>\sin\theta}{\partial \over \partial \theta}<span class="sc">\!</span>\left(\sin\theta {\partial f \over \partial \theta}\right)</span>
<span id="cb12-811"><a href="#cb12-811" aria-hidden="true" tabindex="-1"></a>  <span class="sc">\!</span>+<span class="sc">\!</span>{1 \over r^2<span class="sc">\!</span>\sin^2\theta}{\partial^2 f \over \partial \varphi^2} </span>
<span id="cb12-812"><a href="#cb12-812" aria-hidden="true" tabindex="-1"></a>= <span class="sc">\\</span> </span>
<span id="cb12-813"><a href="#cb12-813" aria-hidden="true" tabindex="-1"></a>&amp; = &amp;\left(\frac{\partial^2}{\partial r^2} + \frac{2}{r} \frac{\partial}{\partial r}\right)f <span class="sc">\!</span>+</span>
<span id="cb12-814"><a href="#cb12-814" aria-hidden="true" tabindex="-1"></a>{1 \over r^2<span class="sc">\!</span>\sin\theta}{\partial \over \partial \theta}<span class="sc">\!</span>\left(\sin\theta \frac{\partial}{\partial \theta}\right)f +\frac{1}{r^2<span class="sc">\!</span>\sin^2\theta}\frac{\partial^2}{\partial \varphi^2}f.</span>
<span id="cb12-815"><a href="#cb12-815" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb12-816"><a href="#cb12-816" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-817"><a href="#cb12-817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-818"><a href="#cb12-818" aria-hidden="true" tabindex="-1"></a>Here we care only for the radial part:</span>
<span id="cb12-819"><a href="#cb12-819" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-820"><a href="#cb12-820" aria-hidden="true" tabindex="-1"></a>\nabla^2_r f =  {1 \over r^2}{\partial \over \partial r}<span class="sc">\!</span>\left(r^2 {\partial f \over \partial r}\right) = \left(\frac{\partial^2}{\partial r^2} + \frac{2}{r} \frac{\partial}{\partial r}\right)f</span>
<span id="cb12-821"><a href="#cb12-821" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-822"><a href="#cb12-822" aria-hidden="true" tabindex="-1"></a>and also make note of the gradient in radial direction:</span>
<span id="cb12-823"><a href="#cb12-823" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-824"><a href="#cb12-824" aria-hidden="true" tabindex="-1"></a>\nabla_r\ f = {\partial f \over \partial r}</span>
<span id="cb12-825"><a href="#cb12-825" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb12-826"><a href="#cb12-826" aria-hidden="true" tabindex="-1"></a></span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>