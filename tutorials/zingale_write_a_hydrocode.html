<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Write A Hydro Code</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e5b8070214c8195f5f60c8866162d912.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../website/index.html"> 
<span class="menu-text">Physics 360: Modern Astrophysics</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-lectures" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Lectures</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-lectures">    
        <li>
    <a class="dropdown-item" href="../lectures/preliminaries.html">
 <span class="dropdown-text">Preliminaries</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/gravity.html">
 <span class="dropdown-text">Gravity</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="../tutorials/python_setup.html">
 <span class="dropdown-text">Setup python</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/gala_tutorial.html">
 <span class="dropdown-text">gala tutorial</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/integrate-1D-poissonEquation.html">
 <span class="dropdown-text">Poisson equation tutorial</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/Intro_3D_visualization.html">
 <span class="dropdown-text">3D vis tutorial</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/lagrangian-hydrodynamics.html">
 <span class="dropdown-text">Lagrangian Hydro</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/pyro_tutorial.html">
 <span class="dropdown-text">2D Hydro</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href=".././tutorials/plasma_pic_1d.ipynb">
 <span class="dropdown-text">1D PIC plasma code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/zingale_write_a_hydrocode.html">
 <span class="dropdown-text">How to write a hydro code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/WavelengthAbsorptionLineModeller.html">
 <span class="dropdown-text">Explore absorption lines</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-assignments" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Assignments</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-assignments">    
        <li>
    <a class="dropdown-item" href="../assignments/assignment_1.html">
 <span class="dropdown-text">Workflow</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-final-project" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Final Project</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-final-project">    
        <li>
    <a class="dropdown-item" href="../final_project/project_ideas.html">
 <span class="dropdown-text">Project Suggestions</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/KIPAC/360"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">How To Write A Hydro Code</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Michael Zingale</p>
<p>There are <em>many</em> methods for solving the equations of hydrodynamics. We will make some choices right from the start:</p>
<ul>
<li><p>We will consider <strong>finite-volume methods</strong>. These are popular in astrophysics because they are based on the integral form of the conservative equations and properly conserve mass, momentum, and energy.</p></li>
<li><p>We will consider an <strong>Eulerian</strong> grid: the grid is fixed and the fluid moves through it.</p></li>
<li><p>We will be <strong>explicit in time</strong>: the new solution depends only on the previous state.</p></li>
<li><p>We will look at a simple 2nd order <strong>method-of-lines</strong> integration. We do this for simplicity here, and will point out where things are commonly done differently. This scheme has a much simpler spatial reconstruction than methods that do characteristic tracing and relies on an integrator (like a Runge-Kutta method) to advance in time.</p></li>
<li><p>We will work in 1-d.</p></li>
<li><p>We won’t cover in detail how to write a Riemann solver (that’s a math exercise as much as anything else and beyond the scope of this notebook).</p></li>
<li><p>We’ll assume a gamma-law equation of state—this is often not the case in astrophysics.</p></li>
</ul>
<p>Much more in-depth details and derivations are given in my hydro notes available online: https://github.com/Open-Astrophysics-Bookshelf/numerical_exercises</p>
<p>For a greater variety of methods, in 2-d, see the pyro code: https://github.com/python-hydro/pyro2 (ref: <a href="http://joss.theoj.org/papers/10.21105/joss.01265">Harpole et al.&nbsp;JOSS</a>)</p>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>We’ll focus on the Euler equations. In 1-d, these are:</p>
<p><span class="math display">\[\begin{align*}
  \frac{\partial \rho}{\partial t} + \frac{\partial (\rho u)}{\partial x} &amp; = 0 \\
  \frac{\partial (\rho u)}{\partial t} + \frac{\partial (\rho u^2 + p)}{\partial x} &amp;= 0 \\
  \frac{\partial (\rho E)}{\partial t} + \frac{\partial (u(\rho E + p))}{\partial x} &amp;= 0 \\
  \end{align*}\]</span></p>
<p>This is a set of (hyperbolic) partial differential equations. To close the system, we need an equation of state, relating the specific internal energy, <span class="math inline">\(e\)</span>, to the pressure: <span class="math display">\[
\begin{align*}
e &amp;= E - \frac{1}{2}u^2 \\
p &amp;= \rho e ( \gamma - 1 ) \\
\end{align*}
\]</span></p>
<p>To solve these, we need to discretize the equations in both space and time. We’ll use grid-based methods (in addition to the finite-volume method we’ll consider, this can include finite-difference and finite-element methods).</p>
<p>Our system of equations can be expressed in conservative form: <span class="math display">\[ \frac{\partial U}{\partial t} + \frac{\partial F(U)}{\partial x} = 0\]</span> where <span class="math inline">\(U = (\rho, \rho u, \rho E)^\intercal\)</span> and <span class="math display">\[
F(U) = \left ( \begin{array}{c} \rho u \\ \rho u^2 + p \\ u (\rho E + p) \end{array} \right )\]</span></p>
<p>In a finite-volume method, we store the state of the fluid in discrete volumes in space, and we can refer to this discretized state with an index. To see this, we integrate the conservative law system in space over a volume <span class="math inline">\([x_{i-1/2},x_{i+1/2}]\)</span>: <span class="math display">\[\frac{\partial \langle U\rangle_i}{\partial t} = - \frac{F_{i+1/2} - F_{i-1/2}}{\Delta x}\]</span></p>
<p>This is the form of the equations we will solve. Here, <span class="math inline">\(\langle U\rangle_i\)</span> represents the average state of the fluid in a volume: <span class="math display">\[\langle U\rangle_i = \frac{1}{\Delta x} \int_{x_{i-1/2}}^{x_{i+1/2}} U(x) dx\]</span> Visually, we usually think of this grid as:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/python-hydro/how_to_write_a_hydro_code/blob/master/fv_grid.png?raw=true" class="img-fluid figure-img"></p>
<figcaption>FV grid</figcaption>
</figure>
</div>
<p>The state on the grid represents an instance in time. We evolve the state by computing the fluxes through the volumes. These fluxes tell us how much the state changes in each volume over some small timestep, <span class="math inline">\(\Delta t\)</span>.</p>
<p>Our code will have the following structure:</p>
<ul>
<li><p>Create our numerical grid</p></li>
<li><p>Set the initial conditions</p></li>
<li><p>Main timestep evolution loop</p>
<ul>
<li><p>Compute the timestep</p></li>
<li><p>Loop to advance one step (count depends on the number of stages in the integrator)</p>
<ul>
<li><p>Reconstruct the state to interfaces</p></li>
<li><p>Solve Riemann problem to find the fluxes through the interface</p></li>
<li><p>Do a conservative update of the state to the stage</p></li>
</ul></li>
<li><p>Output</p></li>
</ul></li>
</ul>
</section>
<section id="grid" class="level2">
<h2 class="anchored" data-anchor-id="grid">Grid</h2>
<p>We’ll manage our 1-d grid via a class <code>FVGrid</code>. We will divide the domain into a number of zones (or volumes) that will store the state. To implement boundary conditions, we traditionally use ghost cells–extra cells added to each end of the domain. We’ll consider a grid that looks like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/python-hydro/how_to_write_a_hydro_code/blob/master/simplegrid_gc.png?raw=true" class="img-fluid figure-img"></p>
<figcaption>grid w ghostcells</figcaption>
</figure>
</div>
<p>We’ll use the names <code>lo</code> and <code>hi</code> to refer to the first and last zone in our domain. The domain boundaries are the bold lines shown above, and beyond that, on each end, we have ghost cells.</p>
<p>The main information we need to setup the grid are the number of zones in the interior and the number of ghost cells.</p>
<div id="cell-9" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;skip&quot;}" data-execution_count="23">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To make life easier, we’ll have a simple class with indices that we use to index the fluid state arrays. We can pass this around and be sure that we are always accessing the correct fluid state.</p>
<div id="cell-11" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="24">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FluidVars:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""A simple container that holds the integer indicies we will use to</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    refer to the different fluid components"""</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, gamma<span class="op">=</span><span class="fl">1.4</span>, C<span class="op">=</span><span class="fl">0.8</span>):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nvar <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># conserved variables</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.urho <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.umx <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.uener <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># primitive variables</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.qrho <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.qu <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.qp <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># EOS gamma</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.gamma <span class="op">=</span> gamma</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># CFL number</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.C <span class="op">=</span> C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is the main class for managing the finite-volume grid. In addition to holding coordinate information and knowing the bounds of the domain, it also can fill the ghost cells and give you a scratch array that lives on the same grid.</p>
<div id="cell-13" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;slide&quot;}" data-execution_count="25">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FVGrid:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""The main finite-volume grid class for holding our fluid state."""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, nx, ng, xmin<span class="op">=</span><span class="fl">0.0</span>, xmax<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.xmin <span class="op">=</span> xmin</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.xmax <span class="op">=</span> xmax</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ng <span class="op">=</span> ng</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nx <span class="op">=</span> nx</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.lo <span class="op">=</span> ng</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.hi <span class="op">=</span> ng<span class="op">+</span>nx<span class="op">-</span><span class="dv">1</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># physical coords -- cell-centered</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dx <span class="op">=</span> (xmax <span class="op">-</span> xmin)<span class="op">/</span>(nx)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> xmin <span class="op">+</span> (np.arange(nx<span class="op">+</span><span class="dv">2</span><span class="op">*</span>ng)<span class="op">-</span>ng<span class="op">+</span><span class="fl">0.5</span>)<span class="op">*</span><span class="va">self</span>.dx</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> scratch_array(<span class="va">self</span>, nc<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" return a scratch array dimensioned for our grid """</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.squeeze(np.zeros((<span class="va">self</span>.nx<span class="op">+</span><span class="dv">2</span><span class="op">*</span><span class="va">self</span>.ng, nc), dtype<span class="op">=</span>np.float64))</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fill_BCs(<span class="va">self</span>, atmp):</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" fill all ghost cells with zero-gradient boundary conditions """</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> atmp.ndim <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(atmp.shape[<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>                atmp[<span class="dv">0</span>:<span class="va">self</span>.lo, n] <span class="op">=</span> atmp[<span class="va">self</span>.lo, n]</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>                atmp[<span class="va">self</span>.hi<span class="op">+</span><span class="dv">1</span>:, n] <span class="op">=</span> atmp[<span class="va">self</span>.hi, n]            </span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>            atmp[<span class="dv">0</span>:<span class="va">self</span>.lo] <span class="op">=</span> atmp[<span class="va">self</span>.lo]</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>            atmp[<span class="va">self</span>.hi<span class="op">+</span><span class="dv">1</span>:] <span class="op">=</span> atmp[<span class="va">self</span>.hi]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="reconstruction" class="level2">
<h2 class="anchored" data-anchor-id="reconstruction">Reconstruction</h2>
<p>We need to use the cell-averages to figure out what the fluid state is on the interfaces. We’ll <em>reconstruct</em> the cell-averages as piecewise lines that give us the same average in the zone. We then follow these lines to the interfaces to define the left and right state at each interface.</p>
<p>Usually we work in terms of the <strong>primitive variables</strong>, <span class="math inline">\(q = (\rho, u, p)\)</span>. So we first write a routine to do the algebraic transformation from conservative to primitive variables: <span class="math display">\[
\begin{align}
\rho &amp;= \rho \\
u &amp;= \frac{(\rho u)}{\rho} \\
p &amp;= \left ( (\rho E) - \frac{1}{2} \frac{(\rho u)^2}{\rho}\right )(\gamma - 1)
\end{align}
\]</span></p>
<div id="cell-16" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="26">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cons_to_prim(grid, U):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""take a conservative state U and return the corresponding primitive</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    variable state as a new array."""</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> FluidVars()</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> grid.scratch_array(nc<span class="op">=</span>v.nvar)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    q[:, v.qrho] <span class="op">=</span> U[:, v.urho]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    q[:, v.qu] <span class="op">=</span> U[:, v.umx]<span class="op">/</span>U[:, v.urho]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    rhoe <span class="op">=</span> U[:, v.uener] <span class="op">-</span> <span class="fl">0.5</span><span class="op">*</span>q[:, v.qrho]<span class="op">*</span>q[:, v.qu]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    q[:, v.qp] <span class="op">=</span> rhoe<span class="op">*</span>(v.gamma <span class="op">-</span> <span class="fl">1.0</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next we need a routine to create the interface states. Here’s well construct a slope for each zone, <span class="math inline">\(\Delta q\)</span> based on the average state in the neighboring zones. This gives us a line representing the value of the fluid state as a function of position in each zone: <span class="math display">\[q_i(x) = \langle q\rangle_i + \frac{\Delta q_i}{\Delta x} (x - x_i)\]</span></p>
<p>Note that there is a unique <span class="math inline">\(q_i(x)\)</span> for each zone—this is usually called <em>piecewise linear reconstruction</em>. By design, the average of <span class="math inline">\(q_i(x)\)</span> over the zone is the cell-average, so it is conservative.</p>
<p>We use this equation for a line to find the fluid state right at the interface. For zone <span class="math inline">\(i\)</span>, the line <span class="math inline">\(q_i(x)\)</span> gives you the right state on the left interface, <span class="math inline">\(q_{i-1/2,R}\)</span>, and the left state on the right interface, <span class="math inline">\(q_{i+1/2,L}\)</span>. Visually this looks like:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/python-hydro/how_to_write_a_hydro_code/blob/master/riemann-mol.png?raw=true" class="img-fluid figure-img"></p>
<figcaption>finding interface states</figcaption>
</figure>
</div>
<p>There’s one additional wrinkle—2nd order codes tend to produce oscillations near discontinuities, so we usually need to <em>limit</em> the slopes, <span class="math inline">\(\Delta q_i\)</span>, so we don’t introduce new minima or maxima in the evolution. We’ll use the minmod limiter: <span class="math display">\[
\begin{equation}                                                                                                         
\left . \frac{\partial a}{\partial x} \right |_i = \mathtt{minmod} \left (                                               
  \frac{a_i - a_{i-1}}{\Delta x}, \frac{a_{i+1} - a_i}{\Delta x} \right )                                                
\end{equation}
\]</span> with <span class="math display">\[
\begin{equation}                                                                                                         
\mathtt{minmod}(a,b) = \left \{                                                                                          
    \begin{array}{ll}                                                                                                    
    a &amp; \mathit{if~} |a| &lt; |b| \mathrm{~and~} a\cdot b &gt; 0 \\                                                            
    b &amp; \mathit{if~} |b| &lt; |a| \mathrm{~and~} a\cdot b &gt; 0 \\                                                            
    0 &amp; \mathit{otherwise}                                                                                               
    \end{array}                                                                                                          
  \right .                                                                                                               
\end{equation}  
\]</span></p>
<div id="cell-20" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;slide&quot;}" data-execution_count="27">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> states(grid, U):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> FluidVars()</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> cons_to_prim(grid, U)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># construct the slopes</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    dq <span class="op">=</span> grid.scratch_array(nc<span class="op">=</span>v.nvar)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(v.nvar):        </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        dl <span class="op">=</span> grid.scratch_array()</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        dr <span class="op">=</span> grid.scratch_array()</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        dl[grid.lo<span class="op">-</span><span class="dv">1</span>:grid.hi<span class="op">+</span><span class="dv">2</span>] <span class="op">=</span> q[grid.lo:grid.hi<span class="op">+</span><span class="dv">3</span>,n] <span class="op">-</span> q[grid.lo<span class="op">-</span><span class="dv">1</span>:grid.hi<span class="op">+</span><span class="dv">2</span>,n]</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        dr[grid.lo<span class="op">-</span><span class="dv">1</span>:grid.hi<span class="op">+</span><span class="dv">2</span>] <span class="op">=</span> q[grid.lo<span class="op">-</span><span class="dv">1</span>:grid.hi<span class="op">+</span><span class="dv">2</span>,n] <span class="op">-</span> q[grid.lo<span class="op">-</span><span class="dv">2</span>:grid.hi<span class="op">+</span><span class="dv">1</span>,n]</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># these where's do a minmod()</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        d1 <span class="op">=</span> np.where(np.fabs(dl) <span class="op">&lt;</span> np.fabs(dr), dl, dr)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        dq[:, n] <span class="op">=</span> np.where(dl<span class="op">*</span>dr <span class="op">&gt;</span> <span class="fl">0.0</span>, d1, <span class="fl">0.0</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># now make the states</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    q_l <span class="op">=</span> grid.scratch_array(nc<span class="op">=</span>v.nvar)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    q_l[grid.lo:grid.hi<span class="op">+</span><span class="dv">2</span>, :] <span class="op">=</span> q[grid.lo<span class="op">-</span><span class="dv">1</span>:grid.hi<span class="op">+</span><span class="dv">1</span>, :] <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>dq[grid.lo<span class="op">-</span><span class="dv">1</span>:grid.hi<span class="op">+</span><span class="dv">1</span>, :]</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    q_r <span class="op">=</span> grid.scratch_array(nc<span class="op">=</span>v.nvar)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    q_r[grid.lo:grid.hi<span class="op">+</span><span class="dv">2</span>, :] <span class="op">=</span> q[grid.lo:grid.hi<span class="op">+</span><span class="dv">2</span>, :] <span class="op">-</span> <span class="fl">0.5</span><span class="op">*</span>dq[grid.lo:grid.hi<span class="op">+</span><span class="dv">2</span>, :]</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> q_l, q_r</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="riemann-problem-and-conservative-update" class="level2">
<h2 class="anchored" data-anchor-id="riemann-problem-and-conservative-update">Riemann problem and conservative update</h2>
<p>After doing our reconstruction, we are left with a left and right state on an interface. To find the unique fluid state on the interface, we solve a <em>Riemann problem</em>, <span class="math display">\[q_{i+1/2} = \mathcal{R}(q_{i+1/2,L},q_{i+1/2,R})\]</span></p>
<p>We could spend an entire day talking about how to solve the Riemann problem. Well just summarize things here.</p>
<p>At each interface, we have a left and right state. Information about the jump across this interface will be carried away from the interface by the 3 hydrodynamic waves (<span class="math inline">\(u\)</span> and <span class="math inline">\(u\pm c\)</span>).</p>
<p><img src="https://github.com/python-hydro/how_to_write_a_hydro_code/blob/master/riemann-waves.png?raw=true" class="img-fluid" alt="Riemann solution structure"> The solution to the Riemann problem that we need is the state on the interface–with that we can evaluate the flux through the interface.</p>
<p>To solve the Riemann problem, we need to know how much each variable changes across each of the three waves. To complicate matters, the left and right waves can be either shocks or rarefactions. The middle wave (<span class="math inline">\(u\)</span>) is always a contact discontinuity (and of our primitive variables, only <span class="math inline">\(\rho\)</span> jumps across it).</p>
<p>For a gamma-law gas, we can write down analytic expressions for the change in the primitive variables across both a rarefaction and shock. We can then solve these to find the state inbetween the left and right waves (the star state) and then compute the wave speeds.</p>
<p>Finally, we can find the solution on the interface by determining which region we are in.</p>
<p><img src="https://github.com/python-hydro/how_to_write_a_hydro_code/blob/master/riemann_state.png?raw=true" alt="FV grid" width="600"></p>
<p>We’ll use an exact Riemann solver to find the solution on the interface. There a lot of algebra involved in finding the expressions for the jumps across the waves and the wave speeds, which we’ll skip (by see my notes). Instead we’ll just use this solver to give us the state.</p>
<p>One we have the interface state, we can compute the fluxes using this state:</p>
<div id="cell-27" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cons_flux(state, v):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" given an interface state, return the conservative flux"""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    flux <span class="op">=</span> np.zeros((v.nvar), dtype<span class="op">=</span>np.float64)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    flux[v.urho] <span class="op">=</span> state.rho <span class="op">*</span> state.u</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    flux[v.umx] <span class="op">=</span> flux[v.urho] <span class="op">*</span> state.u <span class="op">+</span> state.p</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    flux[v.uener] <span class="op">=</span> (<span class="fl">0.5</span> <span class="op">*</span> state.rho <span class="op">*</span> state.u<span class="op">**</span><span class="dv">2</span> <span class="op">+</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>                     state.p<span class="op">/</span>(v.gamma <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">+</span> state.p) <span class="op">*</span> state.u</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flux</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-28" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;slide&quot;}" data-execution_count="29">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> riemann_exact <span class="im">as</span> re</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">help</span>(re)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Help on module riemann_exact:

NAME
    riemann_exact

DESCRIPTION
    An exact Riemann solver for the Euler equations with a gamma-law
    gas.  The left and right states are stored as State objects.  We then
    create a RiemannProblem object with the left and right state:
    
    &gt; rp = RiemannProblem(left_state, right_state)
    
    Next we solve for the star state:
    
    &gt; rp.find_star_state()
    
    Finally, we sample the solution to find the interface state, which
    is returned as a State object:
    
    &gt; q_int = rp.sample_solution()

CLASSES
    builtins.object
        RiemannProblem
        State
    
    class RiemannProblem(builtins.object)
     |  RiemannProblem(left_state, right_state, gamma=1.4)
     |  
     |  a class to define a Riemann problem.  It takes a left
     |  and right state.  Note: we assume a constant gamma
     |  
     |  Methods defined here:
     |  
     |  __init__(self, left_state, right_state, gamma=1.4)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  find_star_state(self, p_min=0.001, p_max=1000.0)
     |      root find the Hugoniot curve to find ustar, pstar
     |  
     |  rarefaction_solution(self, sgn, state)
     |      return the interface solution considering a rarefaction wave
     |  
     |  sample_solution(self)
     |      given the star state (ustar, pstar), find the state on the interface
     |  
     |  shock_solution(self, sgn, state)
     |      return the interface solution considering a shock
     |  
     |  u_hugoniot(self, p, side)
     |      define the Hugoniot curve, u(p).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables
     |  
     |  __weakref__
     |      list of weak references to the object
    
    class State(builtins.object)
     |  State(p=1.0, u=0.0, rho=1.0)
     |  
     |  a simple object to hold a primitive variable state
     |  
     |  Methods defined here:
     |  
     |  __init__(self, p=1.0, u=0.0, rho=1.0)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables
     |  
     |  __weakref__
     |      list of weak references to the object

FUNCTIONS
    cons_flux(state, v)
        given an interface state, return the conservative flux

FILE
    /Users/tabel/Library/Mobile Documents/com~apple~CloudDocs/Teaching/360/tutorials/riemann_exact.py

</code></pre>
</div>
</div>
<p>For a method-of-lines approach, we want to just compute the righthand side, <span class="math inline">\(A = -\partial F/\partial x\)</span>. Then we will turn our PDE into an ODE for time: <span class="math display">\[\frac{\partial \langle U\rangle_i}{\partial t} = -A_i = - \frac{F_{i+1/2} - F_{i-1/2}}{\Delta x}\]</span></p>
<p>We can then use any ODE integration method, like Runge-Kutta to solve the system.</p>
<p>This routine will take the conserved state, <span class="math inline">\(U\)</span>, construct the left and right states at all interfaces, solve the Riemann problem to get the unique state on the boundary, and then compute the advective term and return it.</p>
<div id="cell-31" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="30">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_flux_divergence(grid, U):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> FluidVars()</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># get the states</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    q_l, q_r <span class="op">=</span> states(grid, U)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># now solve the Riemann problem</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    flux <span class="op">=</span> grid.scratch_array(nc<span class="op">=</span>v.nvar)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(grid.lo, grid.hi<span class="op">+</span><span class="dv">2</span>):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        sl <span class="op">=</span> re.State(rho<span class="op">=</span>q_l[i,v.qrho], u<span class="op">=</span>q_l[i,v.qu], p<span class="op">=</span>q_l[i,v.qp])</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        sr <span class="op">=</span> re.State(rho<span class="op">=</span>q_r[i,v.qrho], u<span class="op">=</span>q_r[i,v.qu], p<span class="op">=</span>q_r[i,v.qp])</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        rp <span class="op">=</span> re.RiemannProblem(sl, sr, gamma<span class="op">=</span>v.gamma)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        rp.find_star_state()</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        q_int <span class="op">=</span> rp.sample_solution()</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        flux[i, :] <span class="op">=</span> cons_flux(q_int, v)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> grid.scratch_array(nc<span class="op">=</span>v.nvar)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(v.nvar):</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        A[grid.lo:grid.hi<span class="op">+</span><span class="dv">1</span>, n] <span class="op">=</span> (flux[grid.lo:grid.hi<span class="op">+</span><span class="dv">1</span>, n] <span class="op">-</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>                                   flux[grid.lo<span class="op">+</span><span class="dv">1</span>:grid.hi<span class="op">+</span><span class="dv">2</span>, n])<span class="op">/</span>grid.dx</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="timestep" class="level2">
<h2 class="anchored" data-anchor-id="timestep">Timestep</h2>
<p>Explicit hydro codes have a restriction on the size of the timestep. We cannot allow information to move more than one zone per step. For the hydro equations, the speeds at which information travels are <span class="math inline">\(u\)</span> and <span class="math inline">\(u \pm c\)</span>, so we use the largest speed here to compute the timestep.</p>
<div id="cell-33" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="31">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> timestep(grid, U):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> FluidVars()</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># compute the sound speed</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> cons_to_prim(grid, U)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> grid.scratch_array()</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    c[grid.lo:grid.hi<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> np.sqrt(v.gamma <span class="op">*</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>                                   q[grid.lo:grid.hi<span class="op">+</span><span class="dv">1</span>,v.qp] <span class="op">/</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                                   q[grid.lo:grid.hi<span class="op">+</span><span class="dv">1</span>,v.qrho])</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> v.C <span class="op">*</span> grid.dx <span class="op">/</span> (np.<span class="bu">abs</span>(q[grid.lo:grid.hi<span class="op">+</span><span class="dv">1</span>, v.qu]) <span class="op">+</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>                          c[grid.lo:grid.hi<span class="op">+</span><span class="dv">1</span>]).<span class="bu">max</span>()</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="main-driver" class="level2">
<h2 class="anchored" data-anchor-id="main-driver">Main driver</h2>
<p>This is the main driver. For simplicity, I’ve hardcoded the initial conditions here for the standard Sod problem. Usually those would be a separate routine.</p>
<p>This does 2nd-order RK (or Euler’s method) for the integration, and requires that we compute the advection terms twice to advance the solution by <span class="math inline">\(\Delta t\)</span>. The update looks like: <span class="math display">\[
\begin{align*}
U^\star &amp;= U^n + \frac{\Delta t}{2} A(U^n) \\
U^{n+1} &amp;= U^n + \Delta t A(U^\star)
\end{align*}
\]</span></p>
<div id="cell-35" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;slide&quot;}" data-execution_count="32">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mol_solve(nx, tmax<span class="op">=</span><span class="fl">1.0</span>, init_cond<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Perform 2nd order MOL integration of the Euler equations.</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">    You need to pass in a function foo(grid) that returns the </span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">    initial conserved fluid state."""</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    grid <span class="op">=</span> FVGrid(nx, <span class="dv">2</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> FluidVars()</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> init_cond(grid)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> t <span class="op">&lt;</span> tmax:</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        dt <span class="op">=</span> timestep(grid, U)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> t <span class="op">+</span> dt <span class="op">&gt;</span> tmax:</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            dt <span class="op">=</span> tmax <span class="op">-</span> t</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        grid.fill_BCs(U)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        k1 <span class="op">=</span> make_flux_divergence(grid, U)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        U_tmp <span class="op">=</span> grid.scratch_array(nc<span class="op">=</span>v.nvar)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(v.nvar):</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>            U_tmp[:, n] <span class="op">=</span> U[:, n] <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> dt <span class="op">*</span> k1[:, n]</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>        grid.fill_BCs(U_tmp)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        k2 <span class="op">=</span> make_flux_divergence(grid, U_tmp)</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(v.nvar):</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>            U[:, n] <span class="op">+=</span> dt <span class="op">*</span> k2[:, n]</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>        t <span class="op">+=</span> dt</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grid, U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="example-sods-problem" class="level2">
<h2 class="anchored" data-anchor-id="example-sods-problem">Example: Sod’s problem</h2>
<p>The Sod problem is a standard test problem, consisting of a left and right state separated by an initial discontinuity. As time evolves, a rightward moving shock and contact and leftward moving rarefaction form.</p>
<p>One reason this problem is so popular is that you can find the exact solution (it’s just the Riemann problem) and compare the performance of your code to the exact solution.</p>
<div id="cell-37" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;slide&quot;}" data-execution_count="33">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sod(grid):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> FluidVars()</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> grid.scratch_array(nc<span class="op">=</span>v.nvar)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># setup initial conditions -- this is Sod's problem</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    rho_l <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    u_l <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    p_l <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    rho_r <span class="op">=</span> <span class="fl">0.125</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    u_r <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    p_r <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    idx_l <span class="op">=</span> grid.x <span class="op">&lt;</span> <span class="fl">0.5</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    idx_r <span class="op">=</span> grid.x <span class="op">&gt;=</span> <span class="fl">0.5</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    U[idx_l, v.urho] <span class="op">=</span> rho_l</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    U[idx_l, v.umx] <span class="op">=</span>  rho_l <span class="op">*</span> u_l</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    U[idx_l, v.uener] <span class="op">=</span> p_l<span class="op">/</span>(v.gamma <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> rho_l <span class="op">*</span> u_l<span class="op">**</span><span class="dv">2</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    U[idx_r, v.urho] <span class="op">=</span> rho_r</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    U[idx_r, v.umx] <span class="op">=</span>  rho_r <span class="op">*</span> u_r</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    U[idx_r, v.uener] <span class="op">=</span> p_r<span class="op">/</span>(v.gamma <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> rho_r <span class="op">*</span> u_r<span class="op">**</span><span class="dv">2</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-38" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;slide&quot;}" data-execution_count="34">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>g, U <span class="op">=</span> mol_solve(<span class="dv">128</span>, tmax<span class="op">=</span><span class="fl">0.2</span>, init_cond<span class="op">=</span>sod)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-39" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="37">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'figure.dpi'</span>] <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'figure.figsize'</span>] <span class="op">=</span> [<span class="dv">8</span>, <span class="dv">6</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-40" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="38">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>sod <span class="op">=</span> np.genfromtxt(<span class="st">"sod-exact.out"</span>, skip_header<span class="op">=</span><span class="dv">2</span>, names<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-41" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;slide&quot;}" data-execution_count="39">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> FluidVars()</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>plt.scatter(g.x, U[:,v.urho], marker<span class="op">=</span><span class="st">"x"</span>, color<span class="op">=</span><span class="st">"C0"</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>plt.plot(sod[<span class="st">"x"</span>], sod[<span class="st">"rho"</span>], color<span class="op">=</span><span class="st">"C1"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="zingale_write_a_hydrocode_files/figure-html/cell-16-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="exercises" class="level2">
<h2 class="anchored" data-anchor-id="exercises">Exercises</h2>
<ol type="1">
<li><p>Run the problem without limiting the slopes to see how it compares</p></li>
<li><p>Try a higher-order Runge-Kutta time integration methods to see how the problem changes</p></li>
<li><p>Implement periodic boundary conditions and create a new set of initial conditions that just puts a low amplitude Gaussian pulse—this will create an acoustic wave that propagates through the domain.</p></li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/KIPAC\.github\.io\/360\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>